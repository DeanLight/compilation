[FIRST_PROGRAM_POINT]
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token bool__
Lex Ate token  id__True__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[True]>>
FuncHead_IR for func: True
got label label_29 in line: -1
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: True
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__False__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[False]>>
FuncHead_IR for func: False
got label label_50 in line: -1
written label: label_50
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: False
for an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
FuncHead_IR for func: main
got label label_71 in line: -1
written label: label_71
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token bool__
Lex Ate token  id__t__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[t]type:[]>>
<<Statement_Semantic with id[t]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States->SignleState]  nextlistSize=3
Lex Ate token bool__
[MARKER IR]: label: bp_label_8
Lex Ate token  id__f__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[f]type:[]>>
<<Statement_Semantic with id[f]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_8 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_9
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token )__
[MARKER IR]: label: bp_label_10
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_11
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_9 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_13
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_14
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_15
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_13 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_17
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_18
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_19
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_17 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_21
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_22
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_23
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_21 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_25
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_26
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_27
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_25 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_29
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[MARKER IR]: label: bp_label_30
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_31
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_29 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_33
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[MARKER IR]: label: bp_label_34
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_35
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_33 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_37
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_38
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_39
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_37 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_41
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_42
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_43
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_41 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_45
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_46
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_47
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_45 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_49
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_50
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_51
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_52
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_49 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_54
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_55
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_56
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_57
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_54 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_59
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_60
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_61
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_62
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_59 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_64
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_65
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_66
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_67
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_64 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_69
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_70
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_71
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_72
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_69 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_74
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_75
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:False falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_76
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_77
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_74 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_79
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_80
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:false falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_81
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_82
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_79 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_84
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_85
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:f falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_86
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_87
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_84 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_89
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_90
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_91
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_92
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_89 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_94
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_95
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_96
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_97
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_94 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_99
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_100
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_101
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_102
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_99 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_104
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_105
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_106
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_107
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_104 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_109
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_110
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_111
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_112
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_109 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_114
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_115
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_116
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_117
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_114 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_119
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_120
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_121
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_122
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_119 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_124
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_125
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_126
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_127
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_124 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_129
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_130
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_131
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_132
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_129 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_134
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_135
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_136
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_137
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_134 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_139
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_140
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_141
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_142
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_139 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_144
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_145
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_146
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_147
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_144 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_149
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_150
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_151
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_152
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_149 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_154
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_155
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_156
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_157
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_154 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_159
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_160
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_161
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_162
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_159 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_164
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_165
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_166
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_167
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_164 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_169
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_170
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_171
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_172
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_169 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_174
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_175
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_176
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_177
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_174 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_179
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_180
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_181
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_182
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_179 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_184
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_185
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_186
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_187
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_184 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_189
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_190
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_191
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_192
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_189 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_194
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token and__
[MARKER IR]: label: bp_label_195
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_196
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_197
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_194 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_199
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_200
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:False falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_201
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_202
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_199 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_204
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_205
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:false falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_206
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_207
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_204 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_209
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_210
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:f falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_211
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_212
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_209 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_214
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_215
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_216
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_217
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_214 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_219
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token and__
[MARKER IR]: label: bp_label_220
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_221
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_222
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_219 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_224
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_225
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_226
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_227
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_224 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_229
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_230
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_231
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_232
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_229 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_234
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_235
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_236
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_237
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_234 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_239
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_240
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_241
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_242
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_239 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_244
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_245
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_246
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_247
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_244 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_249
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_250
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_251
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_252
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_249 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_254
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_255
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_256
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_257
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_254 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_259
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_260
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_261
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_262
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_259 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_264
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_265
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_266
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_267
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_264 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_269
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_270
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_271
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_272
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_269 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_274
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_275
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_276
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_277
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_274 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_279
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_280
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_281
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_282
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_279 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_284
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_285
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_286
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_287
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_284 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_289
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_290
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_291
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_292
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_289 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_294
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_295
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_296
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_297
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_294 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_299
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token and__
[MARKER IR]: label: bp_label_300
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_301
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_302
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_299 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_304
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token and__
[MARKER IR]: label: bp_label_305
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_306
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_307
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_304 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_309
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token and__
[MARKER IR]: label: bp_label_310
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_311
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_312
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_309 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_314
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token and__
[MARKER IR]: label: bp_label_315
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_316
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_317
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_314 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_319
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token and__
[MARKER IR]: label: bp_label_320
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_321
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_322
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_319 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_324
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_325
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_326
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_327
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_324 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_329
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_330
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_331
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_332
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_329 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_334
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_335
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_336
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_337
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_334 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_339
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_340
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_341
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_342
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_339 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_344
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_345
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_346
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_347
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_344 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_349
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_350
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_351
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_352
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_349 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_354
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_355
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_356
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_357
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_354 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_359
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_360
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_361
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_362
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_359 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_364
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_365
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_366
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_367
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_364 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_369
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_370
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_371
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_372
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_369 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_374
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_375
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_376
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_377
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_374 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_379
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_380
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_381
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_382
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_379 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_384
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_385
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_386
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_387
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_384 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_389
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_390
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_391
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_392
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_389 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_394
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_395
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_396
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_397
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_394 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_399
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_400
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_401
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_402
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_399 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_404
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_405
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_406
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_407
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_404 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_409
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_410
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_411
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_412
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_409 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_414
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_415
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_416
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_417
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_414 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_419
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_420
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_421
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_422
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_419 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_424
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token or__
[MARKER IR]: label: bp_label_425
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_425
exp1:True truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_426
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_427
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_424 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_429
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token or__
[MARKER IR]: label: bp_label_430
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_430
exp1:True truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_431
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_432
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_429 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_434
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token or__
[MARKER IR]: label: bp_label_435
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_435
exp1:True truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_436
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_437
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_434 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_439
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token or__
[MARKER IR]: label: bp_label_440
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_440
exp1:True truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_441
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_442
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_439 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_444
Lex Ate token  (__
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
[SJ_Exp_IR]: True
Lex Ate token or__
[MARKER IR]: label: bp_label_445
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_445
exp1:True truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_446
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_447
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_444 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_449
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_450
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_450
exp1:true truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_451
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_452
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_449 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_454
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_455
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_455
exp1:true truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_456
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_457
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_454 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_459
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_460
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_460
exp1:true truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_461
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_462
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_459 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_464
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_465
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_465
exp1:true truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_466
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_467
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_464 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_469
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_470
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_470
exp1:true truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_471
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_472
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_469 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_474
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_475
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_475
exp1:t truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_476
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_477
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_474 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_479
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_480
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_480
exp1:t truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_481
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_482
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_479 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_484
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_485
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_485
exp1:t truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_486
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_487
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_484 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_489
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_490
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_490
exp1:t truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_491
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_492
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_489 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_494
Lex Ate token  (__
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_495
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_495
exp1:t truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_496
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_497
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_494 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_499
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_500
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_500
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_501
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_502
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_499 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_504
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_505
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_505
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_506
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_507
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_504 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_509
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_510
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_510
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_511
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_512
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_509 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_514
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_515
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_515
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_516
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_517
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_514 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_519
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_520
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_520
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_521
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_522
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_519 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_524
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_525
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_525
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_526
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_527
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_524 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_529
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_530
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_530
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_531
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_532
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_529 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_534
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_535
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_535
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_536
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_537
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_534 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_539
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_540
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_540
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_541
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_542
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_539 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_544
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_545
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_545
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_546
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_547
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_544 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_549
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_550
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_550
exp1:False truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_551
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_552
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_549 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_554
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_555
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_555
exp1:False truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_556
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_557
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_554 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_559
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_560
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_560
exp1:False truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_561
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_562
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_559 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_564
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_565
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_565
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_566
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_567
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_564 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_569
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_570
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_570
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_571
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_572
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_569 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_574
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_575
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_575
exp1:false truelistSize: 0
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_576
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_577
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_574 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_579
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_580
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_580
exp1:false truelistSize: 0
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_581
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_582
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_579 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_584
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_585
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_585
exp1:false truelistSize: 0
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_586
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_587
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_584 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_589
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_590
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_590
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_591
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_592
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_589 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_594
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_595
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_595
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_596
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_597
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_594 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_599
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_600
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_600
exp1:f truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_601
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_602
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_599 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_604
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_605
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_605
exp1:f truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_606
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_607
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_604 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_609
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_610
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_610
exp1:f truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_611
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_612
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_609 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_614
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_615
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_615
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_616
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_617
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_614 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_619
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_620
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_620
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_621
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_622
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_619 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_624
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_625
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_625
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_626
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_627
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_624 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_629
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_630
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_630
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_631
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_632
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_629 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_634
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_635
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_635
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_636
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_637
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_634 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_639
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_640
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_640
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_641
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_642
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_639 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_644
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_645
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_645
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_646
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_647
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_644 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_649
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_650
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_650
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_651
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_652
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_649 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_654
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_655
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_655
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_656
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_657
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_654 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_659
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_660
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_660
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_661
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_662
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_659 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_664
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_665
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_665
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_666
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_667
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_664 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_669
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_670
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_670
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_671
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_672
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_669 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_674
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_675
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_675
exp1:False truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_676
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_677
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_674 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_679
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_680
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_680
exp1:False truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_681
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_682
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_679 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_684
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_685
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_685
exp1:False truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_686
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_687
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_684 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_689
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_690
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_690
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_691
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_692
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_689 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_694
Lex Ate token  (__
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token or__
[MARKER IR]: label: bp_label_695
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_695
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_696
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_697
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_694 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_699
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_700
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_700
exp1:false truelistSize: 0
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_701
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_702
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_699 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_704
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_705
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_705
exp1:false truelistSize: 0
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 0
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_706
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_707
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_704 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_709
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_710
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_710
exp1:false truelistSize: 0
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_711
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_712
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_709 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_714
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_715
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_715
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_716
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_717
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_714 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_719
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token or__
[MARKER IR]: label: bp_label_720
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_720
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_721
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_722
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_719 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_724
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_725
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_725
exp1:f truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_726
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_727
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_724 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_729
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_730
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_730
exp1:f truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_731
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_732
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_729 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_734
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_735
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_735
exp1:f truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_736
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_737
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_734 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_739
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_740
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_740
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_741
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_742
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_739 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_744
Lex Ate token  (__
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_745
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_745
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_746
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_747
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_744 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_749
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_750
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_750
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_751
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_752
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_749 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_754
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_755
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_755
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_756
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_757
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_754 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_759
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_760
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_760
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_761
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_762
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_759 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_764
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_765
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_765
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_766
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_767
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_764 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_769
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_770
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_770
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_771
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_772
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_769 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_774
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_775
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_775
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_776
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_777
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_774 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_779
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_780
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_780
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_781
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_782
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_779 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_784
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_785
Lex Ate token  id__f__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_785
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_786
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_787
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_784 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_789
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_790
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_790
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_791
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_792
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_789 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_794
Lex Ate token  (__
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_795
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_795
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_796
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"yes\n"__
[Exp_IR] Exp -> string"yes\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_797
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"no\n"__
[Exp_IR] Exp -> string"no\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_794 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
for an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with label_71
[END_OF Program_IR]



 == printing data === 



pvufne1:	.asciiz "Error division by zero
"
string_label_0:	.asciiz "yes\n"
string_label_1:	.asciiz "yes\n"
string_label_2:	.asciiz "no\n"
string_label_3:	.asciiz "no\n"
string_label_4:	.asciiz "yes\n"
string_label_5:	.asciiz "yes\n"
string_label_6:	.asciiz "no\n"
string_label_7:	.asciiz "no\n"
string_label_8:	.asciiz "yes\n"
string_label_9:	.asciiz "yes\n"
string_label_10:	.asciiz "no\n"
string_label_11:	.asciiz "no\n"
string_label_12:	.asciiz "yes\n"
string_label_13:	.asciiz "yes\n"
string_label_14:	.asciiz "no\n"
string_label_15:	.asciiz "no\n"
string_label_16:	.asciiz "yes\n"
string_label_17:	.asciiz "yes\n"
string_label_18:	.asciiz "no\n"
string_label_19:	.asciiz "no\n"
string_label_20:	.asciiz "yes\n"
string_label_21:	.asciiz "yes\n"
string_label_22:	.asciiz "no\n"
string_label_23:	.asciiz "no\n"
string_label_24:	.asciiz "yes\n"
string_label_25:	.asciiz "yes\n"
string_label_26:	.asciiz "no\n"
string_label_27:	.asciiz "no\n"
string_label_28:	.asciiz "yes\n"
string_label_29:	.asciiz "yes\n"
string_label_30:	.asciiz "no\n"
string_label_31:	.asciiz "no\n"
string_label_32:	.asciiz "yes\n"
string_label_33:	.asciiz "yes\n"
string_label_34:	.asciiz "no\n"
string_label_35:	.asciiz "no\n"
string_label_36:	.asciiz "yes\n"
string_label_37:	.asciiz "yes\n"
string_label_38:	.asciiz "no\n"
string_label_39:	.asciiz "no\n"
string_label_40:	.asciiz "yes\n"
string_label_41:	.asciiz "yes\n"
string_label_42:	.asciiz "no\n"
string_label_43:	.asciiz "no\n"
string_label_44:	.asciiz "yes\n"
string_label_45:	.asciiz "yes\n"
string_label_46:	.asciiz "no\n"
string_label_47:	.asciiz "no\n"
string_label_48:	.asciiz "yes\n"
string_label_49:	.asciiz "yes\n"
string_label_50:	.asciiz "no\n"
string_label_51:	.asciiz "no\n"
string_label_52:	.asciiz "yes\n"
string_label_53:	.asciiz "yes\n"
string_label_54:	.asciiz "no\n"
string_label_55:	.asciiz "no\n"
string_label_56:	.asciiz "yes\n"
string_label_57:	.asciiz "yes\n"
string_label_58:	.asciiz "no\n"
string_label_59:	.asciiz "no\n"
string_label_60:	.asciiz "yes\n"
string_label_61:	.asciiz "yes\n"
string_label_62:	.asciiz "no\n"
string_label_63:	.asciiz "no\n"
string_label_64:	.asciiz "yes\n"
string_label_65:	.asciiz "yes\n"
string_label_66:	.asciiz "no\n"
string_label_67:	.asciiz "no\n"
string_label_68:	.asciiz "yes\n"
string_label_69:	.asciiz "yes\n"
string_label_70:	.asciiz "no\n"
string_label_71:	.asciiz "no\n"
string_label_72:	.asciiz "yes\n"
string_label_73:	.asciiz "yes\n"
string_label_74:	.asciiz "no\n"
string_label_75:	.asciiz "no\n"
string_label_76:	.asciiz "yes\n"
string_label_77:	.asciiz "yes\n"
string_label_78:	.asciiz "no\n"
string_label_79:	.asciiz "no\n"
string_label_80:	.asciiz "yes\n"
string_label_81:	.asciiz "yes\n"
string_label_82:	.asciiz "no\n"
string_label_83:	.asciiz "no\n"
string_label_84:	.asciiz "yes\n"
string_label_85:	.asciiz "yes\n"
string_label_86:	.asciiz "no\n"
string_label_87:	.asciiz "no\n"
string_label_88:	.asciiz "yes\n"
string_label_89:	.asciiz "yes\n"
string_label_90:	.asciiz "no\n"
string_label_91:	.asciiz "no\n"
string_label_92:	.asciiz "yes\n"
string_label_93:	.asciiz "yes\n"
string_label_94:	.asciiz "no\n"
string_label_95:	.asciiz "no\n"
string_label_96:	.asciiz "yes\n"
string_label_97:	.asciiz "yes\n"
string_label_98:	.asciiz "no\n"
string_label_99:	.asciiz "no\n"
string_label_100:	.asciiz "yes\n"
string_label_101:	.asciiz "yes\n"
string_label_102:	.asciiz "no\n"
string_label_103:	.asciiz "no\n"
string_label_104:	.asciiz "yes\n"
string_label_105:	.asciiz "yes\n"
string_label_106:	.asciiz "no\n"
string_label_107:	.asciiz "no\n"
string_label_108:	.asciiz "yes\n"
string_label_109:	.asciiz "yes\n"
string_label_110:	.asciiz "no\n"
string_label_111:	.asciiz "no\n"
string_label_112:	.asciiz "yes\n"
string_label_113:	.asciiz "yes\n"
string_label_114:	.asciiz "no\n"
string_label_115:	.asciiz "no\n"
string_label_116:	.asciiz "yes\n"
string_label_117:	.asciiz "yes\n"
string_label_118:	.asciiz "no\n"
string_label_119:	.asciiz "no\n"
string_label_120:	.asciiz "yes\n"
string_label_121:	.asciiz "yes\n"
string_label_122:	.asciiz "no\n"
string_label_123:	.asciiz "no\n"
string_label_124:	.asciiz "yes\n"
string_label_125:	.asciiz "yes\n"
string_label_126:	.asciiz "no\n"
string_label_127:	.asciiz "no\n"
string_label_128:	.asciiz "yes\n"
string_label_129:	.asciiz "yes\n"
string_label_130:	.asciiz "no\n"
string_label_131:	.asciiz "no\n"
string_label_132:	.asciiz "yes\n"
string_label_133:	.asciiz "yes\n"
string_label_134:	.asciiz "no\n"
string_label_135:	.asciiz "no\n"
string_label_136:	.asciiz "yes\n"
string_label_137:	.asciiz "yes\n"
string_label_138:	.asciiz "no\n"
string_label_139:	.asciiz "no\n"
string_label_140:	.asciiz "yes\n"
string_label_141:	.asciiz "yes\n"
string_label_142:	.asciiz "no\n"
string_label_143:	.asciiz "no\n"
string_label_144:	.asciiz "yes\n"
string_label_145:	.asciiz "yes\n"
string_label_146:	.asciiz "no\n"
string_label_147:	.asciiz "no\n"
string_label_148:	.asciiz "yes\n"
string_label_149:	.asciiz "yes\n"
string_label_150:	.asciiz "no\n"
string_label_151:	.asciiz "no\n"
string_label_152:	.asciiz "yes\n"
string_label_153:	.asciiz "yes\n"
string_label_154:	.asciiz "no\n"
string_label_155:	.asciiz "no\n"
string_label_156:	.asciiz "yes\n"
string_label_157:	.asciiz "yes\n"
string_label_158:	.asciiz "no\n"
string_label_159:	.asciiz "no\n"
string_label_160:	.asciiz "yes\n"
string_label_161:	.asciiz "yes\n"
string_label_162:	.asciiz "no\n"
string_label_163:	.asciiz "no\n"
string_label_164:	.asciiz "yes\n"
string_label_165:	.asciiz "yes\n"
string_label_166:	.asciiz "no\n"
string_label_167:	.asciiz "no\n"
string_label_168:	.asciiz "yes\n"
string_label_169:	.asciiz "yes\n"
string_label_170:	.asciiz "no\n"
string_label_171:	.asciiz "no\n"
string_label_172:	.asciiz "yes\n"
string_label_173:	.asciiz "yes\n"
string_label_174:	.asciiz "no\n"
string_label_175:	.asciiz "no\n"
string_label_176:	.asciiz "yes\n"
string_label_177:	.asciiz "yes\n"
string_label_178:	.asciiz "no\n"
string_label_179:	.asciiz "no\n"
string_label_180:	.asciiz "yes\n"
string_label_181:	.asciiz "yes\n"
string_label_182:	.asciiz "no\n"
string_label_183:	.asciiz "no\n"
string_label_184:	.asciiz "yes\n"
string_label_185:	.asciiz "yes\n"
string_label_186:	.asciiz "no\n"
string_label_187:	.asciiz "no\n"
string_label_188:	.asciiz "yes\n"
string_label_189:	.asciiz "yes\n"
string_label_190:	.asciiz "no\n"
string_label_191:	.asciiz "no\n"
string_label_192:	.asciiz "yes\n"
string_label_193:	.asciiz "yes\n"
string_label_194:	.asciiz "no\n"
string_label_195:	.asciiz "no\n"
string_label_196:	.asciiz "yes\n"
string_label_197:	.asciiz "yes\n"
string_label_198:	.asciiz "no\n"
string_label_199:	.asciiz "no\n"
string_label_200:	.asciiz "yes\n"
string_label_201:	.asciiz "yes\n"
string_label_202:	.asciiz "no\n"
string_label_203:	.asciiz "no\n"
string_label_204:	.asciiz "yes\n"
string_label_205:	.asciiz "yes\n"
string_label_206:	.asciiz "no\n"
string_label_207:	.asciiz "no\n"
string_label_208:	.asciiz "yes\n"
string_label_209:	.asciiz "yes\n"
string_label_210:	.asciiz "no\n"
string_label_211:	.asciiz "no\n"
string_label_212:	.asciiz "yes\n"
string_label_213:	.asciiz "yes\n"
string_label_214:	.asciiz "no\n"
string_label_215:	.asciiz "no\n"
string_label_216:	.asciiz "yes\n"
string_label_217:	.asciiz "yes\n"
string_label_218:	.asciiz "no\n"
string_label_219:	.asciiz "no\n"
string_label_220:	.asciiz "yes\n"
string_label_221:	.asciiz "yes\n"
string_label_222:	.asciiz "no\n"
string_label_223:	.asciiz "no\n"
string_label_224:	.asciiz "yes\n"
string_label_225:	.asciiz "yes\n"
string_label_226:	.asciiz "no\n"
string_label_227:	.asciiz "no\n"
string_label_228:	.asciiz "yes\n"
string_label_229:	.asciiz "yes\n"
string_label_230:	.asciiz "no\n"
string_label_231:	.asciiz "no\n"
string_label_232:	.asciiz "yes\n"
string_label_233:	.asciiz "yes\n"
string_label_234:	.asciiz "no\n"
string_label_235:	.asciiz "no\n"
string_label_236:	.asciiz "yes\n"
string_label_237:	.asciiz "yes\n"
string_label_238:	.asciiz "no\n"
string_label_239:	.asciiz "no\n"
string_label_240:	.asciiz "yes\n"
string_label_241:	.asciiz "yes\n"
string_label_242:	.asciiz "no\n"
string_label_243:	.asciiz "no\n"
string_label_244:	.asciiz "yes\n"
string_label_245:	.asciiz "yes\n"
string_label_246:	.asciiz "no\n"
string_label_247:	.asciiz "no\n"
string_label_248:	.asciiz "yes\n"
string_label_249:	.asciiz "yes\n"
string_label_250:	.asciiz "no\n"
string_label_251:	.asciiz "no\n"
string_label_252:	.asciiz "yes\n"
string_label_253:	.asciiz "yes\n"
string_label_254:	.asciiz "no\n"
string_label_255:	.asciiz "no\n"
string_label_256:	.asciiz "yes\n"
string_label_257:	.asciiz "yes\n"
string_label_258:	.asciiz "no\n"
string_label_259:	.asciiz "no\n"
string_label_260:	.asciiz "yes\n"
string_label_261:	.asciiz "yes\n"
string_label_262:	.asciiz "no\n"
string_label_263:	.asciiz "no\n"
string_label_264:	.asciiz "yes\n"
string_label_265:	.asciiz "yes\n"
string_label_266:	.asciiz "no\n"
string_label_267:	.asciiz "no\n"
string_label_268:	.asciiz "yes\n"
string_label_269:	.asciiz "yes\n"
string_label_270:	.asciiz "no\n"
string_label_271:	.asciiz "no\n"
string_label_272:	.asciiz "yes\n"
string_label_273:	.asciiz "yes\n"
string_label_274:	.asciiz "no\n"
string_label_275:	.asciiz "no\n"
string_label_276:	.asciiz "yes\n"
string_label_277:	.asciiz "yes\n"
string_label_278:	.asciiz "no\n"
string_label_279:	.asciiz "no\n"
string_label_280:	.asciiz "yes\n"
string_label_281:	.asciiz "yes\n"
string_label_282:	.asciiz "no\n"
string_label_283:	.asciiz "no\n"
string_label_284:	.asciiz "yes\n"
string_label_285:	.asciiz "yes\n"
string_label_286:	.asciiz "no\n"
string_label_287:	.asciiz "no\n"
string_label_288:	.asciiz "yes\n"
string_label_289:	.asciiz "yes\n"
string_label_290:	.asciiz "no\n"
string_label_291:	.asciiz "no\n"
string_label_292:	.asciiz "yes\n"
string_label_293:	.asciiz "yes\n"
string_label_294:	.asciiz "no\n"
string_label_295:	.asciiz "no\n"
string_label_296:	.asciiz "yes\n"
string_label_297:	.asciiz "yes\n"
string_label_298:	.asciiz "no\n"
string_label_299:	.asciiz "no\n"
string_label_300:	.asciiz "yes\n"
string_label_301:	.asciiz "yes\n"
string_label_302:	.asciiz "no\n"
string_label_303:	.asciiz "no\n"
string_label_304:	.asciiz "yes\n"
string_label_305:	.asciiz "yes\n"
string_label_306:	.asciiz "no\n"
string_label_307:	.asciiz "no\n"
string_label_308:	.asciiz "yes\n"
string_label_309:	.asciiz "yes\n"
string_label_310:	.asciiz "no\n"
string_label_311:	.asciiz "no\n"
string_label_312:	.asciiz "yes\n"
string_label_313:	.asciiz "yes\n"
string_label_314:	.asciiz "no\n"
string_label_315:	.asciiz "no\n"
string_label_316:	.asciiz "yes\n"
string_label_317:	.asciiz "yes\n"
string_label_318:	.asciiz "no\n"
string_label_319:	.asciiz "no\n"
string_label_320:	.asciiz "yes\n"
string_label_321:	.asciiz "yes\n"
string_label_322:	.asciiz "no\n"
string_label_323:	.asciiz "no\n"
string_label_324:	.asciiz "yes\n"
string_label_325:	.asciiz "yes\n"
string_label_326:	.asciiz "no\n"
string_label_327:	.asciiz "no\n"
string_label_328:	.asciiz "yes\n"
string_label_329:	.asciiz "yes\n"
string_label_330:	.asciiz "no\n"
string_label_331:	.asciiz "no\n"
string_label_332:	.asciiz "yes\n"
string_label_333:	.asciiz "yes\n"
string_label_334:	.asciiz "no\n"
string_label_335:	.asciiz "no\n"
string_label_336:	.asciiz "yes\n"
string_label_337:	.asciiz "yes\n"
string_label_338:	.asciiz "no\n"
string_label_339:	.asciiz "no\n"
string_label_340:	.asciiz "yes\n"
string_label_341:	.asciiz "yes\n"
string_label_342:	.asciiz "no\n"
string_label_343:	.asciiz "no\n"
string_label_344:	.asciiz "yes\n"
string_label_345:	.asciiz "yes\n"
string_label_346:	.asciiz "no\n"
string_label_347:	.asciiz "no\n"
string_label_348:	.asciiz "yes\n"
string_label_349:	.asciiz "yes\n"
string_label_350:	.asciiz "no\n"
string_label_351:	.asciiz "no\n"
string_label_352:	.asciiz "yes\n"
string_label_353:	.asciiz "yes\n"
string_label_354:	.asciiz "no\n"
string_label_355:	.asciiz "no\n"
string_label_356:	.asciiz "yes\n"
string_label_357:	.asciiz "yes\n"
string_label_358:	.asciiz "no\n"
string_label_359:	.asciiz "no\n"
string_label_360:	.asciiz "yes\n"
string_label_361:	.asciiz "yes\n"
string_label_362:	.asciiz "no\n"
string_label_363:	.asciiz "no\n"
string_label_364:	.asciiz "yes\n"
string_label_365:	.asciiz "yes\n"
string_label_366:	.asciiz "no\n"
string_label_367:	.asciiz "no\n"
string_label_368:	.asciiz "yes\n"
string_label_369:	.asciiz "yes\n"
string_label_370:	.asciiz "no\n"
string_label_371:	.asciiz "no\n"
string_label_372:	.asciiz "yes\n"
string_label_373:	.asciiz "yes\n"
string_label_374:	.asciiz "no\n"
string_label_375:	.asciiz "no\n"
string_label_376:	.asciiz "yes\n"
string_label_377:	.asciiz "yes\n"
string_label_378:	.asciiz "no\n"
string_label_379:	.asciiz "no\n"
string_label_380:	.asciiz "yes\n"
string_label_381:	.asciiz "yes\n"
string_label_382:	.asciiz "no\n"
string_label_383:	.asciiz "no\n"
string_label_384:	.asciiz "yes\n"
string_label_385:	.asciiz "yes\n"
string_label_386:	.asciiz "no\n"
string_label_387:	.asciiz "no\n"
string_label_388:	.asciiz "yes\n"
string_label_389:	.asciiz "yes\n"
string_label_390:	.asciiz "no\n"
string_label_391:	.asciiz "no\n"
string_label_392:	.asciiz "yes\n"
string_label_393:	.asciiz "yes\n"
string_label_394:	.asciiz "no\n"
string_label_395:	.asciiz "no\n"
string_label_396:	.asciiz "yes\n"
string_label_397:	.asciiz "yes\n"
string_label_398:	.asciiz "no\n"
string_label_399:	.asciiz "no\n"
string_label_400:	.asciiz "yes\n"
string_label_401:	.asciiz "yes\n"
string_label_402:	.asciiz "no\n"
string_label_403:	.asciiz "no\n"
string_label_404:	.asciiz "yes\n"
string_label_405:	.asciiz "yes\n"
string_label_406:	.asciiz "no\n"
string_label_407:	.asciiz "no\n"
string_label_408:	.asciiz "yes\n"
string_label_409:	.asciiz "yes\n"
string_label_410:	.asciiz "no\n"
string_label_411:	.asciiz "no\n"
string_label_412:	.asciiz "yes\n"
string_label_413:	.asciiz "yes\n"
string_label_414:	.asciiz "no\n"
string_label_415:	.asciiz "no\n"
string_label_416:	.asciiz "yes\n"
string_label_417:	.asciiz "yes\n"
string_label_418:	.asciiz "no\n"
string_label_419:	.asciiz "no\n"
string_label_420:	.asciiz "yes\n"
string_label_421:	.asciiz "yes\n"
string_label_422:	.asciiz "no\n"
string_label_423:	.asciiz "no\n"
string_label_424:	.asciiz "yes\n"
string_label_425:	.asciiz "yes\n"
string_label_426:	.asciiz "no\n"
string_label_427:	.asciiz "no\n"
string_label_428:	.asciiz "yes\n"
string_label_429:	.asciiz "yes\n"
string_label_430:	.asciiz "no\n"
string_label_431:	.asciiz "no\n"
string_label_432:	.asciiz "yes\n"
string_label_433:	.asciiz "yes\n"
string_label_434:	.asciiz "no\n"
string_label_435:	.asciiz "no\n"
string_label_436:	.asciiz "yes\n"
string_label_437:	.asciiz "yes\n"
string_label_438:	.asciiz "no\n"
string_label_439:	.asciiz "no\n"
string_label_440:	.asciiz "yes\n"
string_label_441:	.asciiz "yes\n"
string_label_442:	.asciiz "no\n"
string_label_443:	.asciiz "no\n"
string_label_444:	.asciiz "yes\n"
string_label_445:	.asciiz "yes\n"
string_label_446:	.asciiz "no\n"
string_label_447:	.asciiz "no\n"
string_label_448:	.asciiz "yes\n"
string_label_449:	.asciiz "yes\n"
string_label_450:	.asciiz "no\n"
string_label_451:	.asciiz "no\n"
string_label_452:	.asciiz "yes\n"
string_label_453:	.asciiz "yes\n"
string_label_454:	.asciiz "no\n"
string_label_455:	.asciiz "no\n"
string_label_456:	.asciiz "yes\n"
string_label_457:	.asciiz "yes\n"
string_label_458:	.asciiz "no\n"
string_label_459:	.asciiz "no\n"
string_label_460:	.asciiz "yes\n"
string_label_461:	.asciiz "yes\n"
string_label_462:	.asciiz "no\n"
string_label_463:	.asciiz "no\n"
string_label_464:	.asciiz "yes\n"
string_label_465:	.asciiz "yes\n"
string_label_466:	.asciiz "no\n"
string_label_467:	.asciiz "no\n"
string_label_468:	.asciiz "yes\n"
string_label_469:	.asciiz "yes\n"
string_label_470:	.asciiz "no\n"
string_label_471:	.asciiz "no\n"
string_label_472:	.asciiz "yes\n"
string_label_473:	.asciiz "yes\n"
string_label_474:	.asciiz "no\n"
string_label_475:	.asciiz "no\n"
string_label_476:	.asciiz "yes\n"
string_label_477:	.asciiz "yes\n"
string_label_478:	.asciiz "no\n"
string_label_479:	.asciiz "no\n"
string_label_480:	.asciiz "yes\n"
string_label_481:	.asciiz "yes\n"
string_label_482:	.asciiz "no\n"
string_label_483:	.asciiz "no\n"
string_label_484:	.asciiz "yes\n"
string_label_485:	.asciiz "yes\n"
string_label_486:	.asciiz "no\n"
string_label_487:	.asciiz "no\n"
string_label_488:	.asciiz "yes\n"
string_label_489:	.asciiz "yes\n"
string_label_490:	.asciiz "no\n"
string_label_491:	.asciiz "no\n"
string_label_492:	.asciiz "yes\n"
string_label_493:	.asciiz "yes\n"
string_label_494:	.asciiz "no\n"
string_label_495:	.asciiz "no\n"
string_label_496:	.asciiz "yes\n"
string_label_497:	.asciiz "yes\n"
string_label_498:	.asciiz "no\n"
string_label_499:	.asciiz "no\n"
string_label_500:	.asciiz "yes\n"
string_label_501:	.asciiz "yes\n"
string_label_502:	.asciiz "no\n"
string_label_503:	.asciiz "no\n"
string_label_504:	.asciiz "yes\n"
string_label_505:	.asciiz "yes\n"
string_label_506:	.asciiz "no\n"
string_label_507:	.asciiz "no\n"
string_label_508:	.asciiz "yes\n"
string_label_509:	.asciiz "yes\n"
string_label_510:	.asciiz "no\n"
string_label_511:	.asciiz "no\n"
string_label_512:	.asciiz "yes\n"
string_label_513:	.asciiz "yes\n"
string_label_514:	.asciiz "no\n"
string_label_515:	.asciiz "no\n"
string_label_516:	.asciiz "yes\n"
string_label_517:	.asciiz "yes\n"
string_label_518:	.asciiz "no\n"
string_label_519:	.asciiz "no\n"
string_label_520:	.asciiz "yes\n"
string_label_521:	.asciiz "yes\n"
string_label_522:	.asciiz "no\n"
string_label_523:	.asciiz "no\n"
string_label_524:	.asciiz "yes\n"
string_label_525:	.asciiz "yes\n"
string_label_526:	.asciiz "no\n"
string_label_527:	.asciiz "no\n"
string_label_528:	.asciiz "yes\n"
string_label_529:	.asciiz "yes\n"
string_label_530:	.asciiz "no\n"
string_label_531:	.asciiz "no\n"
string_label_532:	.asciiz "yes\n"
string_label_533:	.asciiz "yes\n"
string_label_534:	.asciiz "no\n"
string_label_535:	.asciiz "no\n"
string_label_536:	.asciiz "yes\n"
string_label_537:	.asciiz "yes\n"
string_label_538:	.asciiz "no\n"
string_label_539:	.asciiz "no\n"
string_label_540:	.asciiz "yes\n"
string_label_541:	.asciiz "yes\n"
string_label_542:	.asciiz "no\n"
string_label_543:	.asciiz "no\n"
string_label_544:	.asciiz "yes\n"
string_label_545:	.asciiz "yes\n"
string_label_546:	.asciiz "no\n"
string_label_547:	.asciiz "no\n"
string_label_548:	.asciiz "yes\n"
string_label_549:	.asciiz "yes\n"
string_label_550:	.asciiz "no\n"
string_label_551:	.asciiz "no\n"
string_label_552:	.asciiz "yes\n"
string_label_553:	.asciiz "yes\n"
string_label_554:	.asciiz "no\n"
string_label_555:	.asciiz "no\n"
string_label_556:	.asciiz "yes\n"
string_label_557:	.asciiz "yes\n"
string_label_558:	.asciiz "no\n"
string_label_559:	.asciiz "no\n"
string_label_560:	.asciiz "yes\n"
string_label_561:	.asciiz "yes\n"
string_label_562:	.asciiz "no\n"
string_label_563:	.asciiz "no\n"
string_label_564:	.asciiz "yes\n"
string_label_565:	.asciiz "yes\n"
string_label_566:	.asciiz "no\n"
string_label_567:	.asciiz "no\n"
string_label_568:	.asciiz "yes\n"
string_label_569:	.asciiz "yes\n"
string_label_570:	.asciiz "no\n"
string_label_571:	.asciiz "no\n"
string_label_572:	.asciiz "yes\n"
string_label_573:	.asciiz "yes\n"
string_label_574:	.asciiz "no\n"
string_label_575:	.asciiz "no\n"
string_label_576:	.asciiz "yes\n"
string_label_577:	.asciiz "yes\n"
string_label_578:	.asciiz "no\n"
string_label_579:	.asciiz "no\n"
string_label_580:	.asciiz "yes\n"
string_label_581:	.asciiz "yes\n"
string_label_582:	.asciiz "no\n"
string_label_583:	.asciiz "no\n"
string_label_584:	.asciiz "yes\n"
string_label_585:	.asciiz "yes\n"
string_label_586:	.asciiz "no\n"
string_label_587:	.asciiz "no\n"
string_label_588:	.asciiz "yes\n"
string_label_589:	.asciiz "yes\n"
string_label_590:	.asciiz "no\n"
string_label_591:	.asciiz "no\n"
string_label_592:	.asciiz "yes\n"
string_label_593:	.asciiz "yes\n"
string_label_594:	.asciiz "no\n"
string_label_595:	.asciiz "no\n"
string_label_596:	.asciiz "yes\n"
string_label_597:	.asciiz "yes\n"
string_label_598:	.asciiz "no\n"
string_label_599:	.asciiz "no\n"
string_label_600:	.asciiz "yes\n"
string_label_601:	.asciiz "yes\n"
string_label_602:	.asciiz "no\n"
string_label_603:	.asciiz "no\n"
string_label_604:	.asciiz "yes\n"
string_label_605:	.asciiz "yes\n"
string_label_606:	.asciiz "no\n"
string_label_607:	.asciiz "no\n"
string_label_608:	.asciiz "yes\n"
string_label_609:	.asciiz "yes\n"
string_label_610:	.asciiz "no\n"
string_label_611:	.asciiz "no\n"
string_label_612:	.asciiz "yes\n"
string_label_613:	.asciiz "yes\n"
string_label_614:	.asciiz "no\n"
string_label_615:	.asciiz "no\n"
string_label_616:	.asciiz "yes\n"
string_label_617:	.asciiz "yes\n"
string_label_618:	.asciiz "no\n"
string_label_619:	.asciiz "no\n"
string_label_620:	.asciiz "yes\n"
string_label_621:	.asciiz "yes\n"
string_label_622:	.asciiz "no\n"
string_label_623:	.asciiz "no\n"
string_label_624:	.asciiz "yes\n"
string_label_625:	.asciiz "yes\n"
string_label_626:	.asciiz "no\n"
string_label_627:	.asciiz "no\n"
string_label_628:	.asciiz "yes\n"
string_label_629:	.asciiz "yes\n"
string_label_630:	.asciiz "no\n"
string_label_631:	.asciiz "no\n"
string_label_632:	.asciiz "yes\n"
string_label_633:	.asciiz "yes\n"
string_label_634:	.asciiz "no\n"
string_label_635:	.asciiz "no\n"
string_label_636:	.asciiz "yes\n"
string_label_637:	.asciiz "yes\n"
string_label_638:	.asciiz "no\n"
string_label_639:	.asciiz "no\n"



 == printing code === 



	#first program point
main:
	#initialize fp
	move	$fp,$sp
	jal	label_71
	#exiting...
li $v0, 10
syscall
	#print_func:
print:
lw $a0,4($sp)
li $v0,4
syscall
jr $ra
	#printi func:
printi:
lw $a0,4($sp)
li $v0,1
syscall
jr $ra
	#div by 0 handler:
nayalo:
	li	$v0, 4
	la	$a0, pvufne1
	syscall
	#exiting...
li $v0, 10
syscall
	#Func True:
label_29:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_1
	#return noneVoid in v0
bp_label_1:
	li	$v0,1
	j	bp_label_0
bp_label_2:
	li	$v0,0
bp_label_0:
	move	$sp,$fp
	jr	$ra
bp_label_3:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func False:
label_50:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_6
	#return noneVoid in v0
bp_label_5:
	li	$v0,1
	j	bp_label_4
bp_label_6:
	li	$v0,0
bp_label_4:
	move	$sp,$fp
	jr	$ra
bp_label_7:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func main:
label_71:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
bExpAss_nfjdn0:
	#assigning True to t
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, ($fp)
	j	bp_label_8
bExpAss_nfjdn1:
	#assigning False to t
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, ($fp)
	j	bp_label_8
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_8
	#marker Label
bp_label_8:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
bExpAss_nfjdn2:
	#assigning True to f
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -4($fp)
	j	bp_label_9
bExpAss_nfjdn3:
	#assigning False to f
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -4($fp)
	j	bp_label_9
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_9
	#marker Label
bp_label_9:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_10
	j	bp_label_11
	#			 __freeing reg $t0
	#marker Label
bp_label_10:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_1
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_12
	#marker Label
bp_label_11:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_3
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_12
	#end of ifelse
bp_label_12:
	#end of statement jump
	j	bp_label_13
	#marker Label
bp_label_13:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_14
	#marker Label
bp_label_14:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_5
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_16
	#marker Label
bp_label_15:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_7
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_16
	#end of ifelse
bp_label_16:
	#end of statement jump
	j	bp_label_17
	#marker Label
bp_label_17:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_18
	#			 __freeing reg $t0
	#If False
	j	bp_label_19
	#marker Label
bp_label_18:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_9
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_20
	#marker Label
bp_label_19:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_11
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_20
	#end of ifelse
bp_label_20:
	#end of statement jump
	j	bp_label_21
	#marker Label
bp_label_21:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_22
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_23
	#marker Label
bp_label_22:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_13
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_24
	#marker Label
bp_label_23:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_15
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_24
	#end of ifelse
bp_label_24:
	#end of statement jump
	j	bp_label_25
	#marker Label
bp_label_25:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_26
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_27
	#marker Label
bp_label_26:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_17
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_28
	#marker Label
bp_label_27:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_19
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_28
	#end of ifelse
bp_label_28:
	#end of statement jump
	j	bp_label_29
	#marker Label
bp_label_29:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_30
	j	bp_label_31
	#			 __freeing reg $t0
	#marker Label
bp_label_30:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_21
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_32
	#marker Label
bp_label_31:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_23
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_32
	#end of ifelse
bp_label_32:
	#end of statement jump
	j	bp_label_33
	#marker Label
bp_label_33:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_35
	#marker Label
bp_label_34:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_25
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_36
	#marker Label
bp_label_35:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_27
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_36
	#end of ifelse
bp_label_36:
	#end of statement jump
	j	bp_label_37
	#marker Label
bp_label_37:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_38
	#			 __freeing reg $t0
	#If False
	j	bp_label_39
	#marker Label
bp_label_38:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_29
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_40
	#marker Label
bp_label_39:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_31
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_40
	#end of ifelse
bp_label_40:
	#end of statement jump
	j	bp_label_41
	#marker Label
bp_label_41:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_42
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_43
	#marker Label
bp_label_42:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_33
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_44
	#marker Label
bp_label_43:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_35
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_44
	#end of ifelse
bp_label_44:
	#end of statement jump
	j	bp_label_45
	#marker Label
bp_label_45:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_46
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_47
	#marker Label
bp_label_46:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_37
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_48
	#marker Label
bp_label_47:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_39
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_48
	#end of ifelse
bp_label_48:
	#end of statement jump
	j	bp_label_49
	#marker Label
bp_label_49:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_50
	j	bp_label_52
	#			 __freeing reg $t0
	#marker Label
bp_label_50:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_51
	j	bp_label_52
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_51:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_41
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_53
	#marker Label
bp_label_52:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_43
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_53
	#end of ifelse
bp_label_53:
	#end of statement jump
	j	bp_label_54
	#marker Label
bp_label_54:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_55
	j	bp_label_57
	#			 __freeing reg $t0
	#marker Label
bp_label_55:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_57
	#reach And derivation
	#marker Label
bp_label_56:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_45
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_58
	#marker Label
bp_label_57:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_47
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_58
	#end of ifelse
bp_label_58:
	#end of statement jump
	j	bp_label_59
	#marker Label
bp_label_59:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_60
	j	bp_label_62
	#			 __freeing reg $t0
	#marker Label
bp_label_60:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_61
	#			 __freeing reg $t0
	#If False
	j	bp_label_62
	#reach And derivation
	#marker Label
bp_label_61:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_49
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_63
	#marker Label
bp_label_62:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_51
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_63
	#end of ifelse
bp_label_63:
	#end of statement jump
	j	bp_label_64
	#marker Label
bp_label_64:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_65
	j	bp_label_67
	#			 __freeing reg $t0
	#marker Label
bp_label_65:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_66
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_67
	#reach And derivation
	#marker Label
bp_label_66:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_53
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_68
	#marker Label
bp_label_67:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_55
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_68
	#end of ifelse
bp_label_68:
	#end of statement jump
	j	bp_label_69
	#marker Label
bp_label_69:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_70
	j	bp_label_72
	#			 __freeing reg $t0
	#marker Label
bp_label_70:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_71
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_72
	#reach And derivation
	#marker Label
bp_label_71:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_57
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_73
	#marker Label
bp_label_72:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_59
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_73
	#end of ifelse
bp_label_73:
	#end of statement jump
	j	bp_label_74
	#marker Label
bp_label_74:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_75
	#marker Label
bp_label_75:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_76
	j	bp_label_77
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_76:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_61
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_78
	#marker Label
bp_label_77:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_63
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_78
	#end of ifelse
bp_label_78:
	#end of statement jump
	j	bp_label_79
	#marker Label
bp_label_79:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_80
	#marker Label
bp_label_80:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_82
	#reach And derivation
	#marker Label
bp_label_81:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_65
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_83
	#marker Label
bp_label_82:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_67
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_83
	#end of ifelse
bp_label_83:
	#end of statement jump
	j	bp_label_84
	#marker Label
bp_label_84:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_85
	#marker Label
bp_label_85:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_86
	#			 __freeing reg $t0
	#If False
	j	bp_label_87
	#reach And derivation
	#marker Label
bp_label_86:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_69
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_88
	#marker Label
bp_label_87:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_71
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_88
	#end of ifelse
bp_label_88:
	#end of statement jump
	j	bp_label_89
	#marker Label
bp_label_89:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_90
	#marker Label
bp_label_90:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_91
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_92
	#reach And derivation
	#marker Label
bp_label_91:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_73
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_93
	#marker Label
bp_label_92:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_75
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_93
	#end of ifelse
bp_label_93:
	#end of statement jump
	j	bp_label_94
	#marker Label
bp_label_94:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_95
	#marker Label
bp_label_95:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_96
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_97
	#reach And derivation
	#marker Label
bp_label_96:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_77
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_98
	#marker Label
bp_label_97:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_79
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_98
	#end of ifelse
bp_label_98:
	#end of statement jump
	j	bp_label_99
	#marker Label
bp_label_99:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_100
	#			 __freeing reg $t0
	#If False
	j	bp_label_102
	#marker Label
bp_label_100:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_101
	j	bp_label_102
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_101:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_81
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_103
	#marker Label
bp_label_102:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_83
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_103
	#end of ifelse
bp_label_103:
	#end of statement jump
	j	bp_label_104
	#marker Label
bp_label_104:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_105
	#			 __freeing reg $t0
	#If False
	j	bp_label_107
	#marker Label
bp_label_105:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_107
	#reach And derivation
	#marker Label
bp_label_106:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_85
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_108
	#marker Label
bp_label_107:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_87
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_108
	#end of ifelse
bp_label_108:
	#end of statement jump
	j	bp_label_109
	#marker Label
bp_label_109:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_110
	#			 __freeing reg $t0
	#If False
	j	bp_label_112
	#marker Label
bp_label_110:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_111
	#			 __freeing reg $t0
	#If False
	j	bp_label_112
	#reach And derivation
	#marker Label
bp_label_111:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_89
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_113
	#marker Label
bp_label_112:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_91
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_113
	#end of ifelse
bp_label_113:
	#end of statement jump
	j	bp_label_114
	#marker Label
bp_label_114:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_115
	#			 __freeing reg $t0
	#If False
	j	bp_label_117
	#marker Label
bp_label_115:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_116
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_117
	#reach And derivation
	#marker Label
bp_label_116:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_93
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_118
	#marker Label
bp_label_117:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_95
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_118
	#end of ifelse
bp_label_118:
	#end of statement jump
	j	bp_label_119
	#marker Label
bp_label_119:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_120
	#			 __freeing reg $t0
	#If False
	j	bp_label_122
	#marker Label
bp_label_120:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_121
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_122
	#reach And derivation
	#marker Label
bp_label_121:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_97
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_123
	#marker Label
bp_label_122:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_99
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_123
	#end of ifelse
bp_label_123:
	#end of statement jump
	j	bp_label_124
	#marker Label
bp_label_124:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_125
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_127
	#marker Label
bp_label_125:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_126
	j	bp_label_127
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_126:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_101
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_128
	#marker Label
bp_label_127:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_103
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_128
	#end of ifelse
bp_label_128:
	#end of statement jump
	j	bp_label_129
	#marker Label
bp_label_129:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_130
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_132
	#marker Label
bp_label_130:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_132
	#reach And derivation
	#marker Label
bp_label_131:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_105
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_133
	#marker Label
bp_label_132:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_107
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_133
	#end of ifelse
bp_label_133:
	#end of statement jump
	j	bp_label_134
	#marker Label
bp_label_134:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_135
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_137
	#marker Label
bp_label_135:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_136
	#			 __freeing reg $t0
	#If False
	j	bp_label_137
	#reach And derivation
	#marker Label
bp_label_136:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_109
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_138
	#marker Label
bp_label_137:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_111
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_138
	#end of ifelse
bp_label_138:
	#end of statement jump
	j	bp_label_139
	#marker Label
bp_label_139:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_140
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_142
	#marker Label
bp_label_140:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_141
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_142
	#reach And derivation
	#marker Label
bp_label_141:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_113
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_143
	#marker Label
bp_label_142:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_115
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_143
	#end of ifelse
bp_label_143:
	#end of statement jump
	j	bp_label_144
	#marker Label
bp_label_144:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_145
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_147
	#marker Label
bp_label_145:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_146
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_147
	#reach And derivation
	#marker Label
bp_label_146:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_117
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_148
	#marker Label
bp_label_147:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_119
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_148
	#end of ifelse
bp_label_148:
	#end of statement jump
	j	bp_label_149
	#marker Label
bp_label_149:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_150
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_152
	#marker Label
bp_label_150:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_151
	j	bp_label_152
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_151:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_121
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_153
	#marker Label
bp_label_152:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_123
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_153
	#end of ifelse
bp_label_153:
	#end of statement jump
	j	bp_label_154
	#marker Label
bp_label_154:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_155
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_157
	#marker Label
bp_label_155:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_157
	#reach And derivation
	#marker Label
bp_label_156:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_125
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_158
	#marker Label
bp_label_157:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_127
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_158
	#end of ifelse
bp_label_158:
	#end of statement jump
	j	bp_label_159
	#marker Label
bp_label_159:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_160
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_162
	#marker Label
bp_label_160:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_161
	#			 __freeing reg $t0
	#If False
	j	bp_label_162
	#reach And derivation
	#marker Label
bp_label_161:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_129
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_163
	#marker Label
bp_label_162:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_131
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_163
	#end of ifelse
bp_label_163:
	#end of statement jump
	j	bp_label_164
	#marker Label
bp_label_164:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_165
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_167
	#marker Label
bp_label_165:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_166
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_167
	#reach And derivation
	#marker Label
bp_label_166:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_133
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_168
	#marker Label
bp_label_167:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_135
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_168
	#end of ifelse
bp_label_168:
	#end of statement jump
	j	bp_label_169
	#marker Label
bp_label_169:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_170
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_172
	#marker Label
bp_label_170:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_171
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_172
	#reach And derivation
	#marker Label
bp_label_171:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_137
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_173
	#marker Label
bp_label_172:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_139
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_173
	#end of ifelse
bp_label_173:
	#end of statement jump
	j	bp_label_174
	#marker Label
bp_label_174:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_175
	j	bp_label_177
	#			 __freeing reg $t0
	#marker Label
bp_label_175:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_176
	j	bp_label_177
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_176:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_141
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_178
	#marker Label
bp_label_177:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_143
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_178
	#end of ifelse
bp_label_178:
	#end of statement jump
	j	bp_label_179
	#marker Label
bp_label_179:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_180
	j	bp_label_182
	#			 __freeing reg $t0
	#marker Label
bp_label_180:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_182
	#reach And derivation
	#marker Label
bp_label_181:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_145
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_183
	#marker Label
bp_label_182:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_147
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_183
	#end of ifelse
bp_label_183:
	#end of statement jump
	j	bp_label_184
	#marker Label
bp_label_184:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_185
	j	bp_label_187
	#			 __freeing reg $t0
	#marker Label
bp_label_185:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_186
	#			 __freeing reg $t0
	#If False
	j	bp_label_187
	#reach And derivation
	#marker Label
bp_label_186:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_149
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_188
	#marker Label
bp_label_187:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_151
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_188
	#end of ifelse
bp_label_188:
	#end of statement jump
	j	bp_label_189
	#marker Label
bp_label_189:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_190
	j	bp_label_192
	#			 __freeing reg $t0
	#marker Label
bp_label_190:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_191
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_192
	#reach And derivation
	#marker Label
bp_label_191:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_153
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_193
	#marker Label
bp_label_192:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_155
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_193
	#end of ifelse
bp_label_193:
	#end of statement jump
	j	bp_label_194
	#marker Label
bp_label_194:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_195
	j	bp_label_197
	#			 __freeing reg $t0
	#marker Label
bp_label_195:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_196
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_197
	#reach And derivation
	#marker Label
bp_label_196:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_157
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_198
	#marker Label
bp_label_197:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_159
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_198
	#end of ifelse
bp_label_198:
	#end of statement jump
	j	bp_label_199
	#marker Label
bp_label_199:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_200
	#marker Label
bp_label_200:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_201
	j	bp_label_202
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_201:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_161
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_203
	#marker Label
bp_label_202:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_163
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_203
	#end of ifelse
bp_label_203:
	#end of statement jump
	j	bp_label_204
	#marker Label
bp_label_204:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_205
	#marker Label
bp_label_205:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_207
	#reach And derivation
	#marker Label
bp_label_206:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_165
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_208
	#marker Label
bp_label_207:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_167
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_208
	#end of ifelse
bp_label_208:
	#end of statement jump
	j	bp_label_209
	#marker Label
bp_label_209:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_210
	#marker Label
bp_label_210:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_211
	#			 __freeing reg $t0
	#If False
	j	bp_label_212
	#reach And derivation
	#marker Label
bp_label_211:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_169
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_213
	#marker Label
bp_label_212:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_171
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_213
	#end of ifelse
bp_label_213:
	#end of statement jump
	j	bp_label_214
	#marker Label
bp_label_214:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_215
	#marker Label
bp_label_215:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_216
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_217
	#reach And derivation
	#marker Label
bp_label_216:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_173
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_218
	#marker Label
bp_label_217:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_175
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_218
	#end of ifelse
bp_label_218:
	#end of statement jump
	j	bp_label_219
	#marker Label
bp_label_219:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_220
	#marker Label
bp_label_220:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_221
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_222
	#reach And derivation
	#marker Label
bp_label_221:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_177
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_223
	#marker Label
bp_label_222:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_179
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_223
	#end of ifelse
bp_label_223:
	#end of statement jump
	j	bp_label_224
	#marker Label
bp_label_224:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_225
	#			 __freeing reg $t0
	#If False
	j	bp_label_227
	#marker Label
bp_label_225:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_226
	j	bp_label_227
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_226:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_181
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_228
	#marker Label
bp_label_227:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_183
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_228
	#end of ifelse
bp_label_228:
	#end of statement jump
	j	bp_label_229
	#marker Label
bp_label_229:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_230
	#			 __freeing reg $t0
	#If False
	j	bp_label_232
	#marker Label
bp_label_230:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_232
	#reach And derivation
	#marker Label
bp_label_231:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_185
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_233
	#marker Label
bp_label_232:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_187
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_233
	#end of ifelse
bp_label_233:
	#end of statement jump
	j	bp_label_234
	#marker Label
bp_label_234:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_235
	#			 __freeing reg $t0
	#If False
	j	bp_label_237
	#marker Label
bp_label_235:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_236
	#			 __freeing reg $t0
	#If False
	j	bp_label_237
	#reach And derivation
	#marker Label
bp_label_236:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_189
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_238
	#marker Label
bp_label_237:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_191
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_238
	#end of ifelse
bp_label_238:
	#end of statement jump
	j	bp_label_239
	#marker Label
bp_label_239:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_240
	#			 __freeing reg $t0
	#If False
	j	bp_label_242
	#marker Label
bp_label_240:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_241
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_242
	#reach And derivation
	#marker Label
bp_label_241:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_193
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_243
	#marker Label
bp_label_242:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_195
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_243
	#end of ifelse
bp_label_243:
	#end of statement jump
	j	bp_label_244
	#marker Label
bp_label_244:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_245
	#			 __freeing reg $t0
	#If False
	j	bp_label_247
	#marker Label
bp_label_245:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_246
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_247
	#reach And derivation
	#marker Label
bp_label_246:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_197
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_248
	#marker Label
bp_label_247:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_199
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_248
	#end of ifelse
bp_label_248:
	#end of statement jump
	j	bp_label_249
	#marker Label
bp_label_249:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_250
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_252
	#marker Label
bp_label_250:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_251
	j	bp_label_252
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_251:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_201
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_253
	#marker Label
bp_label_252:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_203
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_253
	#end of ifelse
bp_label_253:
	#end of statement jump
	j	bp_label_254
	#marker Label
bp_label_254:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_255
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_257
	#marker Label
bp_label_255:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_257
	#reach And derivation
	#marker Label
bp_label_256:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_205
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_258
	#marker Label
bp_label_257:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_207
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_258
	#end of ifelse
bp_label_258:
	#end of statement jump
	j	bp_label_259
	#marker Label
bp_label_259:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_260
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_262
	#marker Label
bp_label_260:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_261
	#			 __freeing reg $t0
	#If False
	j	bp_label_262
	#reach And derivation
	#marker Label
bp_label_261:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_209
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_263
	#marker Label
bp_label_262:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_211
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_263
	#end of ifelse
bp_label_263:
	#end of statement jump
	j	bp_label_264
	#marker Label
bp_label_264:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_265
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_267
	#marker Label
bp_label_265:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_266
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_267
	#reach And derivation
	#marker Label
bp_label_266:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_213
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_268
	#marker Label
bp_label_267:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_215
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_268
	#end of ifelse
bp_label_268:
	#end of statement jump
	j	bp_label_269
	#marker Label
bp_label_269:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_270
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_272
	#marker Label
bp_label_270:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_271
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_272
	#reach And derivation
	#marker Label
bp_label_271:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_217
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_273
	#marker Label
bp_label_272:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_219
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_273
	#end of ifelse
bp_label_273:
	#end of statement jump
	j	bp_label_274
	#marker Label
bp_label_274:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_275
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_277
	#marker Label
bp_label_275:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_276
	j	bp_label_277
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_276:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_221
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_278
	#marker Label
bp_label_277:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_223
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_278
	#end of ifelse
bp_label_278:
	#end of statement jump
	j	bp_label_279
	#marker Label
bp_label_279:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_280
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_282
	#marker Label
bp_label_280:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_282
	#reach And derivation
	#marker Label
bp_label_281:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_225
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_283
	#marker Label
bp_label_282:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_227
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_283
	#end of ifelse
bp_label_283:
	#end of statement jump
	j	bp_label_284
	#marker Label
bp_label_284:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_285
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_287
	#marker Label
bp_label_285:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_286
	#			 __freeing reg $t0
	#If False
	j	bp_label_287
	#reach And derivation
	#marker Label
bp_label_286:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_229
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_288
	#marker Label
bp_label_287:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_231
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_288
	#end of ifelse
bp_label_288:
	#end of statement jump
	j	bp_label_289
	#marker Label
bp_label_289:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_290
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_292
	#marker Label
bp_label_290:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_291
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_292
	#reach And derivation
	#marker Label
bp_label_291:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_233
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_293
	#marker Label
bp_label_292:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_235
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_293
	#end of ifelse
bp_label_293:
	#end of statement jump
	j	bp_label_294
	#marker Label
bp_label_294:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_295
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_297
	#marker Label
bp_label_295:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_296
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_297
	#reach And derivation
	#marker Label
bp_label_296:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_237
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_298
	#marker Label
bp_label_297:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_239
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_298
	#end of ifelse
bp_label_298:
	#end of statement jump
	j	bp_label_299
	#marker Label
bp_label_299:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_300
	j	bp_label_302
	#			 __freeing reg $t0
	#marker Label
bp_label_300:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_301
	j	bp_label_302
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_301:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_241
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_303
	#marker Label
bp_label_302:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_243
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_303
	#end of ifelse
bp_label_303:
	#end of statement jump
	j	bp_label_304
	#marker Label
bp_label_304:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_305
	j	bp_label_307
	#			 __freeing reg $t0
	#marker Label
bp_label_305:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_307
	#reach And derivation
	#marker Label
bp_label_306:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_245
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_308
	#marker Label
bp_label_307:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_247
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_308
	#end of ifelse
bp_label_308:
	#end of statement jump
	j	bp_label_309
	#marker Label
bp_label_309:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_310
	j	bp_label_312
	#			 __freeing reg $t0
	#marker Label
bp_label_310:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_311
	#			 __freeing reg $t0
	#If False
	j	bp_label_312
	#reach And derivation
	#marker Label
bp_label_311:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_249
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_313
	#marker Label
bp_label_312:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_251
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_313
	#end of ifelse
bp_label_313:
	#end of statement jump
	j	bp_label_314
	#marker Label
bp_label_314:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_315
	j	bp_label_317
	#			 __freeing reg $t0
	#marker Label
bp_label_315:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_316
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_317
	#reach And derivation
	#marker Label
bp_label_316:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_253
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_318
	#marker Label
bp_label_317:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_255
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_318
	#end of ifelse
bp_label_318:
	#end of statement jump
	j	bp_label_319
	#marker Label
bp_label_319:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_320
	j	bp_label_322
	#			 __freeing reg $t0
	#marker Label
bp_label_320:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_321
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_322
	#reach And derivation
	#marker Label
bp_label_321:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_257
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_323
	#marker Label
bp_label_322:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_259
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_323
	#end of ifelse
bp_label_323:
	#end of statement jump
	j	bp_label_324
	#marker Label
bp_label_324:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_327
	#marker Label
bp_label_325:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_326
	j	bp_label_327
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_326:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_261
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_328
	#marker Label
bp_label_327:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_263
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_328
	#end of ifelse
bp_label_328:
	#end of statement jump
	j	bp_label_329
	#marker Label
bp_label_329:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_332
	#marker Label
bp_label_330:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_332
	#reach And derivation
	#marker Label
bp_label_331:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_265
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_333
	#marker Label
bp_label_332:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_267
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_333
	#end of ifelse
bp_label_333:
	#end of statement jump
	j	bp_label_334
	#marker Label
bp_label_334:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_337
	#marker Label
bp_label_335:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_336
	#			 __freeing reg $t0
	#If False
	j	bp_label_337
	#reach And derivation
	#marker Label
bp_label_336:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_269
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_338
	#marker Label
bp_label_337:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_271
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_338
	#end of ifelse
bp_label_338:
	#end of statement jump
	j	bp_label_339
	#marker Label
bp_label_339:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_342
	#marker Label
bp_label_340:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_341
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_342
	#reach And derivation
	#marker Label
bp_label_341:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_273
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_343
	#marker Label
bp_label_342:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_275
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_343
	#end of ifelse
bp_label_343:
	#end of statement jump
	j	bp_label_344
	#marker Label
bp_label_344:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_347
	#marker Label
bp_label_345:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_346
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_347
	#reach And derivation
	#marker Label
bp_label_346:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_277
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_348
	#marker Label
bp_label_347:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_279
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_348
	#end of ifelse
bp_label_348:
	#end of statement jump
	j	bp_label_349
	#marker Label
bp_label_349:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_350
	#			 __freeing reg $t0
	#If False
	j	bp_label_352
	#marker Label
bp_label_350:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_351
	j	bp_label_352
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_351:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_281
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_353
	#marker Label
bp_label_352:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_283
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_353
	#end of ifelse
bp_label_353:
	#end of statement jump
	j	bp_label_354
	#marker Label
bp_label_354:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_355
	#			 __freeing reg $t0
	#If False
	j	bp_label_357
	#marker Label
bp_label_355:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_357
	#reach And derivation
	#marker Label
bp_label_356:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_285
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_358
	#marker Label
bp_label_357:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_287
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_358
	#end of ifelse
bp_label_358:
	#end of statement jump
	j	bp_label_359
	#marker Label
bp_label_359:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_360
	#			 __freeing reg $t0
	#If False
	j	bp_label_362
	#marker Label
bp_label_360:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_361
	#			 __freeing reg $t0
	#If False
	j	bp_label_362
	#reach And derivation
	#marker Label
bp_label_361:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_289
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_363
	#marker Label
bp_label_362:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_291
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_363
	#end of ifelse
bp_label_363:
	#end of statement jump
	j	bp_label_364
	#marker Label
bp_label_364:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_365
	#			 __freeing reg $t0
	#If False
	j	bp_label_367
	#marker Label
bp_label_365:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_366
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_367
	#reach And derivation
	#marker Label
bp_label_366:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_293
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_368
	#marker Label
bp_label_367:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_295
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_368
	#end of ifelse
bp_label_368:
	#end of statement jump
	j	bp_label_369
	#marker Label
bp_label_369:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_370
	#			 __freeing reg $t0
	#If False
	j	bp_label_372
	#marker Label
bp_label_370:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_371
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_372
	#reach And derivation
	#marker Label
bp_label_371:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_297
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_373
	#marker Label
bp_label_372:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_299
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_373
	#end of ifelse
bp_label_373:
	#end of statement jump
	j	bp_label_374
	#marker Label
bp_label_374:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_375
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_377
	#marker Label
bp_label_375:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_376
	j	bp_label_377
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_376:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_301
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_378
	#marker Label
bp_label_377:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_303
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_378
	#end of ifelse
bp_label_378:
	#end of statement jump
	j	bp_label_379
	#marker Label
bp_label_379:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_380
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_382
	#marker Label
bp_label_380:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_382
	#reach And derivation
	#marker Label
bp_label_381:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_305
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_383
	#marker Label
bp_label_382:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_307
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_383
	#end of ifelse
bp_label_383:
	#end of statement jump
	j	bp_label_384
	#marker Label
bp_label_384:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_385
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_387
	#marker Label
bp_label_385:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_386
	#			 __freeing reg $t0
	#If False
	j	bp_label_387
	#reach And derivation
	#marker Label
bp_label_386:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_309
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_388
	#marker Label
bp_label_387:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_311
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_388
	#end of ifelse
bp_label_388:
	#end of statement jump
	j	bp_label_389
	#marker Label
bp_label_389:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_390
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_392
	#marker Label
bp_label_390:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_391
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_392
	#reach And derivation
	#marker Label
bp_label_391:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_313
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_393
	#marker Label
bp_label_392:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_315
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_393
	#end of ifelse
bp_label_393:
	#end of statement jump
	j	bp_label_394
	#marker Label
bp_label_394:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_395
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_397
	#marker Label
bp_label_395:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_396
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_397
	#reach And derivation
	#marker Label
bp_label_396:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_317
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_398
	#marker Label
bp_label_397:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_319
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_398
	#end of ifelse
bp_label_398:
	#end of statement jump
	j	bp_label_399
	#marker Label
bp_label_399:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_400
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_402
	#marker Label
bp_label_400:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_401
	j	bp_label_402
	#			 __freeing reg $t0
	#reach And derivation
	#marker Label
bp_label_401:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_321
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_403
	#marker Label
bp_label_402:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_323
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_403
	#end of ifelse
bp_label_403:
	#end of statement jump
	j	bp_label_404
	#marker Label
bp_label_404:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_405
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_407
	#marker Label
bp_label_405:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_407
	#reach And derivation
	#marker Label
bp_label_406:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_325
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_408
	#marker Label
bp_label_407:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_327
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_408
	#end of ifelse
bp_label_408:
	#end of statement jump
	j	bp_label_409
	#marker Label
bp_label_409:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_410
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_412
	#marker Label
bp_label_410:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_411
	#			 __freeing reg $t0
	#If False
	j	bp_label_412
	#reach And derivation
	#marker Label
bp_label_411:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_329
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_413
	#marker Label
bp_label_412:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_331
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_413
	#end of ifelse
bp_label_413:
	#end of statement jump
	j	bp_label_414
	#marker Label
bp_label_414:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_415
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_417
	#marker Label
bp_label_415:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_416
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_417
	#reach And derivation
	#marker Label
bp_label_416:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_333
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_418
	#marker Label
bp_label_417:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_335
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_418
	#end of ifelse
bp_label_418:
	#end of statement jump
	j	bp_label_419
	#marker Label
bp_label_419:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_420
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_422
	#marker Label
bp_label_420:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_421
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_422
	#reach And derivation
	#marker Label
bp_label_421:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_337
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_423
	#marker Label
bp_label_422:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_339
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_423
	#end of ifelse
bp_label_423:
	#end of statement jump
	j	bp_label_424
	#marker Label
bp_label_424:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_426
	j	bp_label_425
	#			 __freeing reg $t0
	#marker Label
bp_label_425:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_426
	j	bp_label_427
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_426:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_341
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_428
	#marker Label
bp_label_427:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_343
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_428
	#end of ifelse
bp_label_428:
	#end of statement jump
	j	bp_label_429
	#marker Label
bp_label_429:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_431
	j	bp_label_430
	#			 __freeing reg $t0
	#marker Label
bp_label_430:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_432
	#reach Or derivation
	#marker Label
bp_label_431:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_345
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_433
	#marker Label
bp_label_432:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_347
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_433
	#end of ifelse
bp_label_433:
	#end of statement jump
	j	bp_label_434
	#marker Label
bp_label_434:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_436
	j	bp_label_435
	#			 __freeing reg $t0
	#marker Label
bp_label_435:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_436
	#			 __freeing reg $t0
	#If False
	j	bp_label_437
	#reach Or derivation
	#marker Label
bp_label_436:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_349
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_438
	#marker Label
bp_label_437:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_351
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_438
	#end of ifelse
bp_label_438:
	#end of statement jump
	j	bp_label_439
	#marker Label
bp_label_439:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_441
	j	bp_label_440
	#			 __freeing reg $t0
	#marker Label
bp_label_440:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_441
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_442
	#reach Or derivation
	#marker Label
bp_label_441:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_353
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_443
	#marker Label
bp_label_442:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_355
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_443
	#end of ifelse
bp_label_443:
	#end of statement jump
	j	bp_label_444
	#marker Label
bp_label_444:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bp_label_446
	j	bp_label_445
	#			 __freeing reg $t0
	#marker Label
bp_label_445:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_446
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_447
	#reach Or derivation
	#marker Label
bp_label_446:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_357
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_448
	#marker Label
bp_label_447:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_359
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_448
	#end of ifelse
bp_label_448:
	#end of statement jump
	j	bp_label_449
	#marker Label
bp_label_449:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_451
	#marker Label
bp_label_450:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_451
	j	bp_label_452
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_451:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_361
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_453
	#marker Label
bp_label_452:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_363
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_453
	#end of ifelse
bp_label_453:
	#end of statement jump
	j	bp_label_454
	#marker Label
bp_label_454:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_456
	#marker Label
bp_label_455:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_457
	#reach Or derivation
	#marker Label
bp_label_456:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_365
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_458
	#marker Label
bp_label_457:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_367
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_458
	#end of ifelse
bp_label_458:
	#end of statement jump
	j	bp_label_459
	#marker Label
bp_label_459:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_461
	#marker Label
bp_label_460:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_461
	#			 __freeing reg $t0
	#If False
	j	bp_label_462
	#reach Or derivation
	#marker Label
bp_label_461:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_369
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_463
	#marker Label
bp_label_462:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_371
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_463
	#end of ifelse
bp_label_463:
	#end of statement jump
	j	bp_label_464
	#marker Label
bp_label_464:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_466
	#marker Label
bp_label_465:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_466
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_467
	#reach Or derivation
	#marker Label
bp_label_466:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_373
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_468
	#marker Label
bp_label_467:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_375
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_468
	#end of ifelse
bp_label_468:
	#end of statement jump
	j	bp_label_469
	#marker Label
bp_label_469:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_471
	#marker Label
bp_label_470:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_471
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_472
	#reach Or derivation
	#marker Label
bp_label_471:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_377
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_473
	#marker Label
bp_label_472:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_379
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_473
	#end of ifelse
bp_label_473:
	#end of statement jump
	j	bp_label_474
	#marker Label
bp_label_474:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_476
	#			 __freeing reg $t0
	#If False
	j	bp_label_475
	#marker Label
bp_label_475:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_476
	j	bp_label_477
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_476:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_381
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_478
	#marker Label
bp_label_477:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_383
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_478
	#end of ifelse
bp_label_478:
	#end of statement jump
	j	bp_label_479
	#marker Label
bp_label_479:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_481
	#			 __freeing reg $t0
	#If False
	j	bp_label_480
	#marker Label
bp_label_480:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_482
	#reach Or derivation
	#marker Label
bp_label_481:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_385
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_483
	#marker Label
bp_label_482:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_387
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_483
	#end of ifelse
bp_label_483:
	#end of statement jump
	j	bp_label_484
	#marker Label
bp_label_484:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_486
	#			 __freeing reg $t0
	#If False
	j	bp_label_485
	#marker Label
bp_label_485:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_486
	#			 __freeing reg $t0
	#If False
	j	bp_label_487
	#reach Or derivation
	#marker Label
bp_label_486:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_389
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_488
	#marker Label
bp_label_487:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_391
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_488
	#end of ifelse
bp_label_488:
	#end of statement jump
	j	bp_label_489
	#marker Label
bp_label_489:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_491
	#			 __freeing reg $t0
	#If False
	j	bp_label_490
	#marker Label
bp_label_490:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_491
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_492
	#reach Or derivation
	#marker Label
bp_label_491:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_393
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_493
	#marker Label
bp_label_492:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_395
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_493
	#end of ifelse
bp_label_493:
	#end of statement jump
	j	bp_label_494
	#marker Label
bp_label_494:
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t0, $zero,bp_label_496
	#			 __freeing reg $t0
	#If False
	j	bp_label_495
	#marker Label
bp_label_495:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_496
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_497
	#reach Or derivation
	#marker Label
bp_label_496:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_397
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_498
	#marker Label
bp_label_497:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_399
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_498
	#end of ifelse
bp_label_498:
	#end of statement jump
	j	bp_label_499
	#marker Label
bp_label_499:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_501
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_500
	#marker Label
bp_label_500:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_501
	j	bp_label_502
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_501:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_401
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_503
	#marker Label
bp_label_502:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_403
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_503
	#end of ifelse
bp_label_503:
	#end of statement jump
	j	bp_label_504
	#marker Label
bp_label_504:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_506
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_505
	#marker Label
bp_label_505:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_507
	#reach Or derivation
	#marker Label
bp_label_506:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_405
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_508
	#marker Label
bp_label_507:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_407
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_508
	#end of ifelse
bp_label_508:
	#end of statement jump
	j	bp_label_509
	#marker Label
bp_label_509:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_511
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_510
	#marker Label
bp_label_510:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_511
	#			 __freeing reg $t0
	#If False
	j	bp_label_512
	#reach Or derivation
	#marker Label
bp_label_511:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_409
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_513
	#marker Label
bp_label_512:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_411
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_513
	#end of ifelse
bp_label_513:
	#end of statement jump
	j	bp_label_514
	#marker Label
bp_label_514:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_516
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_515
	#marker Label
bp_label_515:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_516
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_517
	#reach Or derivation
	#marker Label
bp_label_516:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_413
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_518
	#marker Label
bp_label_517:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_415
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_518
	#end of ifelse
bp_label_518:
	#end of statement jump
	j	bp_label_519
	#marker Label
bp_label_519:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	blt $t0, $t1,bp_label_521
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_520
	#marker Label
bp_label_520:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_521
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_522
	#reach Or derivation
	#marker Label
bp_label_521:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_417
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_523
	#marker Label
bp_label_522:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_419
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_523
	#end of ifelse
bp_label_523:
	#end of statement jump
	j	bp_label_524
	#marker Label
bp_label_524:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_526
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_525
	#marker Label
bp_label_525:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_526
	j	bp_label_527
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_526:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_421
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_528
	#marker Label
bp_label_527:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_423
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_528
	#end of ifelse
bp_label_528:
	#end of statement jump
	j	bp_label_529
	#marker Label
bp_label_529:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_531
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_530
	#marker Label
bp_label_530:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_532
	#reach Or derivation
	#marker Label
bp_label_531:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_425
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_533
	#marker Label
bp_label_532:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_427
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_533
	#end of ifelse
bp_label_533:
	#end of statement jump
	j	bp_label_534
	#marker Label
bp_label_534:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_536
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_535
	#marker Label
bp_label_535:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_536
	#			 __freeing reg $t0
	#If False
	j	bp_label_537
	#reach Or derivation
	#marker Label
bp_label_536:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_429
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_538
	#marker Label
bp_label_537:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_431
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_538
	#end of ifelse
bp_label_538:
	#end of statement jump
	j	bp_label_539
	#marker Label
bp_label_539:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_541
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_540
	#marker Label
bp_label_540:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_541
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_542
	#reach Or derivation
	#marker Label
bp_label_541:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_433
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_543
	#marker Label
bp_label_542:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_435
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_543
	#end of ifelse
bp_label_543:
	#end of statement jump
	j	bp_label_544
	#marker Label
bp_label_544:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	beq $t0, $t1,bp_label_546
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_545
	#marker Label
bp_label_545:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_546
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_547
	#reach Or derivation
	#marker Label
bp_label_546:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_437
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_548
	#marker Label
bp_label_547:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_439
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_548
	#end of ifelse
bp_label_548:
	#end of statement jump
	j	bp_label_549
	#marker Label
bp_label_549:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_551
	j	bp_label_550
	#			 __freeing reg $t0
	#marker Label
bp_label_550:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_551
	j	bp_label_552
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_551:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_441
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_553
	#marker Label
bp_label_552:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_443
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_553
	#end of ifelse
bp_label_553:
	#end of statement jump
	j	bp_label_554
	#marker Label
bp_label_554:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_556
	j	bp_label_555
	#			 __freeing reg $t0
	#marker Label
bp_label_555:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_557
	#reach Or derivation
	#marker Label
bp_label_556:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_445
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_558
	#marker Label
bp_label_557:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_447
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_558
	#end of ifelse
bp_label_558:
	#end of statement jump
	j	bp_label_559
	#marker Label
bp_label_559:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_561
	j	bp_label_560
	#			 __freeing reg $t0
	#marker Label
bp_label_560:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_561
	#			 __freeing reg $t0
	#If False
	j	bp_label_562
	#reach Or derivation
	#marker Label
bp_label_561:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_449
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_563
	#marker Label
bp_label_562:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_451
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_563
	#end of ifelse
bp_label_563:
	#end of statement jump
	j	bp_label_564
	#marker Label
bp_label_564:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_566
	j	bp_label_565
	#			 __freeing reg $t0
	#marker Label
bp_label_565:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_566
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_567
	#reach Or derivation
	#marker Label
bp_label_566:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_453
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_568
	#marker Label
bp_label_567:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_455
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_568
	#end of ifelse
bp_label_568:
	#end of statement jump
	j	bp_label_569
	#marker Label
bp_label_569:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_571
	j	bp_label_570
	#			 __freeing reg $t0
	#marker Label
bp_label_570:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_571
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_572
	#reach Or derivation
	#marker Label
bp_label_571:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_457
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_573
	#marker Label
bp_label_572:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_459
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_573
	#end of ifelse
bp_label_573:
	#end of statement jump
	j	bp_label_574
	#marker Label
bp_label_574:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_575
	#marker Label
bp_label_575:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_576
	j	bp_label_577
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_576:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_461
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_578
	#marker Label
bp_label_577:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_463
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_578
	#end of ifelse
bp_label_578:
	#end of statement jump
	j	bp_label_579
	#marker Label
bp_label_579:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_580
	#marker Label
bp_label_580:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_582
	#reach Or derivation
	#marker Label
bp_label_581:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_465
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_583
	#marker Label
bp_label_582:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_467
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_583
	#end of ifelse
bp_label_583:
	#end of statement jump
	j	bp_label_584
	#marker Label
bp_label_584:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_585
	#marker Label
bp_label_585:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_586
	#			 __freeing reg $t0
	#If False
	j	bp_label_587
	#reach Or derivation
	#marker Label
bp_label_586:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_469
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_588
	#marker Label
bp_label_587:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_471
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_588
	#end of ifelse
bp_label_588:
	#end of statement jump
	j	bp_label_589
	#marker Label
bp_label_589:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_590
	#marker Label
bp_label_590:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_591
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_592
	#reach Or derivation
	#marker Label
bp_label_591:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_473
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_593
	#marker Label
bp_label_592:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_475
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_593
	#end of ifelse
bp_label_593:
	#end of statement jump
	j	bp_label_594
	#marker Label
bp_label_594:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_595
	#marker Label
bp_label_595:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_596
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_597
	#reach Or derivation
	#marker Label
bp_label_596:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_477
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_598
	#marker Label
bp_label_597:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_479
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_598
	#end of ifelse
bp_label_598:
	#end of statement jump
	j	bp_label_599
	#marker Label
bp_label_599:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_601
	#			 __freeing reg $t0
	#If False
	j	bp_label_600
	#marker Label
bp_label_600:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_601
	j	bp_label_602
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_601:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_481
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_603
	#marker Label
bp_label_602:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_483
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_603
	#end of ifelse
bp_label_603:
	#end of statement jump
	j	bp_label_604
	#marker Label
bp_label_604:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_606
	#			 __freeing reg $t0
	#If False
	j	bp_label_605
	#marker Label
bp_label_605:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_607
	#reach Or derivation
	#marker Label
bp_label_606:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_485
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_608
	#marker Label
bp_label_607:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_487
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_608
	#end of ifelse
bp_label_608:
	#end of statement jump
	j	bp_label_609
	#marker Label
bp_label_609:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_611
	#			 __freeing reg $t0
	#If False
	j	bp_label_610
	#marker Label
bp_label_610:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_611
	#			 __freeing reg $t0
	#If False
	j	bp_label_612
	#reach Or derivation
	#marker Label
bp_label_611:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_489
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_613
	#marker Label
bp_label_612:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_491
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_613
	#end of ifelse
bp_label_613:
	#end of statement jump
	j	bp_label_614
	#marker Label
bp_label_614:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_616
	#			 __freeing reg $t0
	#If False
	j	bp_label_615
	#marker Label
bp_label_615:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_616
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_617
	#reach Or derivation
	#marker Label
bp_label_616:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_493
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_618
	#marker Label
bp_label_617:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_495
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_618
	#end of ifelse
bp_label_618:
	#end of statement jump
	j	bp_label_619
	#marker Label
bp_label_619:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_621
	#			 __freeing reg $t0
	#If False
	j	bp_label_620
	#marker Label
bp_label_620:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_621
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_622
	#reach Or derivation
	#marker Label
bp_label_621:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_497
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_623
	#marker Label
bp_label_622:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_499
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_623
	#end of ifelse
bp_label_623:
	#end of statement jump
	j	bp_label_624
	#marker Label
bp_label_624:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_626
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_625
	#marker Label
bp_label_625:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_626
	j	bp_label_627
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_626:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_501
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_628
	#marker Label
bp_label_627:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_503
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_628
	#end of ifelse
bp_label_628:
	#end of statement jump
	j	bp_label_629
	#marker Label
bp_label_629:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_631
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_630
	#marker Label
bp_label_630:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_632
	#reach Or derivation
	#marker Label
bp_label_631:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_505
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_633
	#marker Label
bp_label_632:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_507
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_633
	#end of ifelse
bp_label_633:
	#end of statement jump
	j	bp_label_634
	#marker Label
bp_label_634:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_636
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_635
	#marker Label
bp_label_635:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_636
	#			 __freeing reg $t0
	#If False
	j	bp_label_637
	#reach Or derivation
	#marker Label
bp_label_636:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_509
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_638
	#marker Label
bp_label_637:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_511
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_638
	#end of ifelse
bp_label_638:
	#end of statement jump
	j	bp_label_639
	#marker Label
bp_label_639:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_641
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_640
	#marker Label
bp_label_640:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_641
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_642
	#reach Or derivation
	#marker Label
bp_label_641:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_513
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_643
	#marker Label
bp_label_642:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_515
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_643
	#end of ifelse
bp_label_643:
	#end of statement jump
	j	bp_label_644
	#marker Label
bp_label_644:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_646
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_645
	#marker Label
bp_label_645:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_646
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_647
	#reach Or derivation
	#marker Label
bp_label_646:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_517
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_648
	#marker Label
bp_label_647:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_519
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_648
	#end of ifelse
bp_label_648:
	#end of statement jump
	j	bp_label_649
	#marker Label
bp_label_649:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_651
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_650
	#marker Label
bp_label_650:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_651
	j	bp_label_652
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_651:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_521
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_653
	#marker Label
bp_label_652:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_523
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_653
	#end of ifelse
bp_label_653:
	#end of statement jump
	j	bp_label_654
	#marker Label
bp_label_654:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_656
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_655
	#marker Label
bp_label_655:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_657
	#reach Or derivation
	#marker Label
bp_label_656:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_525
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_658
	#marker Label
bp_label_657:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_527
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_658
	#end of ifelse
bp_label_658:
	#end of statement jump
	j	bp_label_659
	#marker Label
bp_label_659:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_661
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_660
	#marker Label
bp_label_660:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_661
	#			 __freeing reg $t0
	#If False
	j	bp_label_662
	#reach Or derivation
	#marker Label
bp_label_661:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_529
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_663
	#marker Label
bp_label_662:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_531
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_663
	#end of ifelse
bp_label_663:
	#end of statement jump
	j	bp_label_664
	#marker Label
bp_label_664:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_666
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_665
	#marker Label
bp_label_665:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_666
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_667
	#reach Or derivation
	#marker Label
bp_label_666:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_533
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_668
	#marker Label
bp_label_667:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_535
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_668
	#end of ifelse
bp_label_668:
	#end of statement jump
	j	bp_label_669
	#marker Label
bp_label_669:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_671
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_670
	#marker Label
bp_label_670:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_671
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_672
	#reach Or derivation
	#marker Label
bp_label_671:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_537
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_673
	#marker Label
bp_label_672:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_539
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_673
	#end of ifelse
bp_label_673:
	#end of statement jump
	j	bp_label_674
	#marker Label
bp_label_674:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_676
	j	bp_label_675
	#			 __freeing reg $t0
	#marker Label
bp_label_675:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_676
	j	bp_label_677
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_676:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_541
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_678
	#marker Label
bp_label_677:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_543
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_678
	#end of ifelse
bp_label_678:
	#end of statement jump
	j	bp_label_679
	#marker Label
bp_label_679:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_681
	j	bp_label_680
	#			 __freeing reg $t0
	#marker Label
bp_label_680:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_682
	#reach Or derivation
	#marker Label
bp_label_681:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_545
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_683
	#marker Label
bp_label_682:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_547
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_683
	#end of ifelse
bp_label_683:
	#end of statement jump
	j	bp_label_684
	#marker Label
bp_label_684:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_686
	j	bp_label_685
	#			 __freeing reg $t0
	#marker Label
bp_label_685:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_686
	#			 __freeing reg $t0
	#If False
	j	bp_label_687
	#reach Or derivation
	#marker Label
bp_label_686:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_549
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_688
	#marker Label
bp_label_687:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_551
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_688
	#end of ifelse
bp_label_688:
	#end of statement jump
	j	bp_label_689
	#marker Label
bp_label_689:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_691
	j	bp_label_690
	#			 __freeing reg $t0
	#marker Label
bp_label_690:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_691
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_692
	#reach Or derivation
	#marker Label
bp_label_691:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_553
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_693
	#marker Label
bp_label_692:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_555
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_693
	#end of ifelse
bp_label_693:
	#end of statement jump
	j	bp_label_694
	#marker Label
bp_label_694:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_696
	j	bp_label_695
	#			 __freeing reg $t0
	#marker Label
bp_label_695:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_696
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_697
	#reach Or derivation
	#marker Label
bp_label_696:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_557
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_698
	#marker Label
bp_label_697:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_559
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_698
	#end of ifelse
bp_label_698:
	#end of statement jump
	j	bp_label_699
	#marker Label
bp_label_699:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_700
	#marker Label
bp_label_700:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_701
	j	bp_label_702
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_701:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_561
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_703
	#marker Label
bp_label_702:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_563
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_703
	#end of ifelse
bp_label_703:
	#end of statement jump
	j	bp_label_704
	#marker Label
bp_label_704:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_705
	#marker Label
bp_label_705:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_707
	#reach Or derivation
	#marker Label
bp_label_706:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_565
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_708
	#marker Label
bp_label_707:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_567
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_708
	#end of ifelse
bp_label_708:
	#end of statement jump
	j	bp_label_709
	#marker Label
bp_label_709:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_710
	#marker Label
bp_label_710:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_711
	#			 __freeing reg $t0
	#If False
	j	bp_label_712
	#reach Or derivation
	#marker Label
bp_label_711:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_569
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_713
	#marker Label
bp_label_712:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_571
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_713
	#end of ifelse
bp_label_713:
	#end of statement jump
	j	bp_label_714
	#marker Label
bp_label_714:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_715
	#marker Label
bp_label_715:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_716
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_717
	#reach Or derivation
	#marker Label
bp_label_716:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_573
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_718
	#marker Label
bp_label_717:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_575
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_718
	#end of ifelse
bp_label_718:
	#end of statement jump
	j	bp_label_719
	#marker Label
bp_label_719:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_720
	#marker Label
bp_label_720:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_721
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_722
	#reach Or derivation
	#marker Label
bp_label_721:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_577
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_723
	#marker Label
bp_label_722:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_579
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_723
	#end of ifelse
bp_label_723:
	#end of statement jump
	j	bp_label_724
	#marker Label
bp_label_724:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_726
	#			 __freeing reg $t0
	#If False
	j	bp_label_725
	#marker Label
bp_label_725:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_726
	j	bp_label_727
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_726:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_581
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_728
	#marker Label
bp_label_727:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_583
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_728
	#end of ifelse
bp_label_728:
	#end of statement jump
	j	bp_label_729
	#marker Label
bp_label_729:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_731
	#			 __freeing reg $t0
	#If False
	j	bp_label_730
	#marker Label
bp_label_730:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_732
	#reach Or derivation
	#marker Label
bp_label_731:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_585
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_733
	#marker Label
bp_label_732:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_587
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_733
	#end of ifelse
bp_label_733:
	#end of statement jump
	j	bp_label_734
	#marker Label
bp_label_734:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_736
	#			 __freeing reg $t0
	#If False
	j	bp_label_735
	#marker Label
bp_label_735:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_736
	#			 __freeing reg $t0
	#If False
	j	bp_label_737
	#reach Or derivation
	#marker Label
bp_label_736:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_589
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_738
	#marker Label
bp_label_737:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_591
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_738
	#end of ifelse
bp_label_738:
	#end of statement jump
	j	bp_label_739
	#marker Label
bp_label_739:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_741
	#			 __freeing reg $t0
	#If False
	j	bp_label_740
	#marker Label
bp_label_740:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_741
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_742
	#reach Or derivation
	#marker Label
bp_label_741:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_593
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_743
	#marker Label
bp_label_742:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_595
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_743
	#end of ifelse
bp_label_743:
	#end of statement jump
	j	bp_label_744
	#marker Label
bp_label_744:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_746
	#			 __freeing reg $t0
	#If False
	j	bp_label_745
	#marker Label
bp_label_745:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_746
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_747
	#reach Or derivation
	#marker Label
bp_label_746:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_597
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_748
	#marker Label
bp_label_747:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_599
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_748
	#end of ifelse
bp_label_748:
	#end of statement jump
	j	bp_label_749
	#marker Label
bp_label_749:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_751
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_750
	#marker Label
bp_label_750:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_751
	j	bp_label_752
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_751:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_601
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_753
	#marker Label
bp_label_752:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_603
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_753
	#end of ifelse
bp_label_753:
	#end of statement jump
	j	bp_label_754
	#marker Label
bp_label_754:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_756
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_755
	#marker Label
bp_label_755:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_757
	#reach Or derivation
	#marker Label
bp_label_756:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_605
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_758
	#marker Label
bp_label_757:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_607
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_758
	#end of ifelse
bp_label_758:
	#end of statement jump
	j	bp_label_759
	#marker Label
bp_label_759:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_761
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_760
	#marker Label
bp_label_760:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_761
	#			 __freeing reg $t0
	#If False
	j	bp_label_762
	#reach Or derivation
	#marker Label
bp_label_761:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_609
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_763
	#marker Label
bp_label_762:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_611
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_763
	#end of ifelse
bp_label_763:
	#end of statement jump
	j	bp_label_764
	#marker Label
bp_label_764:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_766
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_765
	#marker Label
bp_label_765:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_766
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_767
	#reach Or derivation
	#marker Label
bp_label_766:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_613
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_768
	#marker Label
bp_label_767:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_615
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_768
	#end of ifelse
bp_label_768:
	#end of statement jump
	j	bp_label_769
	#marker Label
bp_label_769:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_771
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_770
	#marker Label
bp_label_770:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_771
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_772
	#reach Or derivation
	#marker Label
bp_label_771:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_617
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_773
	#marker Label
bp_label_772:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_619
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_773
	#end of ifelse
bp_label_773:
	#end of statement jump
	j	bp_label_774
	#marker Label
bp_label_774:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_776
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_775
	#marker Label
bp_label_775:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_50
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func False
	bne $t0, $zero,bp_label_776
	j	bp_label_777
	#			 __freeing reg $t0
	#reach Or derivation
	#marker Label
bp_label_776:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_621
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_778
	#marker Label
bp_label_777:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_623
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_778
	#end of ifelse
bp_label_778:
	#end of statement jump
	j	bp_label_779
	#marker Label
bp_label_779:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_781
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_780
	#marker Label
bp_label_780:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_782
	#reach Or derivation
	#marker Label
bp_label_781:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_625
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_783
	#marker Label
bp_label_782:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_627
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_783
	#end of ifelse
bp_label_783:
	#end of statement jump
	j	bp_label_784
	#marker Label
bp_label_784:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_786
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_785
	#marker Label
bp_label_785:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t0, $zero,bp_label_786
	#			 __freeing reg $t0
	#If False
	j	bp_label_787
	#reach Or derivation
	#marker Label
bp_label_786:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_629
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_788
	#marker Label
bp_label_787:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_631
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_788
	#end of ifelse
bp_label_788:
	#end of statement jump
	j	bp_label_789
	#marker Label
bp_label_789:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_791
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_790
	#marker Label
bp_label_790:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,5
	bgt $t0, $t1,bp_label_791
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_792
	#reach Or derivation
	#marker Label
bp_label_791:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_633
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_793
	#marker Label
bp_label_792:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_635
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_793
	#end of ifelse
bp_label_793:
	#end of statement jump
	j	bp_label_794
	#marker Label
bp_label_794:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_796
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_795
	#marker Label
bp_label_795:
	#			 __allocating reg $t0
	li	$t0,4
	#			 __allocating reg $t1
	li	$t1,4
	bne $t0, $t1,bp_label_796
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_797
	#reach Or derivation
	#marker Label
bp_label_796:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_637
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_798
	#marker Label
bp_label_797:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_639
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_798
	#end of ifelse
bp_label_798:
	#end of statement jump
	j	bp_label_799
bp_label_799:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
