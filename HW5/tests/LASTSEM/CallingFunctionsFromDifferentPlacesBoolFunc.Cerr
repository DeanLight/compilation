[FIRST_PROGRAM_POINT]
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate comment://Call can come from Statement and from Exp.

Lex Ate token bool__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[funcByteTrue]>>
FuncHead_IR for func: funcByteTrue
got label label_29 in line: -1
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcByteTrue\n"__
[Exp_IR] Exp -> string"funcByteTrue\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_0
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_0 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: funcByteTrue
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[funcByteFalse]>>
FuncHead_IR for func: funcByteFalse
got label label_80 in line: -1
written label: label_80
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcByteFalse\n"__
[Exp_IR] Exp -> string"funcByteFalse\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_5
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_5 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: funcByteFalse
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__helperFunc1True__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[helperFunc1True]>>
FuncHead_IR for func: helperFunc1True
got label label_131 in line: -1
written label: label_131
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: helperFunc1True
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__helperFunc1False__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[helperFunc1False]>>
FuncHead_IR for func: helperFunc1False
got label label_168 in line: -1
written label: label_168
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: helperFunc1False
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__helperFunc2True__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[helperFunc2True]>>
FuncHead_IR for func: helperFunc2True
got label label_205 in line: -1
written label: label_205
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: helperFunc2True
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__helperFunc2False__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[helperFunc2False]>>
FuncHead_IR for func: helperFunc2False
got label label_242 in line: -1
written label: label_242
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: helperFunc2False
for an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__funcHelper1__
Lex Ate token  (__
Lex Ate token bool__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[funcHelper1]>>
FuncHead_IR for func: funcHelper1
got label label_279 in line: -1
written label: label_279
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__a__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: a
[MARKER IR]: label: bp_label_26
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper1-1\n"__
[Exp_IR] Exp -> string"funcHelper1-1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_27
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper1-2\n"__
[Exp_IR] Exp -> string"funcHelper1-2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: funcHelper1
for an extra ret will be added
Ret type: 1
Lex Ate token void__
Lex Ate token  id__funcHelper2__
Lex Ate token  (__
Lex Ate token bool__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
Lex Ate token  ,__
Lex Ate token bool__
Lex Ate token  id__bb__
<<FormalDecl_Semantic: id[bb]>>
Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[funcHelper2]>>
FuncHead_IR for func: funcHelper2
got label label_361 in line: -1
written label: label_361
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__a__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: a
[MARKER IR]: label: bp_label_30
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper2-1\n"__
[Exp_IR] Exp -> string"funcHelper2-1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_31
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper2-2\n"__
[Exp_IR] Exp -> string"funcHelper2-2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token if__
[MARKER IR]: label: bp_label_33
Lex Ate token  (__
Lex Ate token  id__bb__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb]>>
[Exp_IR] Exp -> id: bb
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb
[MARKER IR]: label: bp_label_34
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper2-3\n"__
[Exp_IR] Exp -> string"funcHelper2-3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_35
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"funcHelper2-4\n"__
[Exp_IR] Exp -> string"funcHelper2-4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_33 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: funcHelper2
for an extra ret will be added
Ret type: 1
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
FuncHead_IR for func: main
got label label_518 in line: -1
written label: label_518
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  {__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token bool__
[MARKER IR]: label: bp_label_38
Lex Ate token  id__z1__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[z1]type:[]>>
<<Statement_Semantic with id[z1]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_38 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_39
Lex Ate token  (__
Lex Ate token  id__z1__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[z1]>>
[Exp_IR] Exp -> id: z1
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: z1
[MARKER IR]: label: bp_label_40
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true1\n"__
[Exp_IR] Exp -> string"true1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_41
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false1\n"__
[Exp_IR] Exp -> string"false1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_39 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_43
Lex Ate token  id__z2__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[z2]type:[]>>
<<Statement_Semantic with id[z2]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_43 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_44
Lex Ate token  (__
Lex Ate token  id__z2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[z2]>>
[Exp_IR] Exp -> id: z2
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: z2
[MARKER IR]: label: bp_label_45
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true2\n"__
[Exp_IR] Exp -> string"true2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_46
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false2\n"__
[Exp_IR] Exp -> string"false2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_44 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_48
Lex Ate token  id__z3__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[z3]type:[]>>
<<Statement_Semantic with id[z3]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_48 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_49
Lex Ate token  (__
Lex Ate token  id__z3__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[z3]>>
[Exp_IR] Exp -> id: z3
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: z3
[MARKER IR]: label: bp_label_50
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true3\n"__
[Exp_IR] Exp -> string"true3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_51
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false3\n"__
[Exp_IR] Exp -> string"false3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_49 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_53
Lex Ate token  id__z4__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[z4]type:[]>>
<<Statement_Semantic with id[z4]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_53 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_54
Lex Ate token  (__
Lex Ate token  id__z4__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[z4]>>
[Exp_IR] Exp -> id: z4
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: z4
[MARKER IR]: label: bp_label_55
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true4\n"__
[Exp_IR] Exp -> string"true4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_56
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false4\n"__
[Exp_IR] Exp -> string"false4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_54 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_58
Lex Ate token  id__c__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[c]type:[]>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_58 breaklist size is 0
Lex Ate token  id__c__
[MARKER IR]: label: bp_label_59
Lex Ate token  =__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token  ;__
<<Statement_Semantic with id[c]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_59 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_60
Lex Ate token  (__
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: c
[MARKER IR]: label: bp_label_61
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true5\n"__
[Exp_IR] Exp -> string"true5\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_62
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false5\n"__
[Exp_IR] Exp -> string"false5\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_60 breaklist size is 0
Lex Ate token  id__c__
[MARKER IR]: label: bp_label_64
Lex Ate token  =__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
Lex Ate token  ;__
<<Statement_Semantic with id[c]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_64 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_65
Lex Ate token  (__
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: c
[MARKER IR]: label: bp_label_66
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true6\n"__
[Exp_IR] Exp -> string"true6\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_67
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false6\n"__
[Exp_IR] Exp -> string"false6\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_65 breaklist size is 0
Lex Ate token  id__c__
[MARKER IR]: label: bp_label_69
Lex Ate token  =__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token  ;__
<<Statement_Semantic with id[c]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_69 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_70
Lex Ate token  (__
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: c
[MARKER IR]: label: bp_label_71
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true7\n"__
[Exp_IR] Exp -> string"true7\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_72
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false7\n"__
[Exp_IR] Exp -> string"false7\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_70 breaklist size is 0
Lex Ate token  id__c__
[MARKER IR]: label: bp_label_74
Lex Ate token  =__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
Lex Ate token  ;__
<<Statement_Semantic with id[c]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_74 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_75
Lex Ate token  (__
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: c
[MARKER IR]: label: bp_label_76
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true8\n"__
[Exp_IR] Exp -> string"true8\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_77
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false8\n"__
[Exp_IR] Exp -> string"false8\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_75 breaklist size is 0
Lex Ate token  id__funcByteTrue__
[MARKER IR]: label: bp_label_79
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_79 breaklist size is 0
Lex Ate token  id__funcByteFalse__
[MARKER IR]: label: bp_label_80
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_80 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_81
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter5\n"__
[Exp_IR] Exp -> string"delimiter5\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_81 breaklist size is 0
Lex Ate comment://return funcByteTrue\False():

Lex Ate token bool__
[MARKER IR]: label: bp_label_82
Lex Ate token  id__d__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__helperFunc1True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments helperFunc1True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callhelperFunc1True
[Exp_IR] endof Exp->callhelperFunc1True
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[d]type:[]>>
<<Statement_Semantic with id[d]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_82 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_83
Lex Ate token  (__
Lex Ate token  id__d__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[d]>>
[Exp_IR] Exp -> id: d
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: d
[MARKER IR]: label: bp_label_84
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true9\n"__
[Exp_IR] Exp -> string"true9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_85
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false9\n"__
[Exp_IR] Exp -> string"false9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_83 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_87
Lex Ate token  id__dd__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__helperFunc1False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments helperFunc1False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callhelperFunc1False
[Exp_IR] endof Exp->callhelperFunc1False
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[dd]type:[]>>
<<Statement_Semantic with id[dd]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_87 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_88
Lex Ate token  (__
Lex Ate token  id__dd__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[dd]>>
[Exp_IR] Exp -> id: dd
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: dd
[MARKER IR]: label: bp_label_89
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true10\n"__
[Exp_IR] Exp -> string"true10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_90
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false10\n"__
[Exp_IR] Exp -> string"false10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_88 breaklist size is 0
Lex Ate comment://return (funcByte()):

Lex Ate token bool__
[MARKER IR]: label: bp_label_92
Lex Ate token  id__e__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__helperFunc2True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments helperFunc2True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callhelperFunc2True
[Exp_IR] endof Exp->callhelperFunc2True
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[e]type:[]>>
<<Statement_Semantic with id[e]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_92 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_93
Lex Ate token  (__
Lex Ate token  id__e__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[e]>>
[Exp_IR] Exp -> id: e
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: e
[MARKER IR]: label: bp_label_94
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true9\n"__
[Exp_IR] Exp -> string"true9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_95
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false9\n"__
[Exp_IR] Exp -> string"false9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_93 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_97
Lex Ate token  id__ff__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__helperFunc2False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments helperFunc2False
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callhelperFunc2False
[Exp_IR] endof Exp->callhelperFunc2False
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[ff]type:[]>>
<<Statement_Semantic with id[ff]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_97 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_98
Lex Ate token  (__
Lex Ate token  id__ff__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[ff]>>
[Exp_IR] Exp -> id: ff
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: ff
[MARKER IR]: label: bp_label_99
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true10\n"__
[Exp_IR] Exp -> string"true10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_100
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false10\n"__
[Exp_IR] Exp -> string"false10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_98 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_102
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[MARKER IR]: label: bp_label_103
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf1\n"__
[Exp_IR] Exp -> string"insideIf1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_104
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_102 breaklist size is 0
[MARKER IR]: label: bp_label_106
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter9\n"__
[Exp_IR] Exp -> string"delimiter9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_106 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_107
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_108
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf2\n"__
[Exp_IR] Exp -> string"insideIf2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_109
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_107 breaklist size is 0
[MARKER IR]: label: bp_label_111
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter10\n"__
[Exp_IR] Exp -> string"delimiter10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_111 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_112
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[MARKER IR]: label: bp_label_113
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf3\n"__
[Exp_IR] Exp -> string"insideIf3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_114
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_112 breaklist size is 0
[MARKER IR]: label: bp_label_116
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter11\n"__
[Exp_IR] Exp -> string"delimiter11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_116 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_117
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_118
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf4\n"__
[Exp_IR] Exp -> string"insideIf4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_119
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_117 breaklist size is 0
[MARKER IR]: label: bp_label_121
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter12\n"__
[Exp_IR] Exp -> string"delimiter12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_121 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_122
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_123
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_124
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_122 breaklist size is 0
[MARKER IR]: label: bp_label_126
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter13\n"__
[Exp_IR] Exp -> string"delimiter13\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_126 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_127
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_128
Lex Ate token  {__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_129
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_127 breaklist size is 0
[MARKER IR]: label: bp_label_131
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter14\n"__
[Exp_IR] Exp -> string"delimiter14\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_131 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_132
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[MARKER IR]: label: bp_label_133
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf1\n"__
[Exp_IR] Exp -> string"insideIf1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_134
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideElse1\n"__
[Exp_IR] Exp -> string"insideElse1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_132 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_136
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter9\n"__
[Exp_IR] Exp -> string"delimiter9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_136 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_137
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_138
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf2\n"__
[Exp_IR] Exp -> string"insideIf2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_139
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideElse2\n"__
[Exp_IR] Exp -> string"insideElse2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_137 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_141
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter10\n"__
[Exp_IR] Exp -> string"delimiter10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_141 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_142
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[MARKER IR]: label: bp_label_143
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf3\n"__
[Exp_IR] Exp -> string"insideIf3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_144
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideElse3\n"__
[Exp_IR] Exp -> string"insideElse3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_142 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_146
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter11\n"__
[Exp_IR] Exp -> string"delimiter11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_146 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_147
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteFalse
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_148
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideIf4\n"__
[Exp_IR] Exp -> string"insideIf4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_149
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideElse4\n"__
[Exp_IR] Exp -> string"insideElse4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_147 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_151
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter12\n"__
[Exp_IR] Exp -> string"delimiter12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_151 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_152
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_153
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_154
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_152 breaklist size is 0
[MARKER IR]: label: bp_label_156
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter13\n"__
[Exp_IR] Exp -> string"delimiter13\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_156 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_157
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_158
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_159
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_157 breaklist size is 0
[MARKER IR]: label: bp_label_161
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter14\n"__
[Exp_IR] Exp -> string"delimiter14\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_161 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_162
[MARKER IR]: label: bp_label_163
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[MARKER IR]: label: bp_label_164
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideWhile1"__
[Exp_IR] Exp -> string"insideWhile1"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_165
Lex Ate token  ;__
 new breakcommand at 3080 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_165 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_162 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_167
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter15\n"__
[Exp_IR] Exp -> string"delimiter15\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_167 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_168
[MARKER IR]: label: bp_label_169
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_170
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideWhile2"__
[Exp_IR] Exp -> string"insideWhile2"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_171
Lex Ate token  ;__
 new breakcommand at 3172 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_171 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_168 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_173
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter16\n"__
[Exp_IR] Exp -> string"delimiter16\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_173 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_174
[MARKER IR]: label: bp_label_175
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[MARKER IR]: label: bp_label_176
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideWhile3"__
[Exp_IR] Exp -> string"insideWhile3"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_177
Lex Ate token  ;__
 new breakcommand at 3264 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_177 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_174 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_179
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter17\n"__
[Exp_IR] Exp -> string"delimiter17\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_179 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_180
[MARKER IR]: label: bp_label_181
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: funcByteTrue
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_182
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"insideWhile4"__
[Exp_IR] Exp -> string"insideWhile4"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_183
Lex Ate token  ;__
 new breakcommand at 3356 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_183 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_180 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_185
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter18\n"__
[Exp_IR] Exp -> string"delimiter18\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_185 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_186
[MARKER IR]: label: bp_label_187
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_188
Lex Ate token  {__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_189
Lex Ate token  ;__
 new breakcommand at 3422 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_189 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_186 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_191
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter19\n"__
[Exp_IR] Exp -> string"delimiter19\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_191 breaklist size is 0
Lex Ate token byte__
[MARKER IR]: label: bp_label_192
Lex Ate token  id__u__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__2__
Lex Ate token B__
<<[Exp_Semantic] B:[2]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[u]type:[]>>
<<Statement_Semantic with id[u]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_192 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_193
Lex Ate token  (__
Lex Ate token  id__u__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[u]>>
[Exp_IR] Exp -> id: u
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_195
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  {__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_196
Lex Ate token  ;__
 new breakcommand at 3504 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_196 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_193 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_199
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter23\n"__
[Exp_IR] Exp -> string"delimiter23\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_199 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_200
Lex Ate token  (__
Lex Ate token  id__u__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[u]>>
[Exp_IR] Exp -> id: u
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_202
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_203
Lex Ate token  ;__
 new breakcommand at 3583 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_203 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_200 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_206
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter24\n"__
[Exp_IR] Exp -> string"delimiter24\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_206 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_207
Lex Ate token  (__
Lex Ate token  id__u__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[u]>>
[Exp_IR] Exp -> id: u
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_209
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  {__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_210
Lex Ate token  ;__
 new breakcommand at 3662 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_210 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_207 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_213
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter23\n"__
[Exp_IR] Exp -> string"delimiter23\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_213 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_214
Lex Ate token  (__
Lex Ate token  id__u__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[u]>>
[Exp_IR] Exp -> id: u
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_216
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_217
Lex Ate token  ;__
 new breakcommand at 3741 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_217 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_214 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_220
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter24\n"__
[Exp_IR] Exp -> string"delimiter24\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_220 breaklist size is 0
Lex Ate token byte__
[MARKER IR]: label: bp_label_221
Lex Ate token  id__ub__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__2__
Lex Ate token B__
<<[Exp_Semantic] B:[2]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[ub]type:[]>>
<<Statement_Semantic with id[ub]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_221 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_222
Lex Ate token  (__
Lex Ate token  id__ub__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[ub]>>
[Exp_IR] Exp -> id: ub
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_224
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token B__
Lex Ate token  :__
Lex Ate token  {__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_225
Lex Ate token  ;__
 new breakcommand at 3831 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_225 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_222 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_228
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter25\n"__
[Exp_IR] Exp -> string"delimiter25\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_228 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_229
Lex Ate token  (__
Lex Ate token  id__ub__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[ub]>>
[Exp_IR] Exp -> id: ub
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_231
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token B__
Lex Ate token  :__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_232
Lex Ate token  ;__
 new breakcommand at 3910 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_232 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_229 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_235
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter26\n"__
[Exp_IR] Exp -> string"delimiter26\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_235 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_236
Lex Ate token  (__
Lex Ate token  id__ub__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[ub]>>
[Exp_IR] Exp -> id: ub
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_238
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token B__
Lex Ate token  :__
Lex Ate token  {__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_239
Lex Ate token  ;__
 new breakcommand at 3989 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_239 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_236 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_242
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter25\n"__
[Exp_IR] Exp -> string"delimiter25\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_242 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_243
Lex Ate token  (__
Lex Ate token  id__ub__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[ub]>>
[Exp_IR] Exp -> id: ub
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_245
Lex Ate token case__
Lex Ate token  num__2__
Lex Ate token B__
Lex Ate token  :__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_246
Lex Ate token  ;__
 new breakcommand at 4068 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_246 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  1
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
before backpatching case nextlists
before backpatching case breaklists
reached non empty case in breaking 0outof 0 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_243 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_249
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"delimiter26\n"__
[Exp_IR] Exp -> string"delimiter26\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_249 breaklist size is 0
Lex Ate token  id__funcHelper1__
[MARKER IR]: label: bp_label_250
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : funcByteTrue
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: funcByteTrue
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments funcHelper1
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_250 breaklist size is 0
Lex Ate token  id__funcHelper2__
[MARKER IR]: label: bp_label_254
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token  ,__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : funcByteTrue
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: funcByteTrue
[ExpList_IR: ExpList->Exp]: funcByteTrue
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments funcHelper2
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_254 breaklist size is 0
Lex Ate token  id__funcHelper1__
[MARKER IR]: label: bp_label_261
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : funcByteFalse
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: funcByteFalse
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments funcHelper1
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_261 breaklist size is 0
Lex Ate token  id__funcHelper2__
[MARKER IR]: label: bp_label_265
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token  ,__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : funcByteFalse
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: funcByteFalse
[ExpList_IR: ExpList->Exp]: funcByteFalse
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments funcHelper2
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_265 breaklist size is 0
Lex Ate comment://Need to check every exp with (funcByte())

Lex Ate comment://bool bb1 = funcByte()*funcByte(); printi(bb1);

Lex Ate comment://bool bb2 = funcByte()/funcByte(); printi(bb2);

Lex Ate comment://bool bb3 = funcByte()+funcByte(); printi(bb3);

Lex Ate comment://bool bb4 = funcByte()-funcByte(); printi(bb4);

Lex Ate comment://calling true

Lex Ate token bool__
[MARKER IR]: label: bp_label_272
Lex Ate token  id__bb5__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[bb5]type:[]>>
<<Statement_Semantic with id[bb5]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_272 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_273
Lex Ate token  (__
Lex Ate token  id__bb5__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb5]>>
[Exp_IR] Exp -> id: bb5
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb5
[MARKER IR]: label: bp_label_274
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true1\n"__
[Exp_IR] Exp -> string"true1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_275
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false1\n"__
[Exp_IR] Exp -> string"false1\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_273 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_277
Lex Ate token  id__aa5__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa5]type:[]>>
<<Statement_Semantic with id[aa5]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_277 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_278
Lex Ate token  (__
Lex Ate token  id__aa5__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa5]>>
[Exp_IR] Exp -> id: aa5
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa5
[MARKER IR]: label: bp_label_279
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true2\n"__
[Exp_IR] Exp -> string"true2\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_280
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false\n"__
[Exp_IR] Exp -> string"false\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_278 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_282
Lex Ate token  id__bb6__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token and__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_283
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteTrue falselistSize: 1
exp2:funcByteTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[bb6]type:[]>>
<<Statement_Semantic with id[bb6]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_282 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_284
Lex Ate token  (__
Lex Ate token  id__bb6__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb6]>>
[Exp_IR] Exp -> id: bb6
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb6
[MARKER IR]: label: bp_label_285
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true3\n"__
[Exp_IR] Exp -> string"true3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_286
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false3\n"__
[Exp_IR] Exp -> string"false3\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_284 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_288
Lex Ate token  id__aa6__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token and__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_289
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteTrue falselistSize: 1
exp2:funcByteTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 2
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa6]type:[]>>
<<Statement_Semantic with id[aa6]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_288 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_290
Lex Ate token  (__
Lex Ate token  id__aa6__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa6]>>
[Exp_IR] Exp -> id: aa6
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa6
[MARKER IR]: label: bp_label_291
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true4\n"__
[Exp_IR] Exp -> string"true4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_292
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false4\n"__
[Exp_IR] Exp -> string"false4\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_290 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_294
Lex Ate token  id__bb7__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token or__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_295
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_295
exp1:funcByteTrue truelistSize: 1
exp2:funcByteTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[bb7]type:[]>>
<<Statement_Semantic with id[bb7]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_294 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_296
Lex Ate token  (__
Lex Ate token  id__bb7__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb7]>>
[Exp_IR] Exp -> id: bb7
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb7
[MARKER IR]: label: bp_label_297
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true5\n"__
[Exp_IR] Exp -> string"true5\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_298
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false5\n"__
[Exp_IR] Exp -> string"false5\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_296 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_300
Lex Ate token  id__aa7__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token or__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_301
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_301
exp1:funcByteTrue truelistSize: 1
exp2:funcByteTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa7]type:[]>>
<<Statement_Semantic with id[aa7]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_300 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_302
Lex Ate token  (__
Lex Ate token  id__aa7__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa7]>>
[Exp_IR] Exp -> id: aa7
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa7
[MARKER IR]: label: bp_label_303
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true6\n"__
[Exp_IR] Exp -> string"true6\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_304
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false6\n"__
[Exp_IR] Exp -> string"false6\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_302 breaklist size is 0
Lex Ate comment://calling false

Lex Ate token bool__
[MARKER IR]: label: bp_label_306
Lex Ate token  id__bb8__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[bb8]type:[]>>
<<Statement_Semantic with id[bb8]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_306 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_307
Lex Ate token  (__
Lex Ate token  id__bb8__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb8]>>
[Exp_IR] Exp -> id: bb8
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb8
[MARKER IR]: label: bp_label_308
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true7\n"__
[Exp_IR] Exp -> string"true7\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_309
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false7\n"__
[Exp_IR] Exp -> string"false7\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_307 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_311
Lex Ate token  id__aa8__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa8]type:[]>>
<<Statement_Semantic with id[aa8]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_311 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_312
Lex Ate token  (__
Lex Ate token  id__aa8__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa8]>>
[Exp_IR] Exp -> id: aa8
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa8
[MARKER IR]: label: bp_label_313
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true8\n"__
[Exp_IR] Exp -> string"true8\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_314
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false8\n"__
[Exp_IR] Exp -> string"false8\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_312 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_316
Lex Ate token  id__bb9__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token and__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_317
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteFalse falselistSize: 1
exp2:funcByteFalse falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[bb9]type:[]>>
<<Statement_Semantic with id[bb9]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_316 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_318
Lex Ate token  (__
Lex Ate token  id__bb9__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb9]>>
[Exp_IR] Exp -> id: bb9
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb9
[MARKER IR]: label: bp_label_319
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true9\n"__
[Exp_IR] Exp -> string"true9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_320
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false9\n"__
[Exp_IR] Exp -> string"false9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_318 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_322
Lex Ate token  id__aa9__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token and__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_323
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteFalse falselistSize: 1
exp2:funcByteTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 2
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa9]type:[]>>
<<Statement_Semantic with id[aa9]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_322 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_324
Lex Ate token  (__
Lex Ate token  id__aa9__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa9]>>
[Exp_IR] Exp -> id: aa9
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa9
[MARKER IR]: label: bp_label_325
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true10\n"__
[Exp_IR] Exp -> string"true10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_326
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false10\n"__
[Exp_IR] Exp -> string"false10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_324 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_328
Lex Ate token  id__bb10__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token or__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_329
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_329
exp1:funcByteFalse truelistSize: 1
exp2:funcByteFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[bb10]type:[]>>
<<Statement_Semantic with id[bb10]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_328 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_330
Lex Ate token  (__
Lex Ate token  id__bb10__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb10]>>
[Exp_IR] Exp -> id: bb10
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb10
[MARKER IR]: label: bp_label_331
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true11\n"__
[Exp_IR] Exp -> string"true11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_332
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false11\n"__
[Exp_IR] Exp -> string"false11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_330 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_334
Lex Ate token  id__aa10__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token or__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_335
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_335
exp1:funcByteFalse truelistSize: 1
exp2:funcByteFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa10]type:[]>>
<<Statement_Semantic with id[aa10]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_334 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_336
Lex Ate token  (__
Lex Ate token  id__aa10__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa10]>>
[Exp_IR] Exp -> id: aa10
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa10
[MARKER IR]: label: bp_label_337
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true12\n"__
[Exp_IR] Exp -> string"true12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_338
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false12\n"__
[Exp_IR] Exp -> string"false12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_336 breaklist size is 0
Lex Ate comment://calling true and then false

Lex Ate token bool__
[MARKER IR]: label: bp_label_340
Lex Ate token  id__bb11__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token and__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_341
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteTrue falselistSize: 1
exp2:funcByteFalse falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[bb11]type:[]>>
<<Statement_Semantic with id[bb11]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_340 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_342
Lex Ate token  (__
Lex Ate token  id__bb11__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb11]>>
[Exp_IR] Exp -> id: bb11
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb11
[MARKER IR]: label: bp_label_343
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true9\n"__
[Exp_IR] Exp -> string"true9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_344
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false9\n"__
[Exp_IR] Exp -> string"false9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_342 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_346
Lex Ate token  id__aa11__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token and__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_347
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteTrue falselistSize: 1
exp2:funcByteFalse falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 2
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa11]type:[]>>
<<Statement_Semantic with id[aa11]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_346 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_348
Lex Ate token  (__
Lex Ate token  id__aa11__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa11]>>
[Exp_IR] Exp -> id: aa11
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa11
[MARKER IR]: label: bp_label_349
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true10\n"__
[Exp_IR] Exp -> string"true10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_350
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false10\n"__
[Exp_IR] Exp -> string"false10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_348 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_352
Lex Ate token  id__bb12__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token or__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_353
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_353
exp1:funcByteTrue truelistSize: 1
exp2:funcByteFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[bb12]type:[]>>
<<Statement_Semantic with id[bb12]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_352 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_354
Lex Ate token  (__
Lex Ate token  id__bb12__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb12]>>
[Exp_IR] Exp -> id: bb12
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb12
[MARKER IR]: label: bp_label_355
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true11\n"__
[Exp_IR] Exp -> string"true11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_356
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false11\n"__
[Exp_IR] Exp -> string"false11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_354 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_358
Lex Ate token  id__aa12__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
Lex Ate token or__
[SJ_Exp_IR]: funcByteTrue
[MARKER IR]: label: bp_label_359
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
[SJ_Exp_IR]: funcByteFalse
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_359
exp1:funcByteTrue truelistSize: 1
exp2:funcByteFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa12]type:[]>>
<<Statement_Semantic with id[aa12]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_358 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_360
Lex Ate token  (__
Lex Ate token  id__aa12__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa12]>>
[Exp_IR] Exp -> id: aa12
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa12
[MARKER IR]: label: bp_label_361
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true12\n"__
[Exp_IR] Exp -> string"true12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_362
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false12\n"__
[Exp_IR] Exp -> string"false12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_360 breaklist size is 0
Lex Ate comment://calling false and then true

Lex Ate token bool__
[MARKER IR]: label: bp_label_364
Lex Ate token  id__bb13__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token and__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_365
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteFalse falselistSize: 1
exp2:funcByteTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[bb13]type:[]>>
<<Statement_Semantic with id[bb13]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_364 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_366
Lex Ate token  (__
Lex Ate token  id__bb13__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb13]>>
[Exp_IR] Exp -> id: bb13
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb13
[MARKER IR]: label: bp_label_367
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true9\n"__
[Exp_IR] Exp -> string"true9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_368
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false9\n"__
[Exp_IR] Exp -> string"false9\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_366 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_370
Lex Ate token  id__aa13__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token and__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_371
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:funcByteFalse falselistSize: 1
exp2:funcByteTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 2
(Exp) truelistSize: 1
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa13]type:[]>>
<<Statement_Semantic with id[aa13]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_370 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_372
Lex Ate token  (__
Lex Ate token  id__aa13__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa13]>>
[Exp_IR] Exp -> id: aa13
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa13
[MARKER IR]: label: bp_label_373
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true10\n"__
[Exp_IR] Exp -> string"true10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_374
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false10\n"__
[Exp_IR] Exp -> string"false10\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_372 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_376
Lex Ate token  id__bb14__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token or__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_377
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_377
exp1:funcByteFalse truelistSize: 1
exp2:funcByteTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[bb14]type:[]>>
<<Statement_Semantic with id[bb14]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_376 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_378
Lex Ate token  (__
Lex Ate token  id__bb14__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[bb14]>>
[Exp_IR] Exp -> id: bb14
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: bb14
[MARKER IR]: label: bp_label_379
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true11\n"__
[Exp_IR] Exp -> string"true11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_380
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false11\n"__
[Exp_IR] Exp -> string"false11\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_378 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_382
Lex Ate token  id__aa14__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token not__
Lex Ate token  (__
Lex Ate token  id__funcByteFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteFalse
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteFalse
[Exp_IR] endof Exp->callfuncByteFalse
Lex Ate token or__
[SJ_Exp_IR]: funcByteFalse
[MARKER IR]: label: bp_label_383
Lex Ate token  id__funcByteTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments funcByteTrue
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfuncByteTrue
[Exp_IR] endof Exp->callfuncByteTrue
[SJ_Exp_IR]: funcByteTrue
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_383
exp1:funcByteFalse truelistSize: 1
exp2:funcByteTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[aa14]type:[]>>
<<Statement_Semantic with id[aa14]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_382 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_384
Lex Ate token  (__
Lex Ate token  id__aa14__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[aa14]>>
[Exp_IR] Exp -> id: aa14
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: aa14
[MARKER IR]: label: bp_label_385
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true12\n"__
[Exp_IR] Exp -> string"true12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_386
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false12\n"__
[Exp_IR] Exp -> string"false12\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_384 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
for an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with label_518
[END_OF Program_IR]



 == printing data === 



pvufne1:	.asciiz "Error division by zero
"
string_label_0:	.asciiz "funcByteTrue\n"
string_label_1:	.asciiz "funcByteTrue\n"
string_label_2:	.asciiz "funcByteFalse\n"
string_label_3:	.asciiz "funcByteFalse\n"
string_label_4:	.asciiz "funcHelper1-1\n"
string_label_5:	.asciiz "funcHelper1-1\n"
string_label_6:	.asciiz "funcHelper1-2\n"
string_label_7:	.asciiz "funcHelper1-2\n"
string_label_8:	.asciiz "funcHelper2-1\n"
string_label_9:	.asciiz "funcHelper2-1\n"
string_label_10:	.asciiz "funcHelper2-2\n"
string_label_11:	.asciiz "funcHelper2-2\n"
string_label_12:	.asciiz "funcHelper2-3\n"
string_label_13:	.asciiz "funcHelper2-3\n"
string_label_14:	.asciiz "funcHelper2-4\n"
string_label_15:	.asciiz "funcHelper2-4\n"
string_label_16:	.asciiz "true1\n"
string_label_17:	.asciiz "true1\n"
string_label_18:	.asciiz "false1\n"
string_label_19:	.asciiz "false1\n"
string_label_20:	.asciiz "true2\n"
string_label_21:	.asciiz "true2\n"
string_label_22:	.asciiz "false2\n"
string_label_23:	.asciiz "false2\n"
string_label_24:	.asciiz "true3\n"
string_label_25:	.asciiz "true3\n"
string_label_26:	.asciiz "false3\n"
string_label_27:	.asciiz "false3\n"
string_label_28:	.asciiz "true4\n"
string_label_29:	.asciiz "true4\n"
string_label_30:	.asciiz "false4\n"
string_label_31:	.asciiz "false4\n"
string_label_32:	.asciiz "true5\n"
string_label_33:	.asciiz "true5\n"
string_label_34:	.asciiz "false5\n"
string_label_35:	.asciiz "false5\n"
string_label_36:	.asciiz "true6\n"
string_label_37:	.asciiz "true6\n"
string_label_38:	.asciiz "false6\n"
string_label_39:	.asciiz "false6\n"
string_label_40:	.asciiz "true7\n"
string_label_41:	.asciiz "true7\n"
string_label_42:	.asciiz "false7\n"
string_label_43:	.asciiz "false7\n"
string_label_44:	.asciiz "true8\n"
string_label_45:	.asciiz "true8\n"
string_label_46:	.asciiz "false8\n"
string_label_47:	.asciiz "false8\n"
string_label_48:	.asciiz "delimiter5\n"
string_label_49:	.asciiz "delimiter5\n"
string_label_50:	.asciiz "true9\n"
string_label_51:	.asciiz "true9\n"
string_label_52:	.asciiz "false9\n"
string_label_53:	.asciiz "false9\n"
string_label_54:	.asciiz "true10\n"
string_label_55:	.asciiz "true10\n"
string_label_56:	.asciiz "false10\n"
string_label_57:	.asciiz "false10\n"
string_label_58:	.asciiz "true9\n"
string_label_59:	.asciiz "true9\n"
string_label_60:	.asciiz "false9\n"
string_label_61:	.asciiz "false9\n"
string_label_62:	.asciiz "true10\n"
string_label_63:	.asciiz "true10\n"
string_label_64:	.asciiz "false10\n"
string_label_65:	.asciiz "false10\n"
string_label_66:	.asciiz "insideIf1\n"
string_label_67:	.asciiz "insideIf1\n"
string_label_68:	.asciiz "delimiter9\n"
string_label_69:	.asciiz "delimiter9\n"
string_label_70:	.asciiz "insideIf2\n"
string_label_71:	.asciiz "insideIf2\n"
string_label_72:	.asciiz "delimiter10\n"
string_label_73:	.asciiz "delimiter10\n"
string_label_74:	.asciiz "insideIf3\n"
string_label_75:	.asciiz "insideIf3\n"
string_label_76:	.asciiz "delimiter11\n"
string_label_77:	.asciiz "delimiter11\n"
string_label_78:	.asciiz "insideIf4\n"
string_label_79:	.asciiz "insideIf4\n"
string_label_80:	.asciiz "delimiter12\n"
string_label_81:	.asciiz "delimiter12\n"
string_label_82:	.asciiz "delimiter13\n"
string_label_83:	.asciiz "delimiter13\n"
string_label_84:	.asciiz "delimiter14\n"
string_label_85:	.asciiz "delimiter14\n"
string_label_86:	.asciiz "insideIf1\n"
string_label_87:	.asciiz "insideIf1\n"
string_label_88:	.asciiz "insideElse1\n"
string_label_89:	.asciiz "insideElse1\n"
string_label_90:	.asciiz "delimiter9\n"
string_label_91:	.asciiz "delimiter9\n"
string_label_92:	.asciiz "insideIf2\n"
string_label_93:	.asciiz "insideIf2\n"
string_label_94:	.asciiz "insideElse2\n"
string_label_95:	.asciiz "insideElse2\n"
string_label_96:	.asciiz "delimiter10\n"
string_label_97:	.asciiz "delimiter10\n"
string_label_98:	.asciiz "insideIf3\n"
string_label_99:	.asciiz "insideIf3\n"
string_label_100:	.asciiz "insideElse3\n"
string_label_101:	.asciiz "insideElse3\n"
string_label_102:	.asciiz "delimiter11\n"
string_label_103:	.asciiz "delimiter11\n"
string_label_104:	.asciiz "insideIf4\n"
string_label_105:	.asciiz "insideIf4\n"
string_label_106:	.asciiz "insideElse4\n"
string_label_107:	.asciiz "insideElse4\n"
string_label_108:	.asciiz "delimiter12\n"
string_label_109:	.asciiz "delimiter12\n"
string_label_110:	.asciiz "delimiter13\n"
string_label_111:	.asciiz "delimiter13\n"
string_label_112:	.asciiz "delimiter14\n"
string_label_113:	.asciiz "delimiter14\n"
string_label_114:	.asciiz "insideWhile1"
string_label_115:	.asciiz "insideWhile1"
string_label_116:	.asciiz "delimiter15\n"
string_label_117:	.asciiz "delimiter15\n"
string_label_118:	.asciiz "insideWhile2"
string_label_119:	.asciiz "insideWhile2"
string_label_120:	.asciiz "delimiter16\n"
string_label_121:	.asciiz "delimiter16\n"
string_label_122:	.asciiz "insideWhile3"
string_label_123:	.asciiz "insideWhile3"
string_label_124:	.asciiz "delimiter17\n"
string_label_125:	.asciiz "delimiter17\n"
string_label_126:	.asciiz "insideWhile4"
string_label_127:	.asciiz "insideWhile4"
string_label_128:	.asciiz "delimiter18\n"
string_label_129:	.asciiz "delimiter18\n"
string_label_130:	.asciiz "delimiter19\n"
string_label_131:	.asciiz "delimiter19\n"
string_label_132:	.asciiz "delimiter23\n"
string_label_133:	.asciiz "delimiter23\n"
string_label_134:	.asciiz "delimiter24\n"
string_label_135:	.asciiz "delimiter24\n"
string_label_136:	.asciiz "delimiter23\n"
string_label_137:	.asciiz "delimiter23\n"
string_label_138:	.asciiz "delimiter24\n"
string_label_139:	.asciiz "delimiter24\n"
string_label_140:	.asciiz "delimiter25\n"
string_label_141:	.asciiz "delimiter25\n"
string_label_142:	.asciiz "delimiter26\n"
string_label_143:	.asciiz "delimiter26\n"
string_label_144:	.asciiz "delimiter25\n"
string_label_145:	.asciiz "delimiter25\n"
string_label_146:	.asciiz "delimiter26\n"
string_label_147:	.asciiz "delimiter26\n"
string_label_148:	.asciiz "true1\n"
string_label_149:	.asciiz "true1\n"
string_label_150:	.asciiz "false1\n"
string_label_151:	.asciiz "false1\n"
string_label_152:	.asciiz "true2\n"
string_label_153:	.asciiz "true2\n"
string_label_154:	.asciiz "false\n"
string_label_155:	.asciiz "false\n"
string_label_156:	.asciiz "true3\n"
string_label_157:	.asciiz "true3\n"
string_label_158:	.asciiz "false3\n"
string_label_159:	.asciiz "false3\n"
string_label_160:	.asciiz "true4\n"
string_label_161:	.asciiz "true4\n"
string_label_162:	.asciiz "false4\n"
string_label_163:	.asciiz "false4\n"
string_label_164:	.asciiz "true5\n"
string_label_165:	.asciiz "true5\n"
string_label_166:	.asciiz "false5\n"
string_label_167:	.asciiz "false5\n"
string_label_168:	.asciiz "true6\n"
string_label_169:	.asciiz "true6\n"
string_label_170:	.asciiz "false6\n"
string_label_171:	.asciiz "false6\n"
string_label_172:	.asciiz "true7\n"
string_label_173:	.asciiz "true7\n"
string_label_174:	.asciiz "false7\n"
string_label_175:	.asciiz "false7\n"
string_label_176:	.asciiz "true8\n"
string_label_177:	.asciiz "true8\n"
string_label_178:	.asciiz "false8\n"
string_label_179:	.asciiz "false8\n"
string_label_180:	.asciiz "true9\n"
string_label_181:	.asciiz "true9\n"
string_label_182:	.asciiz "false9\n"
string_label_183:	.asciiz "false9\n"
string_label_184:	.asciiz "true10\n"
string_label_185:	.asciiz "true10\n"
string_label_186:	.asciiz "false10\n"
string_label_187:	.asciiz "false10\n"
string_label_188:	.asciiz "true11\n"
string_label_189:	.asciiz "true11\n"
string_label_190:	.asciiz "false11\n"
string_label_191:	.asciiz "false11\n"
string_label_192:	.asciiz "true12\n"
string_label_193:	.asciiz "true12\n"
string_label_194:	.asciiz "false12\n"
string_label_195:	.asciiz "false12\n"
string_label_196:	.asciiz "true9\n"
string_label_197:	.asciiz "true9\n"
string_label_198:	.asciiz "false9\n"
string_label_199:	.asciiz "false9\n"
string_label_200:	.asciiz "true10\n"
string_label_201:	.asciiz "true10\n"
string_label_202:	.asciiz "false10\n"
string_label_203:	.asciiz "false10\n"
string_label_204:	.asciiz "true11\n"
string_label_205:	.asciiz "true11\n"
string_label_206:	.asciiz "false11\n"
string_label_207:	.asciiz "false11\n"
string_label_208:	.asciiz "true12\n"
string_label_209:	.asciiz "true12\n"
string_label_210:	.asciiz "false12\n"
string_label_211:	.asciiz "false12\n"
string_label_212:	.asciiz "true9\n"
string_label_213:	.asciiz "true9\n"
string_label_214:	.asciiz "false9\n"
string_label_215:	.asciiz "false9\n"
string_label_216:	.asciiz "true10\n"
string_label_217:	.asciiz "true10\n"
string_label_218:	.asciiz "false10\n"
string_label_219:	.asciiz "false10\n"
string_label_220:	.asciiz "true11\n"
string_label_221:	.asciiz "true11\n"
string_label_222:	.asciiz "false11\n"
string_label_223:	.asciiz "false11\n"
string_label_224:	.asciiz "true12\n"
string_label_225:	.asciiz "true12\n"
string_label_226:	.asciiz "false12\n"
string_label_227:	.asciiz "false12\n"



 == printing code === 



	#first program point
main:
	#initialize fp
	move	$fp,$sp
	jal	label_518
	#exiting...
li $v0, 10
syscall
	#print_func:
print:
lw $a0,4($sp)
li $v0,4
syscall
jr $ra
	#printi func:
printi:
lw $a0,4($sp)
li $v0,1
syscall
jr $ra
	#div by 0 handler:
nayalo:
	li	$v0, 4
	la	$a0, pvufne1
	syscall
	#exiting...
li $v0, 10
syscall
	#Func funcByteTrue:
label_29:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_1
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_0
	#marker Label
bp_label_0:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_2
	#return noneVoid in v0
bp_label_2:
	li	$v0,1
	j	bp_label_1
bp_label_3:
	li	$v0,0
bp_label_1:
	move	$sp,$fp
	jr	$ra
bp_label_4:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func funcByteFalse:
label_80:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_3
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_5
	#marker Label
bp_label_5:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_8
	#return noneVoid in v0
bp_label_7:
	li	$v0,1
	j	bp_label_6
bp_label_8:
	li	$v0,0
bp_label_6:
	move	$sp,$fp
	jr	$ra
bp_label_9:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func helperFunc1True:
label_131:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_11
	j	bp_label_12
	#			 __freeing reg $t0
	#return noneVoid in v0
bp_label_11:
	li	$v0,1
	j	bp_label_10
bp_label_12:
	li	$v0,0
bp_label_10:
	move	$sp,$fp
	jr	$ra
bp_label_13:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func helperFunc1False:
label_168:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_15
	j	bp_label_16
	#			 __freeing reg $t0
	#return noneVoid in v0
bp_label_15:
	li	$v0,1
	j	bp_label_14
bp_label_16:
	li	$v0,0
bp_label_14:
	move	$sp,$fp
	jr	$ra
bp_label_17:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func helperFunc2True:
label_205:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_19
	j	bp_label_20
	#			 __freeing reg $t0
	#return noneVoid in v0
bp_label_19:
	li	$v0,1
	j	bp_label_18
bp_label_20:
	li	$v0,0
bp_label_18:
	move	$sp,$fp
	jr	$ra
bp_label_21:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func helperFunc2False:
label_242:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_23
	j	bp_label_24
	#			 __freeing reg $t0
	#return noneVoid in v0
bp_label_23:
	li	$v0,1
	j	bp_label_22
bp_label_24:
	li	$v0,0
bp_label_22:
	move	$sp,$fp
	jr	$ra
bp_label_25:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func funcHelper1:
label_279:
	#Getting Var falue for [Exp->id]: a offset is 4($fp)
	#			 __allocating reg $t0
	lw $t0, 4($fp)
	#a Bool Var a in boolean operator
	#If true
	bne $t0, $zero,bp_label_26
	#			 __freeing reg $t0
	#If False
	j	bp_label_27
	#marker Label
bp_label_26:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_5
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_28
	#marker Label
bp_label_27:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_7
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_28
	#end of ifelse
bp_label_28:
	#end of statement jump
	j	bp_label_29
bp_label_29:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func funcHelper2:
label_361:
	#Getting Var falue for [Exp->id]: a offset is 4($fp)
	#			 __allocating reg $t0
	lw $t0, 4($fp)
	#a Bool Var a in boolean operator
	#If true
	bne $t0, $zero,bp_label_30
	#			 __freeing reg $t0
	#If False
	j	bp_label_31
	#marker Label
bp_label_30:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_9
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_32
	#marker Label
bp_label_31:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_11
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_32
	#end of ifelse
bp_label_32:
	#end of statement jump
	j	bp_label_33
	#marker Label
bp_label_33:
	#Getting Var falue for [Exp->id]: bb offset is 8($fp)
	#			 __allocating reg $t0
	lw $t0, 8($fp)
	#a Bool Var bb in boolean operator
	#If true
	bne $t0, $zero,bp_label_34
	#			 __freeing reg $t0
	#If False
	j	bp_label_35
	#marker Label
bp_label_34:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_13
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_36
	#marker Label
bp_label_35:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_15
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_36
	#end of ifelse
bp_label_36:
	#end of statement jump
	j	bp_label_37
bp_label_37:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func main:
label_518:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_38
	#marker Label
bp_label_38:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn0
	j	bExpAss_nfjdn1
	#			 __freeing reg $t0
bExpAss_nfjdn0:
	#assigning True to z1
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, ($fp)
	j	bp_label_39
bExpAss_nfjdn1:
	#assigning False to z1
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, ($fp)
	j	bp_label_39
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_39
	#marker Label
bp_label_39:
	#Getting Var falue for [Exp->id]: z1 offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
	#a Bool Var z1 in boolean operator
	#If true
	bne $t0, $zero,bp_label_40
	#			 __freeing reg $t0
	#If False
	j	bp_label_41
	#marker Label
bp_label_40:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_17
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_42
	#marker Label
bp_label_41:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_19
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_42
	#end of ifelse
bp_label_42:
	#end of statement jump
	j	bp_label_43
	#marker Label
bp_label_43:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn2
	j	bExpAss_nfjdn3
	#			 __freeing reg $t0
bExpAss_nfjdn2:
	#assigning True to z2
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -4($fp)
	j	bp_label_44
bExpAss_nfjdn3:
	#assigning False to z2
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -4($fp)
	j	bp_label_44
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_44
	#marker Label
bp_label_44:
	#Getting Var falue for [Exp->id]: z2 offset is -4($fp)
	#			 __allocating reg $t0
	lw $t0, -4($fp)
	#a Bool Var z2 in boolean operator
	#If true
	bne $t0, $zero,bp_label_45
	#			 __freeing reg $t0
	#If False
	j	bp_label_46
	#marker Label
bp_label_45:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_21
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_47
	#marker Label
bp_label_46:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_23
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_47
	#end of ifelse
bp_label_47:
	#end of statement jump
	j	bp_label_48
	#marker Label
bp_label_48:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn4
	j	bExpAss_nfjdn5
	#			 __freeing reg $t0
bExpAss_nfjdn4:
	#assigning True to z3
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -8($fp)
	j	bp_label_49
bExpAss_nfjdn5:
	#assigning False to z3
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -8($fp)
	j	bp_label_49
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_49
	#marker Label
bp_label_49:
	#Getting Var falue for [Exp->id]: z3 offset is -8($fp)
	#			 __allocating reg $t0
	lw $t0, -8($fp)
	#a Bool Var z3 in boolean operator
	#If true
	bne $t0, $zero,bp_label_50
	#			 __freeing reg $t0
	#If False
	j	bp_label_51
	#marker Label
bp_label_50:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_25
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_52
	#marker Label
bp_label_51:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_27
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_52
	#end of ifelse
bp_label_52:
	#end of statement jump
	j	bp_label_53
	#marker Label
bp_label_53:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn6
	j	bExpAss_nfjdn7
	#			 __freeing reg $t0
bExpAss_nfjdn6:
	#assigning True to z4
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -12($fp)
	j	bp_label_54
bExpAss_nfjdn7:
	#assigning False to z4
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -12($fp)
	j	bp_label_54
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_54
	#marker Label
bp_label_54:
	#Getting Var falue for [Exp->id]: z4 offset is -12($fp)
	#			 __allocating reg $t0
	lw $t0, -12($fp)
	#a Bool Var z4 in boolean operator
	#If true
	bne $t0, $zero,bp_label_55
	#			 __freeing reg $t0
	#If False
	j	bp_label_56
	#marker Label
bp_label_55:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_29
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_57
	#marker Label
bp_label_56:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_31
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_57
	#end of ifelse
bp_label_57:
	#end of statement jump
	j	bp_label_58
	#marker Label
bp_label_58:
	# allocating word on stack for local variable c
	#allocationg words on stack 
	addiu $sp, $sp, -4
	# and initializing it to 0
	sw $zero, -16($fp)
	#end of statement jump
	j	bp_label_59
	#marker Label
bp_label_59:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn8
	j	bExpAss_nfjdn9
	#			 __freeing reg $t0
bExpAss_nfjdn8:
	#assigning True to c
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -16($fp)
	j	bp_label_60
bExpAss_nfjdn9:
	#assigning False to c
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -16($fp)
	j	bp_label_60
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_60
	#marker Label
bp_label_60:
	#Getting Var falue for [Exp->id]: c offset is -16($fp)
	#			 __allocating reg $t0
	lw $t0, -16($fp)
	#a Bool Var c in boolean operator
	#If true
	bne $t0, $zero,bp_label_61
	#			 __freeing reg $t0
	#If False
	j	bp_label_62
	#marker Label
bp_label_61:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_33
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_63
	#marker Label
bp_label_62:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_35
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_63
	#end of ifelse
bp_label_63:
	#end of statement jump
	j	bp_label_64
	#marker Label
bp_label_64:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn10
	j	bExpAss_nfjdn11
	#			 __freeing reg $t0
bExpAss_nfjdn10:
	#assigning True to c
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -16($fp)
	j	bp_label_65
bExpAss_nfjdn11:
	#assigning False to c
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -16($fp)
	j	bp_label_65
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_65
	#marker Label
bp_label_65:
	#Getting Var falue for [Exp->id]: c offset is -16($fp)
	#			 __allocating reg $t0
	lw $t0, -16($fp)
	#a Bool Var c in boolean operator
	#If true
	bne $t0, $zero,bp_label_66
	#			 __freeing reg $t0
	#If False
	j	bp_label_67
	#marker Label
bp_label_66:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_37
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_68
	#marker Label
bp_label_67:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_39
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_68
	#end of ifelse
bp_label_68:
	#end of statement jump
	j	bp_label_69
	#marker Label
bp_label_69:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn12
	j	bExpAss_nfjdn13
	#			 __freeing reg $t0
bExpAss_nfjdn12:
	#assigning True to c
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -16($fp)
	j	bp_label_70
bExpAss_nfjdn13:
	#assigning False to c
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -16($fp)
	j	bp_label_70
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_70
	#marker Label
bp_label_70:
	#Getting Var falue for [Exp->id]: c offset is -16($fp)
	#			 __allocating reg $t0
	lw $t0, -16($fp)
	#a Bool Var c in boolean operator
	#If true
	bne $t0, $zero,bp_label_71
	#			 __freeing reg $t0
	#If False
	j	bp_label_72
	#marker Label
bp_label_71:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_41
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_73
	#marker Label
bp_label_72:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_43
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_73
	#end of ifelse
bp_label_73:
	#end of statement jump
	j	bp_label_74
	#marker Label
bp_label_74:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn14
	j	bExpAss_nfjdn15
	#			 __freeing reg $t0
bExpAss_nfjdn14:
	#assigning True to c
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -16($fp)
	j	bp_label_75
bExpAss_nfjdn15:
	#assigning False to c
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -16($fp)
	j	bp_label_75
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_75
	#marker Label
bp_label_75:
	#Getting Var falue for [Exp->id]: c offset is -16($fp)
	#			 __allocating reg $t0
	lw $t0, -16($fp)
	#a Bool Var c in boolean operator
	#If true
	bne $t0, $zero,bp_label_76
	#			 __freeing reg $t0
	#If False
	j	bp_label_77
	#marker Label
bp_label_76:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_45
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_78
	#marker Label
bp_label_77:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_47
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_78
	#end of ifelse
bp_label_78:
	#end of statement jump
	j	bp_label_79
	#marker Label
bp_label_79:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_80
	#marker Label
bp_label_80:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_81
	#marker Label
bp_label_81:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_49
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_82
	#marker Label
bp_label_82:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_131
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func helperFunc1True
	bne $t0, $zero,bExpAss_nfjdn16
	j	bExpAss_nfjdn17
	#			 __freeing reg $t0
bExpAss_nfjdn16:
	#assigning True to d
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -20($fp)
	j	bp_label_83
bExpAss_nfjdn17:
	#assigning False to d
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -20($fp)
	j	bp_label_83
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_83
	#marker Label
bp_label_83:
	#Getting Var falue for [Exp->id]: d offset is -20($fp)
	#			 __allocating reg $t0
	lw $t0, -20($fp)
	#a Bool Var d in boolean operator
	#If true
	bne $t0, $zero,bp_label_84
	#			 __freeing reg $t0
	#If False
	j	bp_label_85
	#marker Label
bp_label_84:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_51
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_86
	#marker Label
bp_label_85:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_53
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_86
	#end of ifelse
bp_label_86:
	#end of statement jump
	j	bp_label_87
	#marker Label
bp_label_87:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_168
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func helperFunc1False
	bne $t0, $zero,bExpAss_nfjdn18
	j	bExpAss_nfjdn19
	#			 __freeing reg $t0
bExpAss_nfjdn18:
	#assigning True to dd
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -24($fp)
	j	bp_label_88
bExpAss_nfjdn19:
	#assigning False to dd
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -24($fp)
	j	bp_label_88
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_88
	#marker Label
bp_label_88:
	#Getting Var falue for [Exp->id]: dd offset is -24($fp)
	#			 __allocating reg $t0
	lw $t0, -24($fp)
	#a Bool Var dd in boolean operator
	#If true
	bne $t0, $zero,bp_label_89
	#			 __freeing reg $t0
	#If False
	j	bp_label_90
	#marker Label
bp_label_89:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_55
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_91
	#marker Label
bp_label_90:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_57
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_91
	#end of ifelse
bp_label_91:
	#end of statement jump
	j	bp_label_92
	#marker Label
bp_label_92:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_205
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func helperFunc2True
	bne $t0, $zero,bExpAss_nfjdn20
	j	bExpAss_nfjdn21
	#			 __freeing reg $t0
bExpAss_nfjdn20:
	#assigning True to e
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -28($fp)
	j	bp_label_93
bExpAss_nfjdn21:
	#assigning False to e
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -28($fp)
	j	bp_label_93
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_93
	#marker Label
bp_label_93:
	#Getting Var falue for [Exp->id]: e offset is -28($fp)
	#			 __allocating reg $t0
	lw $t0, -28($fp)
	#a Bool Var e in boolean operator
	#If true
	bne $t0, $zero,bp_label_94
	#			 __freeing reg $t0
	#If False
	j	bp_label_95
	#marker Label
bp_label_94:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_59
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_96
	#marker Label
bp_label_95:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_61
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_96
	#end of ifelse
bp_label_96:
	#end of statement jump
	j	bp_label_97
	#marker Label
bp_label_97:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_242
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func helperFunc2False
	bne $t0, $zero,bExpAss_nfjdn22
	j	bExpAss_nfjdn23
	#			 __freeing reg $t0
bExpAss_nfjdn22:
	#assigning True to ff
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -32($fp)
	j	bp_label_98
bExpAss_nfjdn23:
	#assigning False to ff
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -32($fp)
	j	bp_label_98
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_98
	#marker Label
bp_label_98:
	#Getting Var falue for [Exp->id]: ff offset is -32($fp)
	#			 __allocating reg $t0
	lw $t0, -32($fp)
	#a Bool Var ff in boolean operator
	#If true
	bne $t0, $zero,bp_label_99
	#			 __freeing reg $t0
	#If False
	j	bp_label_100
	#marker Label
bp_label_99:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_63
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_101
	#marker Label
bp_label_100:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_65
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_101
	#end of ifelse
bp_label_101:
	#end of statement jump
	j	bp_label_102
	#marker Label
bp_label_102:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_103
	j	bp_label_104
	#			 __freeing reg $t0
	#marker Label
bp_label_103:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_67
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_105
	#marker Label
bp_label_104:
	#end of ifelse
bp_label_105:
	#end of statement jump
	j	bp_label_106
	#marker Label
bp_label_106:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_69
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_107
	#marker Label
bp_label_107:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_109
	j	bp_label_108
	#			 __freeing reg $t0
	#marker Label
bp_label_108:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_71
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_110
	#marker Label
bp_label_109:
	#end of ifelse
bp_label_110:
	#end of statement jump
	j	bp_label_111
	#marker Label
bp_label_111:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_73
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_112
	#marker Label
bp_label_112:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_113
	j	bp_label_114
	#			 __freeing reg $t0
	#marker Label
bp_label_113:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_75
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_115
	#marker Label
bp_label_114:
	#end of ifelse
bp_label_115:
	#end of statement jump
	j	bp_label_116
	#marker Label
bp_label_116:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_77
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_117
	#marker Label
bp_label_117:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_119
	j	bp_label_118
	#			 __freeing reg $t0
	#marker Label
bp_label_118:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_79
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_120
	#marker Label
bp_label_119:
	#end of ifelse
bp_label_120:
	#end of statement jump
	j	bp_label_121
	#marker Label
bp_label_121:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_81
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_122
	#marker Label
bp_label_122:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_123
	#marker Label
bp_label_123:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_125
	#marker Label
bp_label_124:
	#end of ifelse
bp_label_125:
	#end of statement jump
	j	bp_label_126
	#marker Label
bp_label_126:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_83
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_127
	#marker Label
bp_label_127:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_128
	#marker Label
bp_label_128:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_130
	#marker Label
bp_label_129:
	#end of ifelse
bp_label_130:
	#end of statement jump
	j	bp_label_131
	#marker Label
bp_label_131:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_85
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_132
	#marker Label
bp_label_132:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_133
	j	bp_label_134
	#			 __freeing reg $t0
	#marker Label
bp_label_133:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_87
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_135
	#marker Label
bp_label_134:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_89
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_135
	#end of ifelse
bp_label_135:
	#end of statement jump
	j	bp_label_136
	#marker Label
bp_label_136:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_91
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_137
	#marker Label
bp_label_137:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_139
	j	bp_label_138
	#			 __freeing reg $t0
	#marker Label
bp_label_138:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_93
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_140
	#marker Label
bp_label_139:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_95
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_140
	#end of ifelse
bp_label_140:
	#end of statement jump
	j	bp_label_141
	#marker Label
bp_label_141:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_97
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_142
	#marker Label
bp_label_142:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_143
	j	bp_label_144
	#			 __freeing reg $t0
	#marker Label
bp_label_143:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_99
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_145
	#marker Label
bp_label_144:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_101
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_145
	#end of ifelse
bp_label_145:
	#end of statement jump
	j	bp_label_146
	#marker Label
bp_label_146:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_103
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_147
	#marker Label
bp_label_147:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_149
	j	bp_label_148
	#			 __freeing reg $t0
	#marker Label
bp_label_148:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_105
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_150
	#marker Label
bp_label_149:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_107
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_150
	#end of ifelse
bp_label_150:
	#end of statement jump
	j	bp_label_151
	#marker Label
bp_label_151:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_109
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_152
	#marker Label
bp_label_152:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_153
	#marker Label
bp_label_153:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_155
	#marker Label
bp_label_154:
	#end of ifelse
bp_label_155:
	#end of statement jump
	j	bp_label_156
	#marker Label
bp_label_156:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_111
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_157
	#marker Label
bp_label_157:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_158
	#marker Label
bp_label_158:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_160
	#marker Label
bp_label_159:
	#end of ifelse
bp_label_160:
	#end of statement jump
	j	bp_label_161
	#marker Label
bp_label_161:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_113
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_162
	#marker Label
bp_label_162:
	#marker Label
bp_label_163:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_164
	j	bp_label_166
	#			 __freeing reg $t0
	#marker Label
bp_label_164:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_115
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_165
	#marker Label
bp_label_165:
	#break
	j	bp_label_166
	#end of statement jump
	j	bp_label_163
bp_label_166:
	#end of statement jump
	j	bp_label_167
	#marker Label
bp_label_167:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_117
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_168
	#marker Label
bp_label_168:
	#marker Label
bp_label_169:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_172
	j	bp_label_170
	#			 __freeing reg $t0
	#marker Label
bp_label_170:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_119
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_171
	#marker Label
bp_label_171:
	#break
	j	bp_label_172
	#end of statement jump
	j	bp_label_169
bp_label_172:
	#end of statement jump
	j	bp_label_173
	#marker Label
bp_label_173:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_121
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_174
	#marker Label
bp_label_174:
	#marker Label
bp_label_175:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_176
	j	bp_label_178
	#			 __freeing reg $t0
	#marker Label
bp_label_176:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_123
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_177
	#marker Label
bp_label_177:
	#break
	j	bp_label_178
	#end of statement jump
	j	bp_label_175
bp_label_178:
	#end of statement jump
	j	bp_label_179
	#marker Label
bp_label_179:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_125
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_180
	#marker Label
bp_label_180:
	#marker Label
bp_label_181:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_184
	j	bp_label_182
	#			 __freeing reg $t0
	#marker Label
bp_label_182:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_127
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_183
	#marker Label
bp_label_183:
	#break
	j	bp_label_184
	#end of statement jump
	j	bp_label_181
bp_label_184:
	#end of statement jump
	j	bp_label_185
	#marker Label
bp_label_185:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_129
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_186
	#marker Label
bp_label_186:
	#marker Label
bp_label_187:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_188
	#marker Label
bp_label_188:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_189
	#marker Label
bp_label_189:
	#break
	j	bp_label_190
	#end of statement jump
	j	bp_label_187
bp_label_190:
	#end of statement jump
	j	bp_label_191
	#marker Label
bp_label_191:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_131
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_192
	#marker Label
bp_label_192:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t0
	li	$t0,2
	sw $t0, -36($fp)
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_193
	#marker Label
bp_label_193:
	#Getting Var falue for [Exp->id]: u offset is -36($fp)
	#			 __allocating reg $t0
	lw $t0, -36($fp)
	#switch!
	j	bp_label_197
	#			 __freeing reg $t0
	#case init marker
bp_label_194:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_195:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_196
	#marker Label
bp_label_196:
	#break
	j	bp_label_198
	#end of statement jump
	j	bp_label_198
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_198
	#switch init label
bp_label_197:
	beq $t0,2,bp_label_194
	#end of switch:
bp_label_198:
	#end of statement jump
	j	bp_label_199
	#			 __freeing reg $t0
	#marker Label
bp_label_199:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_133
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_200
	#marker Label
bp_label_200:
	#Getting Var falue for [Exp->id]: u offset is -36($fp)
	#			 __allocating reg $t0
	lw $t0, -36($fp)
	#switch!
	j	bp_label_204
	#			 __freeing reg $t0
	#case init marker
bp_label_201:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_202:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_203
	#marker Label
bp_label_203:
	#break
	j	bp_label_205
	#end of statement jump
	j	bp_label_205
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_205
	#switch init label
bp_label_204:
	beq $t0,2,bp_label_201
	#end of switch:
bp_label_205:
	#end of statement jump
	j	bp_label_206
	#			 __freeing reg $t0
	#marker Label
bp_label_206:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_135
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_207
	#marker Label
bp_label_207:
	#Getting Var falue for [Exp->id]: u offset is -36($fp)
	#			 __allocating reg $t0
	lw $t0, -36($fp)
	#switch!
	j	bp_label_211
	#			 __freeing reg $t0
	#case init marker
bp_label_208:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_209:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_210
	#marker Label
bp_label_210:
	#break
	j	bp_label_212
	#end of statement jump
	j	bp_label_212
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_212
	#switch init label
bp_label_211:
	beq $t0,2,bp_label_208
	#end of switch:
bp_label_212:
	#end of statement jump
	j	bp_label_213
	#			 __freeing reg $t0
	#marker Label
bp_label_213:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_137
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_214
	#marker Label
bp_label_214:
	#Getting Var falue for [Exp->id]: u offset is -36($fp)
	#			 __allocating reg $t0
	lw $t0, -36($fp)
	#switch!
	j	bp_label_218
	#			 __freeing reg $t0
	#case init marker
bp_label_215:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_216:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_217
	#marker Label
bp_label_217:
	#break
	j	bp_label_219
	#end of statement jump
	j	bp_label_219
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_219
	#switch init label
bp_label_218:
	beq $t0,2,bp_label_215
	#end of switch:
bp_label_219:
	#end of statement jump
	j	bp_label_220
	#			 __freeing reg $t0
	#marker Label
bp_label_220:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_139
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_221
	#marker Label
bp_label_221:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t0
	li	$t0,2
	sw $t0, -40($fp)
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_222
	#marker Label
bp_label_222:
	#Getting Var falue for [Exp->id]: ub offset is -40($fp)
	#			 __allocating reg $t0
	lw $t0, -40($fp)
	#switch!
	j	bp_label_226
	#			 __freeing reg $t0
	#case init marker
bp_label_223:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_224:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_225
	#marker Label
bp_label_225:
	#break
	j	bp_label_227
	#end of statement jump
	j	bp_label_227
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_227
	#switch init label
bp_label_226:
	beq $t0,2,bp_label_223
	#end of switch:
bp_label_227:
	#end of statement jump
	j	bp_label_228
	#			 __freeing reg $t0
	#marker Label
bp_label_228:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_141
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_229
	#marker Label
bp_label_229:
	#Getting Var falue for [Exp->id]: ub offset is -40($fp)
	#			 __allocating reg $t0
	lw $t0, -40($fp)
	#switch!
	j	bp_label_233
	#			 __freeing reg $t0
	#case init marker
bp_label_230:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_231:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_232
	#marker Label
bp_label_232:
	#break
	j	bp_label_234
	#end of statement jump
	j	bp_label_234
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_234
	#switch init label
bp_label_233:
	beq $t0,2,bp_label_230
	#end of switch:
bp_label_234:
	#end of statement jump
	j	bp_label_235
	#			 __freeing reg $t0
	#marker Label
bp_label_235:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_143
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_236
	#marker Label
bp_label_236:
	#Getting Var falue for [Exp->id]: ub offset is -40($fp)
	#			 __allocating reg $t0
	lw $t0, -40($fp)
	#switch!
	j	bp_label_240
	#			 __freeing reg $t0
	#case init marker
bp_label_237:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_238:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_239
	#marker Label
bp_label_239:
	#break
	j	bp_label_241
	#end of statement jump
	j	bp_label_241
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_241
	#switch init label
bp_label_240:
	beq $t0,2,bp_label_237
	#end of switch:
bp_label_241:
	#end of statement jump
	j	bp_label_242
	#			 __freeing reg $t0
	#marker Label
bp_label_242:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_145
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_243
	#marker Label
bp_label_243:
	#Getting Var falue for [Exp->id]: ub offset is -40($fp)
	#			 __allocating reg $t0
	lw $t0, -40($fp)
	#switch!
	j	bp_label_247
	#			 __freeing reg $t0
	#case init marker
bp_label_244:
	#updating sp by 0 and zeroing them
	#finished sp update
	#marker Label
bp_label_245:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_246
	#marker Label
bp_label_246:
	#break
	j	bp_label_248
	#end of statement jump
	j	bp_label_248
	#			 __allocating reg $t0
	#catching falling cases
	j	bp_label_248
	#switch init label
bp_label_247:
	beq $t0,2,bp_label_244
	#end of switch:
bp_label_248:
	#end of statement jump
	j	bp_label_249
	#			 __freeing reg $t0
	#marker Label
bp_label_249:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_147
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_250
	#marker Label
bp_label_250:
	#func header store regs before call
	#stored 0 registers
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_251
	j	bp_label_253
	#			 __freeing reg $t0
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_251:
	#			 __allocating reg $t0
	li	$t0,1
	j	bp_label_252
	#inserting 0 to param reg if evaluates to false
bp_label_253:
	#			 __allocating reg $t0
	li	$t0,0
bp_label_252:
	#preparing to call funcHelper1
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: funcHelper1
	jal	label_279
	#returned from func: funcHelper1
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling funcHelper1
	#end of statement jump
	j	bp_label_254
	#marker Label
bp_label_254:
	#func header store regs before call
	#stored 0 registers
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_258
	j	bp_label_260
	#			 __freeing reg $t0
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_255
	j	bp_label_257
	#			 __freeing reg $t0
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_255:
	#			 __allocating reg $t0
	li	$t0,1
	j	bp_label_256
	#inserting 0 to param reg if evaluates to false
bp_label_257:
	#			 __allocating reg $t0
	li	$t0,0
bp_label_256:
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_258:
	#			 __allocating reg $t1
	li	$t1,1
	j	bp_label_259
	#inserting 0 to param reg if evaluates to false
bp_label_260:
	#			 __allocating reg $t1
	li	$t1,0
bp_label_259:
	#preparing to call funcHelper2
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t1 to stack
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t1
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: funcHelper2
	jal	label_361
	#returned from func: funcHelper2
	#poping 2 params from stack 
	addiu $sp, $sp, 8
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling funcHelper2
	#end of statement jump
	j	bp_label_261
	#marker Label
bp_label_261:
	#func header store regs before call
	#stored 0 registers
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_262
	j	bp_label_264
	#			 __freeing reg $t0
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_262:
	#			 __allocating reg $t0
	li	$t0,1
	j	bp_label_263
	#inserting 0 to param reg if evaluates to false
bp_label_264:
	#			 __allocating reg $t0
	li	$t0,0
bp_label_263:
	#preparing to call funcHelper1
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: funcHelper1
	jal	label_279
	#returned from func: funcHelper1
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling funcHelper1
	#end of statement jump
	j	bp_label_265
	#marker Label
bp_label_265:
	#func header store regs before call
	#stored 0 registers
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_269
	j	bp_label_271
	#			 __freeing reg $t0
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_266
	j	bp_label_268
	#			 __freeing reg $t0
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_266:
	#			 __allocating reg $t0
	li	$t0,1
	j	bp_label_267
	#inserting 0 to param reg if evaluates to false
bp_label_268:
	#			 __allocating reg $t0
	li	$t0,0
bp_label_267:
	#complicated bool exp as a function parameter
	#inserting 1 to param reg if evaluates to true
bp_label_269:
	#			 __allocating reg $t1
	li	$t1,1
	j	bp_label_270
	#inserting 0 to param reg if evaluates to false
bp_label_271:
	#			 __allocating reg $t1
	li	$t1,0
bp_label_270:
	#preparing to call funcHelper2
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t1 to stack
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t1
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: funcHelper2
	jal	label_361
	#returned from func: funcHelper2
	#poping 2 params from stack 
	addiu $sp, $sp, 8
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling funcHelper2
	#end of statement jump
	j	bp_label_272
	#marker Label
bp_label_272:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn25
	j	bExpAss_nfjdn24
	#			 __freeing reg $t0
bExpAss_nfjdn24:
	#assigning True to bb5
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -44($fp)
	j	bp_label_273
bExpAss_nfjdn25:
	#assigning False to bb5
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -44($fp)
	j	bp_label_273
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_273
	#marker Label
bp_label_273:
	#Getting Var falue for [Exp->id]: bb5 offset is -44($fp)
	#			 __allocating reg $t0
	lw $t0, -44($fp)
	#a Bool Var bb5 in boolean operator
	#If true
	bne $t0, $zero,bp_label_274
	#			 __freeing reg $t0
	#If False
	j	bp_label_275
	#marker Label
bp_label_274:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_149
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_276
	#marker Label
bp_label_275:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_151
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_276
	#end of ifelse
bp_label_276:
	#end of statement jump
	j	bp_label_277
	#marker Label
bp_label_277:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn26
	j	bExpAss_nfjdn27
	#			 __freeing reg $t0
bExpAss_nfjdn26:
	#assigning True to aa5
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -48($fp)
	j	bp_label_278
bExpAss_nfjdn27:
	#assigning False to aa5
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -48($fp)
	j	bp_label_278
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_278
	#marker Label
bp_label_278:
	#Getting Var falue for [Exp->id]: aa5 offset is -48($fp)
	#			 __allocating reg $t0
	lw $t0, -48($fp)
	#a Bool Var aa5 in boolean operator
	#If true
	bne $t0, $zero,bp_label_279
	#			 __freeing reg $t0
	#If False
	j	bp_label_280
	#marker Label
bp_label_279:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_153
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_281
	#marker Label
bp_label_280:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_155
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_281
	#end of ifelse
bp_label_281:
	#end of statement jump
	j	bp_label_282
	#marker Label
bp_label_282:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_283
	j	bExpAss_nfjdn29
	#			 __freeing reg $t0
	#marker Label
bp_label_283:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn28
	j	bExpAss_nfjdn29
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn28:
	#assigning True to bb6
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -52($fp)
	j	bp_label_284
bExpAss_nfjdn29:
	#assigning False to bb6
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -52($fp)
	j	bp_label_284
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_284
	#marker Label
bp_label_284:
	#Getting Var falue for [Exp->id]: bb6 offset is -52($fp)
	#			 __allocating reg $t0
	lw $t0, -52($fp)
	#a Bool Var bb6 in boolean operator
	#If true
	bne $t0, $zero,bp_label_285
	#			 __freeing reg $t0
	#If False
	j	bp_label_286
	#marker Label
bp_label_285:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_157
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_287
	#marker Label
bp_label_286:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_159
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_287
	#end of ifelse
bp_label_287:
	#end of statement jump
	j	bp_label_288
	#marker Label
bp_label_288:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_289
	j	bExpAss_nfjdn30
	#			 __freeing reg $t0
	#marker Label
bp_label_289:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn31
	j	bExpAss_nfjdn30
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn30:
	#assigning True to aa6
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -56($fp)
	j	bp_label_290
bExpAss_nfjdn31:
	#assigning False to aa6
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -56($fp)
	j	bp_label_290
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_290
	#marker Label
bp_label_290:
	#Getting Var falue for [Exp->id]: aa6 offset is -56($fp)
	#			 __allocating reg $t0
	lw $t0, -56($fp)
	#a Bool Var aa6 in boolean operator
	#If true
	bne $t0, $zero,bp_label_291
	#			 __freeing reg $t0
	#If False
	j	bp_label_292
	#marker Label
bp_label_291:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_161
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_293
	#marker Label
bp_label_292:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_163
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_293
	#end of ifelse
bp_label_293:
	#end of statement jump
	j	bp_label_294
	#marker Label
bp_label_294:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn32
	j	bp_label_295
	#			 __freeing reg $t0
	#marker Label
bp_label_295:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn32
	j	bExpAss_nfjdn33
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn32:
	#assigning True to bb7
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -60($fp)
	j	bp_label_296
bExpAss_nfjdn33:
	#assigning False to bb7
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -60($fp)
	j	bp_label_296
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_296
	#marker Label
bp_label_296:
	#Getting Var falue for [Exp->id]: bb7 offset is -60($fp)
	#			 __allocating reg $t0
	lw $t0, -60($fp)
	#a Bool Var bb7 in boolean operator
	#If true
	bne $t0, $zero,bp_label_297
	#			 __freeing reg $t0
	#If False
	j	bp_label_298
	#marker Label
bp_label_297:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_165
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_299
	#marker Label
bp_label_298:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_167
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_299
	#end of ifelse
bp_label_299:
	#end of statement jump
	j	bp_label_300
	#marker Label
bp_label_300:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn35
	j	bp_label_301
	#			 __freeing reg $t0
	#marker Label
bp_label_301:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn35
	j	bExpAss_nfjdn34
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn34:
	#assigning True to aa7
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -64($fp)
	j	bp_label_302
bExpAss_nfjdn35:
	#assigning False to aa7
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -64($fp)
	j	bp_label_302
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_302
	#marker Label
bp_label_302:
	#Getting Var falue for [Exp->id]: aa7 offset is -64($fp)
	#			 __allocating reg $t0
	lw $t0, -64($fp)
	#a Bool Var aa7 in boolean operator
	#If true
	bne $t0, $zero,bp_label_303
	#			 __freeing reg $t0
	#If False
	j	bp_label_304
	#marker Label
bp_label_303:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_169
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_305
	#marker Label
bp_label_304:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_171
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_305
	#end of ifelse
bp_label_305:
	#end of statement jump
	j	bp_label_306
	#marker Label
bp_label_306:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn37
	j	bExpAss_nfjdn36
	#			 __freeing reg $t0
bExpAss_nfjdn36:
	#assigning True to bb8
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -68($fp)
	j	bp_label_307
bExpAss_nfjdn37:
	#assigning False to bb8
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -68($fp)
	j	bp_label_307
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_307
	#marker Label
bp_label_307:
	#Getting Var falue for [Exp->id]: bb8 offset is -68($fp)
	#			 __allocating reg $t0
	lw $t0, -68($fp)
	#a Bool Var bb8 in boolean operator
	#If true
	bne $t0, $zero,bp_label_308
	#			 __freeing reg $t0
	#If False
	j	bp_label_309
	#marker Label
bp_label_308:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_173
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_310
	#marker Label
bp_label_309:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_175
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_310
	#end of ifelse
bp_label_310:
	#end of statement jump
	j	bp_label_311
	#marker Label
bp_label_311:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn38
	j	bExpAss_nfjdn39
	#			 __freeing reg $t0
bExpAss_nfjdn38:
	#assigning True to aa8
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -72($fp)
	j	bp_label_312
bExpAss_nfjdn39:
	#assigning False to aa8
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -72($fp)
	j	bp_label_312
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_312
	#marker Label
bp_label_312:
	#Getting Var falue for [Exp->id]: aa8 offset is -72($fp)
	#			 __allocating reg $t0
	lw $t0, -72($fp)
	#a Bool Var aa8 in boolean operator
	#If true
	bne $t0, $zero,bp_label_313
	#			 __freeing reg $t0
	#If False
	j	bp_label_314
	#marker Label
bp_label_313:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_177
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_315
	#marker Label
bp_label_314:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_179
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_315
	#end of ifelse
bp_label_315:
	#end of statement jump
	j	bp_label_316
	#marker Label
bp_label_316:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_317
	j	bExpAss_nfjdn41
	#			 __freeing reg $t0
	#marker Label
bp_label_317:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn40
	j	bExpAss_nfjdn41
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn40:
	#assigning True to bb9
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -76($fp)
	j	bp_label_318
bExpAss_nfjdn41:
	#assigning False to bb9
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -76($fp)
	j	bp_label_318
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_318
	#marker Label
bp_label_318:
	#Getting Var falue for [Exp->id]: bb9 offset is -76($fp)
	#			 __allocating reg $t0
	lw $t0, -76($fp)
	#a Bool Var bb9 in boolean operator
	#If true
	bne $t0, $zero,bp_label_319
	#			 __freeing reg $t0
	#If False
	j	bp_label_320
	#marker Label
bp_label_319:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_181
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_321
	#marker Label
bp_label_320:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_183
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_321
	#end of ifelse
bp_label_321:
	#end of statement jump
	j	bp_label_322
	#marker Label
bp_label_322:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_323
	j	bExpAss_nfjdn42
	#			 __freeing reg $t0
	#marker Label
bp_label_323:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn43
	j	bExpAss_nfjdn42
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn42:
	#assigning True to aa9
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -80($fp)
	j	bp_label_324
bExpAss_nfjdn43:
	#assigning False to aa9
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -80($fp)
	j	bp_label_324
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_324
	#marker Label
bp_label_324:
	#Getting Var falue for [Exp->id]: aa9 offset is -80($fp)
	#			 __allocating reg $t0
	lw $t0, -80($fp)
	#a Bool Var aa9 in boolean operator
	#If true
	bne $t0, $zero,bp_label_325
	#			 __freeing reg $t0
	#If False
	j	bp_label_326
	#marker Label
bp_label_325:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_185
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_327
	#marker Label
bp_label_326:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_187
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_327
	#end of ifelse
bp_label_327:
	#end of statement jump
	j	bp_label_328
	#marker Label
bp_label_328:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn44
	j	bp_label_329
	#			 __freeing reg $t0
	#marker Label
bp_label_329:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn44
	j	bExpAss_nfjdn45
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn44:
	#assigning True to bb10
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -84($fp)
	j	bp_label_330
bExpAss_nfjdn45:
	#assigning False to bb10
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -84($fp)
	j	bp_label_330
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_330
	#marker Label
bp_label_330:
	#Getting Var falue for [Exp->id]: bb10 offset is -84($fp)
	#			 __allocating reg $t0
	lw $t0, -84($fp)
	#a Bool Var bb10 in boolean operator
	#If true
	bne $t0, $zero,bp_label_331
	#			 __freeing reg $t0
	#If False
	j	bp_label_332
	#marker Label
bp_label_331:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_189
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_333
	#marker Label
bp_label_332:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_191
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_333
	#end of ifelse
bp_label_333:
	#end of statement jump
	j	bp_label_334
	#marker Label
bp_label_334:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn47
	j	bp_label_335
	#			 __freeing reg $t0
	#marker Label
bp_label_335:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn47
	j	bExpAss_nfjdn46
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn46:
	#assigning True to aa10
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -88($fp)
	j	bp_label_336
bExpAss_nfjdn47:
	#assigning False to aa10
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -88($fp)
	j	bp_label_336
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_336
	#marker Label
bp_label_336:
	#Getting Var falue for [Exp->id]: aa10 offset is -88($fp)
	#			 __allocating reg $t0
	lw $t0, -88($fp)
	#a Bool Var aa10 in boolean operator
	#If true
	bne $t0, $zero,bp_label_337
	#			 __freeing reg $t0
	#If False
	j	bp_label_338
	#marker Label
bp_label_337:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_193
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_339
	#marker Label
bp_label_338:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_195
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_339
	#end of ifelse
bp_label_339:
	#end of statement jump
	j	bp_label_340
	#marker Label
bp_label_340:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_341
	j	bExpAss_nfjdn49
	#			 __freeing reg $t0
	#marker Label
bp_label_341:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn48
	j	bExpAss_nfjdn49
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn48:
	#assigning True to bb11
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -92($fp)
	j	bp_label_342
bExpAss_nfjdn49:
	#assigning False to bb11
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -92($fp)
	j	bp_label_342
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_342
	#marker Label
bp_label_342:
	#Getting Var falue for [Exp->id]: bb11 offset is -92($fp)
	#			 __allocating reg $t0
	lw $t0, -92($fp)
	#a Bool Var bb11 in boolean operator
	#If true
	bne $t0, $zero,bp_label_343
	#			 __freeing reg $t0
	#If False
	j	bp_label_344
	#marker Label
bp_label_343:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_197
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_345
	#marker Label
bp_label_344:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_199
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_345
	#end of ifelse
bp_label_345:
	#end of statement jump
	j	bp_label_346
	#marker Label
bp_label_346:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bp_label_347
	j	bExpAss_nfjdn50
	#			 __freeing reg $t0
	#marker Label
bp_label_347:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn51
	j	bExpAss_nfjdn50
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn50:
	#assigning True to aa11
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -96($fp)
	j	bp_label_348
bExpAss_nfjdn51:
	#assigning False to aa11
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -96($fp)
	j	bp_label_348
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_348
	#marker Label
bp_label_348:
	#Getting Var falue for [Exp->id]: aa11 offset is -96($fp)
	#			 __allocating reg $t0
	lw $t0, -96($fp)
	#a Bool Var aa11 in boolean operator
	#If true
	bne $t0, $zero,bp_label_349
	#			 __freeing reg $t0
	#If False
	j	bp_label_350
	#marker Label
bp_label_349:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_201
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_351
	#marker Label
bp_label_350:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_203
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_351
	#end of ifelse
bp_label_351:
	#end of statement jump
	j	bp_label_352
	#marker Label
bp_label_352:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn52
	j	bp_label_353
	#			 __freeing reg $t0
	#marker Label
bp_label_353:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn52
	j	bExpAss_nfjdn53
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn52:
	#assigning True to bb12
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -100($fp)
	j	bp_label_354
bExpAss_nfjdn53:
	#assigning False to bb12
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -100($fp)
	j	bp_label_354
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_354
	#marker Label
bp_label_354:
	#Getting Var falue for [Exp->id]: bb12 offset is -100($fp)
	#			 __allocating reg $t0
	lw $t0, -100($fp)
	#a Bool Var bb12 in boolean operator
	#If true
	bne $t0, $zero,bp_label_355
	#			 __freeing reg $t0
	#If False
	j	bp_label_356
	#marker Label
bp_label_355:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_205
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_357
	#marker Label
bp_label_356:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_207
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_357
	#end of ifelse
bp_label_357:
	#end of statement jump
	j	bp_label_358
	#marker Label
bp_label_358:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn55
	j	bp_label_359
	#			 __freeing reg $t0
	#marker Label
bp_label_359:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn55
	j	bExpAss_nfjdn54
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn54:
	#assigning True to aa12
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -104($fp)
	j	bp_label_360
bExpAss_nfjdn55:
	#assigning False to aa12
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -104($fp)
	j	bp_label_360
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_360
	#marker Label
bp_label_360:
	#Getting Var falue for [Exp->id]: aa12 offset is -104($fp)
	#			 __allocating reg $t0
	lw $t0, -104($fp)
	#a Bool Var aa12 in boolean operator
	#If true
	bne $t0, $zero,bp_label_361
	#			 __freeing reg $t0
	#If False
	j	bp_label_362
	#marker Label
bp_label_361:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_209
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_363
	#marker Label
bp_label_362:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_211
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_363
	#end of ifelse
bp_label_363:
	#end of statement jump
	j	bp_label_364
	#marker Label
bp_label_364:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_365
	j	bExpAss_nfjdn57
	#			 __freeing reg $t0
	#marker Label
bp_label_365:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn56
	j	bExpAss_nfjdn57
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn56:
	#assigning True to bb13
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -108($fp)
	j	bp_label_366
bExpAss_nfjdn57:
	#assigning False to bb13
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -108($fp)
	j	bp_label_366
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_366
	#marker Label
bp_label_366:
	#Getting Var falue for [Exp->id]: bb13 offset is -108($fp)
	#			 __allocating reg $t0
	lw $t0, -108($fp)
	#a Bool Var bb13 in boolean operator
	#If true
	bne $t0, $zero,bp_label_367
	#			 __freeing reg $t0
	#If False
	j	bp_label_368
	#marker Label
bp_label_367:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_213
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_369
	#marker Label
bp_label_368:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_215
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_369
	#end of ifelse
bp_label_369:
	#end of statement jump
	j	bp_label_370
	#marker Label
bp_label_370:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bp_label_371
	j	bExpAss_nfjdn58
	#			 __freeing reg $t0
	#marker Label
bp_label_371:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn59
	j	bExpAss_nfjdn58
	#			 __freeing reg $t0
	#reach And derivation
bExpAss_nfjdn58:
	#assigning True to aa13
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -112($fp)
	j	bp_label_372
bExpAss_nfjdn59:
	#assigning False to aa13
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -112($fp)
	j	bp_label_372
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_372
	#marker Label
bp_label_372:
	#Getting Var falue for [Exp->id]: aa13 offset is -112($fp)
	#			 __allocating reg $t0
	lw $t0, -112($fp)
	#a Bool Var aa13 in boolean operator
	#If true
	bne $t0, $zero,bp_label_373
	#			 __freeing reg $t0
	#If False
	j	bp_label_374
	#marker Label
bp_label_373:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_217
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_375
	#marker Label
bp_label_374:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_219
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_375
	#end of ifelse
bp_label_375:
	#end of statement jump
	j	bp_label_376
	#marker Label
bp_label_376:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn60
	j	bp_label_377
	#			 __freeing reg $t0
	#marker Label
bp_label_377:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn60
	j	bExpAss_nfjdn61
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn60:
	#assigning True to bb14
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -116($fp)
	j	bp_label_378
bExpAss_nfjdn61:
	#assigning False to bb14
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -116($fp)
	j	bp_label_378
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_378
	#marker Label
bp_label_378:
	#Getting Var falue for [Exp->id]: bb14 offset is -116($fp)
	#			 __allocating reg $t0
	lw $t0, -116($fp)
	#a Bool Var bb14 in boolean operator
	#If true
	bne $t0, $zero,bp_label_379
	#			 __freeing reg $t0
	#If False
	j	bp_label_380
	#marker Label
bp_label_379:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_221
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_381
	#marker Label
bp_label_380:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_223
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_381
	#end of ifelse
bp_label_381:
	#end of statement jump
	j	bp_label_382
	#marker Label
bp_label_382:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_80
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteFalse
	bne $t0, $zero,bExpAss_nfjdn63
	j	bp_label_383
	#			 __freeing reg $t0
	#marker Label
bp_label_383:
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_29
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func funcByteTrue
	bne $t0, $zero,bExpAss_nfjdn63
	j	bExpAss_nfjdn62
	#			 __freeing reg $t0
	#reach Or derivation
bExpAss_nfjdn62:
	#assigning True to aa14
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -120($fp)
	j	bp_label_384
bExpAss_nfjdn63:
	#assigning False to aa14
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -120($fp)
	j	bp_label_384
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_384
	#marker Label
bp_label_384:
	#Getting Var falue for [Exp->id]: aa14 offset is -120($fp)
	#			 __allocating reg $t0
	lw $t0, -120($fp)
	#a Bool Var aa14 in boolean operator
	#If true
	bne $t0, $zero,bp_label_385
	#			 __freeing reg $t0
	#If False
	j	bp_label_386
	#marker Label
bp_label_385:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_225
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_387
	#marker Label
bp_label_386:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_227
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_387
	#end of ifelse
bp_label_387:
	#end of statement jump
	j	bp_label_388
bp_label_388:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
