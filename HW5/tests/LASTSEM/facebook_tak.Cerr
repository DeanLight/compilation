[FIRST_PROGRAM_POINT]
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token int__
Lex Ate token  id__ex__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__x__
<<FormalDecl_Semantic: id[x]>>
Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__y__
<<FormalDecl_Semantic: id[y]>>
Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__z__
<<FormalDecl_Semantic: id[z]>>
Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[ex]>>
FuncHead_IR for func: ex
got label label_29 in line: -1
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__y__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[y]>>
[Exp_IR] Exp -> id: y
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects y
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_0
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__x__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
Lex Ate token  num__1__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
Lex Ate token  id__y__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[y]>>
[Exp_IR] Exp -> id: y
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__z__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[z]>>
[Exp_IR] Exp -> id: z
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : z
exp is of type INT
[ExpList_IR: ExpList->Exp]: z
[ExpList_IR: ExpList->Exp]: y
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token  ,__
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__y__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[y]>>
[Exp_IR] Exp -> id: y
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects y
Lex Ate token  num__1__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
Lex Ate token  id__z__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[z]>>
[Exp_IR] Exp -> id: z
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : x
exp is of type INT
[ExpList_IR: ExpList->Exp]: x
[ExpList_IR: ExpList->Exp]: z
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 1
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token  ,__
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__z__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[z]>>
[Exp_IR] Exp -> id: z
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects z
Lex Ate token  num__1__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
Lex Ate token  id__x__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__y__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[y]>>
[Exp_IR] Exp -> id: y
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : y
exp is of type INT
[ExpList_IR: ExpList->Exp]: y
[ExpList_IR: ExpList->Exp]: x
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : ex
exp is of type INT
[ExpList_IR: ExpList->Exp]: ex
[ExpList_IR: ExpList->Exp]: ex
[ExpList_IR: ExpList->Exp]: ex
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
not a bool var so no SJ_exp after effects ex
Lex Ate token  ;__
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[MARKER IR]: label: bp_label_1
Lex Ate token else__
Lex Ate token return__
Lex Ate token  id__z__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[z]>>
[Exp_IR] Exp -> id: z
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects z
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: ex
for an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__f__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[f]>>
FuncHead_IR for func: f
got label label_267 in line: -1
written label: label_267
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  id__a__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  num__2__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: f
for an extra ret will be added
Ret type: 3
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
FuncHead_IR for func: main
got label label_290 in line: -1
written label: label_290
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__14__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:14
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__13__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:13
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__12__
Lex Ate token )__
[Exp_IR] Exp -> Num:12
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : ex
exp is of type INT
[ExpList_IR: ExpList->Exp]: ex
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_5
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_5 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_6
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__18__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:18
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__12__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:12
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__6__
Lex Ate token )__
[Exp_IR] Exp -> Num:6
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : ex
exp is of type INT
[ExpList_IR: ExpList->Exp]: ex
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_6 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_7
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_7 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_8
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__ex__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__19__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:19
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__15__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:15
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__10__
Lex Ate token )__
[Exp_IR] Exp -> Num:10
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 3
tmpActP: 3
tmptmp: 1
[Call_IR] : with arguments ex
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callex
[Exp_IR] endof Exp->callex
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : ex
exp is of type INT
[ExpList_IR: ExpList->Exp]: ex
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_8 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_9
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_9 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
for an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with label_290
[END_OF Program_IR]



 == printing data === 



pvufne1:	.asciiz "Error division by zero
"
string_label_0:	.asciiz "\n"
string_label_1:	.asciiz "\n"
string_label_2:	.asciiz "\n"
string_label_3:	.asciiz "\n"
string_label_4:	.asciiz "\n"
string_label_5:	.asciiz "\n"



 == printing code === 



	#first program point
main:
	#initialize fp
	move	$fp,$sp
	jal	label_290
	#exiting...
li $v0, 10
syscall
	#print_func:
print:
lw $a0,4($sp)
li $v0,4
syscall
jr $ra
	#printi func:
printi:
lw $a0,4($sp)
li $v0,1
syscall
jr $ra
	#div by 0 handler:
nayalo:
	li	$v0, 4
	la	$a0, pvufne1
	syscall
	#exiting...
li $v0, 10
syscall
	#Func ex:
label_29:
	#Getting Var falue for [Exp->id]: y offset is 8($fp)
	#			 __allocating reg $t0
	lw $t0, 8($fp)
	#Getting Var falue for [Exp->id]: x offset is 4($fp)
	#			 __allocating reg $t1
	lw $t1, 4($fp)
	blt $t0, $t1,bp_label_0
	#			 __freeing reg $t1
	#			 __freeing reg $t0
	j	bp_label_1
	#marker Label
bp_label_0:
	#func header store regs before call
	#stored 0 registers
	#func header store regs before call
	#stored 0 registers
	#Getting Var falue for [Exp->id]: x offset is 4($fp)
	#			 __allocating reg $t0
	lw $t0, 4($fp)
	#			 __allocating reg $t1
	li	$t1,1
	#subtruct
	subu	$t0,$t0,$t1
	#			 __freeing reg $t1
	#Getting Var falue for [Exp->id]: y offset is 8($fp)
	#			 __allocating reg $t1
	lw $t1, 8($fp)
	#Getting Var falue for [Exp->id]: z offset is 12($fp)
	#			 __allocating reg $t2
	lw $t2, 12($fp)
	#preparing to call ex
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t2 to stack
	sw $t2, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t2
	#pushing reg $t1 to stack
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t1
	#pushing reg $t0 to stack
