[FIRST_PROGRAM_POINT]
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__printBool__
Lex Ate token  (__
Lex Ate token bool__
Lex Ate token  id__c__
<<FormalDecl_Semantic: id[c]>>
Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[printBool]>>
FuncHead_IR for func: printBool
got label label_29 in line: -1
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: c
[MARKER IR]: label: bp_label_0
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"true\n"__
[Exp_IR] Exp -> string"true\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_1
Lex Ate token else__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"false\n"__
[Exp_IR] Exp -> string"false\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: printBool
for an extra ret will be added
Ret type: 1
Lex Ate token bool__
Lex Ate token  id__True__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[True]>>
FuncHead_IR for func: True
got label label_111 in line: -1
written label: label_111
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: True
for an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__False__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[False]>>
FuncHead_IR for func: False
got label label_132 in line: -1
written label: label_132
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: False
for an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
FuncHead_IR for func: main
got label label_153 in line: -1
written label: label_153
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token bool__
Lex Ate token  id__t__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[t]type:[]>>
<<Statement_Semantic with id[t]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States->SignleState]  nextlistSize=3
Lex Ate token bool__
[MARKER IR]: label: bp_label_12
Lex Ate token  id__f__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[f]type:[]>>
<<Statement_Semantic with id[f]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_12 breaklist size is 0
Lex Ate comment://simple true

Lex Ate token bool__
[MARKER IR]: label: bp_label_13
Lex Ate token  id__b2__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=0
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[b2]type:[]>>
<<Statement_Semantic with id[b2]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_13 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_14
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__b2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b2]>>
[Exp_IR] Exp -> id: b2
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b2
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b2
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_14 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_15
Lex Ate token  id__b3__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[b3]type:[]>>
<<Statement_Semantic with id[b3]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_15 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_16
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__b3__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b3]>>
[Exp_IR] Exp -> id: b3
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b3
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b3
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_16 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_17
Lex Ate token  id__b4__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
<<[Statement_Semantic][TypeID_SC] id:[b4]type:[]>>
<<Statement_Semantic with id[b4]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_17 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_18
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__b4__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b4]>>
[Exp_IR] Exp -> id: b4
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b4
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b4
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_18 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_19
Lex Ate token  id__b5__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
<<[Statement_Semantic][TypeID_SC] id:[b5]type:[]>>
<<Statement_Semantic with id[b5]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_19 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_20
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__b5__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b5]>>
[Exp_IR] Exp -> id: b5
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b5
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b5
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_20 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_21
Lex Ate token  id__b6__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
<<[Statement_Semantic][TypeID_SC] id:[b6]type:[]>>
<<Statement_Semantic with id[b6]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_21 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_22
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__b6__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b6]>>
[Exp_IR] Exp -> id: b6
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b6
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b6
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_22 breaklist size is 0
Lex Ate comment://simple false

Lex Ate token bool__
[MARKER IR]: label: bp_label_23
Lex Ate token  id__b7__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=1
[Emitter] REstore_registers: 1
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[b7]type:[]>>
<<Statement_Semantic with id[b7]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_23 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_24
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__b7__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b7]>>
[Exp_IR] Exp -> id: b7
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b7
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b7
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_24 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_25
Lex Ate token  id__b8__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[b8]type:[]>>
<<Statement_Semantic with id[b8]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_25 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_26
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__b8__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b8]>>
[Exp_IR] Exp -> id: b8
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b8
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b8
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_26 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_27
Lex Ate token  id__b9__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
<<[Statement_Semantic][TypeID_SC] id:[b9]type:[]>>
<<Statement_Semantic with id[b9]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_27 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_28
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b9__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b9]>>
[Exp_IR] Exp -> id: b9
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b9
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b9
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_28 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_29
Lex Ate token  id__b10__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
<<[Statement_Semantic][TypeID_SC] id:[b10]type:[]>>
<<Statement_Semantic with id[b10]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_29 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_30
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b10__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b10]>>
[Exp_IR] Exp -> id: b10
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b10
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b10
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_30 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_31
Lex Ate token  id__b11__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
<<[Statement_Semantic][TypeID_SC] id:[b11]type:[]>>
<<Statement_Semantic with id[b11]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_31 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_32
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b11__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b11]>>
[Exp_IR] Exp -> id: b11
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b11
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b11
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_32 breaklist size is 0
Lex Ate comment://mix it up

Lex Ate token bool__
[MARKER IR]: label: bp_label_33
Lex Ate token  id__b12__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_34
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b12]type:[]>>
<<Statement_Semantic with id[b12]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_33 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_35
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b12__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b12]>>
[Exp_IR] Exp -> id: b12
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b12
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b12
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_35 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_36
Lex Ate token  id__b13__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_37
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b13]type:[]>>
<<Statement_Semantic with id[b13]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_36 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_38
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b13__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b13]>>
[Exp_IR] Exp -> id: b13
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b13
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b13
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_38 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_39
Lex Ate token  id__b14__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_40
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b14]type:[]>>
<<Statement_Semantic with id[b14]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_39 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_41
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b14__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b14]>>
[Exp_IR] Exp -> id: b14
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b14
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b14
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_41 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_42
Lex Ate token  id__b15__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_43
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b15]type:[]>>
<<Statement_Semantic with id[b15]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_42 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_44
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b15__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b15]>>
[Exp_IR] Exp -> id: b15
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b15
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b15
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_44 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_45
Lex Ate token  id__b16__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_46
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b16]type:[]>>
<<Statement_Semantic with id[b16]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_45 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_47
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b16__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b16]>>
[Exp_IR] Exp -> id: b16
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b16
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b16
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_47 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_48
Lex Ate token  id__b17__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_49
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:False falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b17]type:[]>>
<<Statement_Semantic with id[b17]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_48 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_50
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b17__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b17]>>
[Exp_IR] Exp -> id: b17
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b17
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b17
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_50 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_51
Lex Ate token  id__b18__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_52
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:false falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b18]type:[]>>
<<Statement_Semantic with id[b18]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_51 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_53
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b18__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b18]>>
[Exp_IR] Exp -> id: b18
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b18
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b18
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_53 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_54
Lex Ate token  id__b19__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_55
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:f falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b19]type:[]>>
<<Statement_Semantic with id[b19]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_54 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_56
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b19__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b19]>>
[Exp_IR] Exp -> id: b19
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b19
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b19
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_56 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_57
Lex Ate token  id__b20__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_58
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b20]type:[]>>
<<Statement_Semantic with id[b20]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_57 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_59
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b20__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b20]>>
[Exp_IR] Exp -> id: b20
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b20
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b20
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_59 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_60
Lex Ate token  id__b21__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_61
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b21]type:[]>>
<<Statement_Semantic with id[b21]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_60 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_62
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b21__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b21]>>
[Exp_IR] Exp -> id: b21
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b21
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b21
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_62 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_63
Lex Ate token  id__b22__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_64
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b22]type:[]>>
<<Statement_Semantic with id[b22]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_63 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_65
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b22__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b22]>>
[Exp_IR] Exp -> id: b22
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b22
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b22
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_65 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_66
Lex Ate token  id__b23__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_67
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b23]type:[]>>
<<Statement_Semantic with id[b23]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_66 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_68
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b23__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b23]>>
[Exp_IR] Exp -> id: b23
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b23
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b23
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_68 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_69
Lex Ate token  id__b24__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_70
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b24]type:[]>>
<<Statement_Semantic with id[b24]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_69 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_71
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b24__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b24]>>
[Exp_IR] Exp -> id: b24
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b24
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b24
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_71 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_72
Lex Ate token  id__b25__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_73
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b25]type:[]>>
<<Statement_Semantic with id[b25]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_72 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_74
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b25__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b25]>>
[Exp_IR] Exp -> id: b25
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b25
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b25
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_74 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_75
Lex Ate token  id__b26__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_76
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b26]type:[]>>
<<Statement_Semantic with id[b26]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_75 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_77
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b26__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b26]>>
[Exp_IR] Exp -> id: b26
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b26
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b26
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_77 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_78
Lex Ate token  id__b27__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_79
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b27]type:[]>>
<<Statement_Semantic with id[b27]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_78 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_80
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b27__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b27]>>
[Exp_IR] Exp -> id: b27
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b27
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b27
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_80 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_81
Lex Ate token  id__b28__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_82
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b28]type:[]>>
<<Statement_Semantic with id[b28]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_81 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_83
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b28__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b28]>>
[Exp_IR] Exp -> id: b28
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b28
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b28
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_83 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_84
Lex Ate token  id__b29__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_85
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b29]type:[]>>
<<Statement_Semantic with id[b29]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_84 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_86
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b29__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b29]>>
[Exp_IR] Exp -> id: b29
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b29
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b29
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_86 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_87
Lex Ate token  id__b30__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_88
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b30]type:[]>>
<<Statement_Semantic with id[b30]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_87 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_89
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b30__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b30]>>
[Exp_IR] Exp -> id: b30
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b30
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b30
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_89 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_90
Lex Ate token  id__b31__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_91
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b31]type:[]>>
<<Statement_Semantic with id[b31]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_90 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_92
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b31__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b31]>>
[Exp_IR] Exp -> id: b31
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b31
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b31
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_92 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_93
Lex Ate token  id__b32__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_94
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b32]type:[]>>
<<Statement_Semantic with id[b32]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_93 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_95
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b32__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b32]>>
[Exp_IR] Exp -> id: b32
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b32
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b32
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_95 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_96
Lex Ate token  id__b33__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_97
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b33]type:[]>>
<<Statement_Semantic with id[b33]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_96 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_98
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b33__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b33]>>
[Exp_IR] Exp -> id: b33
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b33
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b33
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_98 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_99
Lex Ate token  id__b34__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_100
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b34]type:[]>>
<<Statement_Semantic with id[b34]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_99 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_101
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b34__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b34]>>
[Exp_IR] Exp -> id: b34
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b34
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b34
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_101 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_102
Lex Ate token  id__b35__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_103
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b35]type:[]>>
<<Statement_Semantic with id[b35]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_102 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_104
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b35__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b35]>>
[Exp_IR] Exp -> id: b35
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b35
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b35
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_104 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_105
Lex Ate token  id__b36__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_106
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b36]type:[]>>
<<Statement_Semantic with id[b36]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_105 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_107
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b36__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b36]>>
[Exp_IR] Exp -> id: b36
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b36
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b36
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_107 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_108
Lex Ate token  id__b37__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_109
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b37]type:[]>>
<<Statement_Semantic with id[b37]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_108 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_110
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b37__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b37]>>
[Exp_IR] Exp -> id: b37
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b37
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b37
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_110 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_111
Lex Ate token  id__b38__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_112
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b38]type:[]>>
<<Statement_Semantic with id[b38]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_111 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_113
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b38__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b38]>>
[Exp_IR] Exp -> id: b38
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b38
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b38
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_113 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_114
Lex Ate token  id__b39__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_115
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b39]type:[]>>
<<Statement_Semantic with id[b39]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_114 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_116
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b39__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b39]>>
[Exp_IR] Exp -> id: b39
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b39
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b39
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_116 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_117
Lex Ate token  id__b40__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_118
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b40]type:[]>>
<<Statement_Semantic with id[b40]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_117 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_119
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b40__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b40]>>
[Exp_IR] Exp -> id: b40
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b40
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b40
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_119 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_120
Lex Ate token  id__b41__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token and__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_121
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:True falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b41]type:[]>>
<<Statement_Semantic with id[b41]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_120 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_122
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b41__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b41]>>
[Exp_IR] Exp -> id: b41
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b41
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b41
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_122 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_123
Lex Ate token  id__b42__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_124
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:False falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b42]type:[]>>
<<Statement_Semantic with id[b42]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_123 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_125
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b42__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b42]>>
[Exp_IR] Exp -> id: b42
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b42
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b42
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_125 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_126
Lex Ate token  id__b43__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_127
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:false falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b43]type:[]>>
<<Statement_Semantic with id[b43]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_126 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_128
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b43__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b43]>>
[Exp_IR] Exp -> id: b43
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b43
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b43
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_128 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_129
Lex Ate token  id__b44__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_130
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:f falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b44]type:[]>>
<<Statement_Semantic with id[b44]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_129 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_131
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b44__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b44]>>
[Exp_IR] Exp -> id: b44
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b44
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b44
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_131 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_132
Lex Ate token  id__b45__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_133
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b45]type:[]>>
<<Statement_Semantic with id[b45]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_132 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_134
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b45__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b45]>>
[Exp_IR] Exp -> id: b45
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b45
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b45
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_134 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_135
Lex Ate token  id__b46__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_136
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2: falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b46]type:[]>>
<<Statement_Semantic with id[b46]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_135 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_137
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b46__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b46]>>
[Exp_IR] Exp -> id: b46
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b46
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b46
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_137 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_138
Lex Ate token  id__b47__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_139
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b47]type:[]>>
<<Statement_Semantic with id[b47]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_138 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_140
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b47__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b47]>>
[Exp_IR] Exp -> id: b47
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b47
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b47
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_140 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_141
Lex Ate token  id__b48__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_142
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b48]type:[]>>
<<Statement_Semantic with id[b48]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_141 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_143
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b48__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b48]>>
[Exp_IR] Exp -> id: b48
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b48
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b48
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_143 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_144
Lex Ate token  id__b49__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_145
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b49]type:[]>>
<<Statement_Semantic with id[b49]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_144 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_146
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b49__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b49]>>
[Exp_IR] Exp -> id: b49
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b49
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b49
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_146 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_147
Lex Ate token  id__b50__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_148
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b50]type:[]>>
<<Statement_Semantic with id[b50]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_147 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_149
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b50__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b50]>>
[Exp_IR] Exp -> id: b50
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b50
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b50
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_149 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_150
Lex Ate token  id__b51__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_151
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:t falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b51]type:[]>>
<<Statement_Semantic with id[b51]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_150 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_152
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b51__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b51]>>
[Exp_IR] Exp -> id: b51
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b51
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b51
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_152 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_153
Lex Ate token  id__b52__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_154
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b52]type:[]>>
<<Statement_Semantic with id[b52]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_153 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_155
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b52__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b52]>>
[Exp_IR] Exp -> id: b52
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b52
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b52
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_155 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_156
Lex Ate token  id__b53__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_157
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b53]type:[]>>
<<Statement_Semantic with id[b53]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_156 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_158
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b53__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b53]>>
[Exp_IR] Exp -> id: b53
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b53
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b53
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_158 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_159
Lex Ate token  id__b54__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_160
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b54]type:[]>>
<<Statement_Semantic with id[b54]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_159 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_161
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b54__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b54]>>
[Exp_IR] Exp -> id: b54
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b54
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b54
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_161 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_162
Lex Ate token  id__b55__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_163
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b55]type:[]>>
<<Statement_Semantic with id[b55]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_162 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_164
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b55__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b55]>>
[Exp_IR] Exp -> id: b55
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b55
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b55
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_164 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_165
Lex Ate token  id__b56__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_166
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b56]type:[]>>
<<Statement_Semantic with id[b56]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_165 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_167
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b56__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b56]>>
[Exp_IR] Exp -> id: b56
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b56
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b56
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_167 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_168
Lex Ate token  id__b57__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_169
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b57]type:[]>>
<<Statement_Semantic with id[b57]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_168 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_170
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b57__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b57]>>
[Exp_IR] Exp -> id: b57
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b57
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b57
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_170 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_171
Lex Ate token  id__b58__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_172
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b58]type:[]>>
<<Statement_Semantic with id[b58]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_171 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_173
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b58__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b58]>>
[Exp_IR] Exp -> id: b58
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b58
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b58
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_173 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_174
Lex Ate token  id__b59__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_175
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b59]type:[]>>
<<Statement_Semantic with id[b59]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_174 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_176
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b59__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b59]>>
[Exp_IR] Exp -> id: b59
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b59
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b59
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_176 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_177
Lex Ate token  id__b60__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_178
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b60]type:[]>>
<<Statement_Semantic with id[b60]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_177 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_179
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b60__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b60]>>
[Exp_IR] Exp -> id: b60
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b60
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b60
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_179 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_180
Lex Ate token  id__b61__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_181
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b61]type:[]>>
<<Statement_Semantic with id[b61]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_180 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_182
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b61__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b61]>>
[Exp_IR] Exp -> id: b61
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b61
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b61
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_182 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_183
Lex Ate token  id__b62__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token and__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_184
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b62]type:[]>>
<<Statement_Semantic with id[b62]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_183 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_185
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b62__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b62]>>
[Exp_IR] Exp -> id: b62
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b62
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b62
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_185 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_186
Lex Ate token  id__b63__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token and__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_187
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b63]type:[]>>
<<Statement_Semantic with id[b63]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_186 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_188
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b63__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b63]>>
[Exp_IR] Exp -> id: b63
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b63
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b63
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_188 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_189
Lex Ate token  id__b64__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token and__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_190
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b64]type:[]>>
<<Statement_Semantic with id[b64]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_189 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_191
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b64__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b64]>>
[Exp_IR] Exp -> id: b64
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b64
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b64
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_191 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_192
Lex Ate token  id__b65__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token and__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_193
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b65]type:[]>>
<<Statement_Semantic with id[b65]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_192 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_194
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b65__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b65]>>
[Exp_IR] Exp -> id: b65
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b65
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b65
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_194 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_195
Lex Ate token  id__b66__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token and__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_196
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:False falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b66]type:[]>>
<<Statement_Semantic with id[b66]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_195 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_197
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b66__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b66]>>
[Exp_IR] Exp -> id: b66
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b66
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b66
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_197 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_198
Lex Ate token  id__b67__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_199
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b67]type:[]>>
<<Statement_Semantic with id[b67]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_198 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_200
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b67__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b67]>>
[Exp_IR] Exp -> id: b67
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b67
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b67
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_200 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_201
Lex Ate token  id__b68__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_202
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b68]type:[]>>
<<Statement_Semantic with id[b68]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_201 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_203
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b68__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b68]>>
[Exp_IR] Exp -> id: b68
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b68
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b68
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_203 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_204
Lex Ate token  id__b69__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_205
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b69]type:[]>>
<<Statement_Semantic with id[b69]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_204 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_206
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b69__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b69]>>
[Exp_IR] Exp -> id: b69
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b69
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b69
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_206 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_207
Lex Ate token  id__b70__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_208
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b70]type:[]>>
<<Statement_Semantic with id[b70]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_207 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_209
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b70__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b70]>>
[Exp_IR] Exp -> id: b70
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b70
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b70
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_209 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_210
Lex Ate token  id__b71__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_211
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b71]type:[]>>
<<Statement_Semantic with id[b71]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_210 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_212
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b71__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b71]>>
[Exp_IR] Exp -> id: b71
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b71
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b71
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_212 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_213
Lex Ate token  id__b72__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_214
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b72]type:[]>>
<<Statement_Semantic with id[b72]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_213 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_215
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b72__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b72]>>
[Exp_IR] Exp -> id: b72
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b72
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b72
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_215 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_216
Lex Ate token  id__b73__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_217
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b73]type:[]>>
<<Statement_Semantic with id[b73]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_216 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_218
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b73__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b73]>>
[Exp_IR] Exp -> id: b73
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b73
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b73
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_218 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_219
Lex Ate token  id__b74__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_220
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b74]type:[]>>
<<Statement_Semantic with id[b74]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_219 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_221
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b74__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b74]>>
[Exp_IR] Exp -> id: b74
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b74
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b74
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_221 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_222
Lex Ate token  id__b75__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_223
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b75]type:[]>>
<<Statement_Semantic with id[b75]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_222 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_224
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b75__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b75]>>
[Exp_IR] Exp -> id: b75
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b75
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b75
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_224 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_225
Lex Ate token  id__b76__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token and__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_226
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:f falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b76]type:[]>>
<<Statement_Semantic with id[b76]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_225 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_227
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b76__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b76]>>
[Exp_IR] Exp -> id: b76
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b76
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b76
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_227 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_228
Lex Ate token  id__b77__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_229
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b77]type:[]>>
<<Statement_Semantic with id[b77]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_228 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_230
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b77__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b77]>>
[Exp_IR] Exp -> id: b77
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b77
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b77
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_230 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_231
Lex Ate token  id__b78__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_232
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b78]type:[]>>
<<Statement_Semantic with id[b78]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_231 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_233
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b78__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b78]>>
[Exp_IR] Exp -> id: b78
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b78
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b78
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_233 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_234
Lex Ate token  id__b79__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_235
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b79]type:[]>>
<<Statement_Semantic with id[b79]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_234 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_236
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b79__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b79]>>
[Exp_IR] Exp -> id: b79
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b79
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b79
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_236 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_237
Lex Ate token  id__b80__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_238
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b80]type:[]>>
<<Statement_Semantic with id[b80]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_237 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_239
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b80__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b80]>>
[Exp_IR] Exp -> id: b80
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b80
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b80
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_239 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_240
Lex Ate token  id__b81__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token and__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_241
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b81]type:[]>>
<<Statement_Semantic with id[b81]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_240 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_242
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b81__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b81]>>
[Exp_IR] Exp -> id: b81
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b81
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b81
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_242 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_243
Lex Ate token  id__b82__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_244
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:False falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b82]type:[]>>
<<Statement_Semantic with id[b82]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_243 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_245
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b82__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b82]>>
[Exp_IR] Exp -> id: b82
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b82
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b82
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_245 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_246
Lex Ate token  id__b83__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_247
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:false falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b83]type:[]>>
<<Statement_Semantic with id[b83]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_246 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_248
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b83__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b83]>>
[Exp_IR] Exp -> id: b83
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b83
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b83
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_248 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_249
Lex Ate token  id__b84__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_250
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:f falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b84]type:[]>>
<<Statement_Semantic with id[b84]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_249 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_251
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b84__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b84]>>
[Exp_IR] Exp -> id: b84
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b84
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b84
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_251 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_252
Lex Ate token  id__b85__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_253
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b85]type:[]>>
<<Statement_Semantic with id[b85]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_252 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_254
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b85__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b85]>>
[Exp_IR] Exp -> id: b85
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b85
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b85
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_254 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_255
Lex Ate token  id__b86__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token and__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_256
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b86]type:[]>>
<<Statement_Semantic with id[b86]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_255 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_257
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b86__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b86]>>
[Exp_IR] Exp -> id: b86
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b86
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b86
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_257 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_258
Lex Ate token  id__b87__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token or__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_259
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_259
exp1:True truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b87]type:[]>>
<<Statement_Semantic with id[b87]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_258 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_260
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b87__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b87]>>
[Exp_IR] Exp -> id: b87
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b87
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b87
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_260 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_261
Lex Ate token  id__b88__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token or__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_262
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_262
exp1:True truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b88]type:[]>>
<<Statement_Semantic with id[b88]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_261 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_263
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b88__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b88]>>
[Exp_IR] Exp -> id: b88
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b88
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b88
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_263 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_264
Lex Ate token  id__b89__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token or__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_265
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_265
exp1:True truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b89]type:[]>>
<<Statement_Semantic with id[b89]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_264 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_266
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b89__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b89]>>
[Exp_IR] Exp -> id: b89
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b89
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b89
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_266 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_267
Lex Ate token  id__b90__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token or__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_268
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_268
exp1:True truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b90]type:[]>>
<<Statement_Semantic with id[b90]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_267 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_269
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b90__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b90]>>
[Exp_IR] Exp -> id: b90
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b90
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b90
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_269 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_270
Lex Ate token  id__b91__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__True__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments True
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callTrue
[Exp_IR] endof Exp->callTrue
Lex Ate token or__
[SJ_Exp_IR]: True
[MARKER IR]: label: bp_label_271
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_271
exp1:True truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b91]type:[]>>
<<Statement_Semantic with id[b91]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_270 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_272
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b91__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b91]>>
[Exp_IR] Exp -> id: b91
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b91
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b91
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_272 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_273
Lex Ate token  id__b92__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_274
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_274
exp1:true truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b92]type:[]>>
<<Statement_Semantic with id[b92]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_273 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_275
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b92__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b92]>>
[Exp_IR] Exp -> id: b92
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b92
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b92
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_275 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_276
Lex Ate token  id__b93__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_277
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_277
exp1:true truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b93]type:[]>>
<<Statement_Semantic with id[b93]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_276 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_278
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b93__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b93]>>
[Exp_IR] Exp -> id: b93
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b93
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b93
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_278 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_279
Lex Ate token  id__b94__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_280
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_280
exp1:true truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b94]type:[]>>
<<Statement_Semantic with id[b94]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_279 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_281
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b94__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b94]>>
[Exp_IR] Exp -> id: b94
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b94
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b94
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_281 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_282
Lex Ate token  id__b95__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_283
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_283
exp1:true truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b95]type:[]>>
<<Statement_Semantic with id[b95]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_282 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_284
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b95__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b95]>>
[Exp_IR] Exp -> id: b95
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b95
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b95
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_284 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_285
Lex Ate token  id__b96__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_286
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_286
exp1:true truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b96]type:[]>>
<<Statement_Semantic with id[b96]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_285 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_287
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b96__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b96]>>
[Exp_IR] Exp -> id: b96
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b96
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b96
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_287 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_288
Lex Ate token  id__b97__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_289
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_289
exp1:t truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b97]type:[]>>
<<Statement_Semantic with id[b97]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_288 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_290
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b97__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b97]>>
[Exp_IR] Exp -> id: b97
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b97
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b97
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_290 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_291
Lex Ate token  id__b98__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_292
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_292
exp1:t truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b98]type:[]>>
<<Statement_Semantic with id[b98]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_291 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_293
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b98__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b98]>>
[Exp_IR] Exp -> id: b98
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b98
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b98
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_293 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_294
Lex Ate token  id__b99__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_295
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_295
exp1:t truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b99]type:[]>>
<<Statement_Semantic with id[b99]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_294 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_296
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b99__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b99]>>
[Exp_IR] Exp -> id: b99
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b99
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b99
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_296 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_297
Lex Ate token  id__b100__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_298
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_298
exp1:t truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b100]type:[]>>
<<Statement_Semantic with id[b100]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_297 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_299
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b100__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b100]>>
[Exp_IR] Exp -> id: b100
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b100
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b100
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_299 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_300
Lex Ate token  id__b101__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__t__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[t]>>
[Exp_IR] Exp -> id: t
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: t
[MARKER IR]: label: bp_label_301
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_301
exp1:t truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b101]type:[]>>
<<Statement_Semantic with id[b101]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_300 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_302
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b101__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b101]>>
[Exp_IR] Exp -> id: b101
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b101
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b101
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_302 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_303
Lex Ate token  id__b102__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_304
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_304
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b102]type:[]>>
<<Statement_Semantic with id[b102]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_303 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_305
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b102__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b102]>>
[Exp_IR] Exp -> id: b102
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b102
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b102
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_305 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_306
Lex Ate token  id__b103__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_307
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_307
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b103]type:[]>>
<<Statement_Semantic with id[b103]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_306 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_308
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b103__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b103]>>
[Exp_IR] Exp -> id: b103
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b103
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b103
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_308 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_309
Lex Ate token  id__b104__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_310
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_310
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b104]type:[]>>
<<Statement_Semantic with id[b104]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_309 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_311
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b104__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b104]>>
[Exp_IR] Exp -> id: b104
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b104
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b104
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_311 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_312
Lex Ate token  id__b105__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_313
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_313
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b105]type:[]>>
<<Statement_Semantic with id[b105]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_312 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_314
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b105__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b105]>>
[Exp_IR] Exp -> id: b105
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b105
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b105
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_314 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_315
Lex Ate token  id__b106__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__<__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_316
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_316
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b106]type:[]>>
<<Statement_Semantic with id[b106]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_315 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_317
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b106__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b106]>>
[Exp_IR] Exp -> id: b106
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b106
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b106
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_317 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_318
Lex Ate token  id__b107__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_319
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_319
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b107]type:[]>>
<<Statement_Semantic with id[b107]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_318 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_320
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b107__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b107]>>
[Exp_IR] Exp -> id: b107
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b107
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b107
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_320 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_321
Lex Ate token  id__b108__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_322
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_322
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b108]type:[]>>
<<Statement_Semantic with id[b108]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_321 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_323
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b108__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b108]>>
[Exp_IR] Exp -> id: b108
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b108
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b108
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_323 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_324
Lex Ate token  id__b109__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_325
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_325
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b109]type:[]>>
<<Statement_Semantic with id[b109]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_324 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_326
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b109__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b109]>>
[Exp_IR] Exp -> id: b109
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b109
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b109
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_326 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_327
Lex Ate token  id__b110__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_328
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_328
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b110]type:[]>>
<<Statement_Semantic with id[b110]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_327 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_329
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b110__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b110]>>
[Exp_IR] Exp -> id: b110
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b110
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b110
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_329 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_330
Lex Ate token  id__b111__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_331
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_331
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b111]type:[]>>
<<Statement_Semantic with id[b111]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_330 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_332
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b111__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b111]>>
[Exp_IR] Exp -> id: b111
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b111
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b111
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_332 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_333
Lex Ate token  id__b112__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_334
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_334
exp1:False truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b112]type:[]>>
<<Statement_Semantic with id[b112]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_333 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_335
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b112__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b112]>>
[Exp_IR] Exp -> id: b112
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b112
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b112
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_335 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_336
Lex Ate token  id__b113__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_337
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_337
exp1:False truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b113]type:[]>>
<<Statement_Semantic with id[b113]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_336 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_338
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b113__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b113]>>
[Exp_IR] Exp -> id: b113
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b113
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b113
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_338 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_339
Lex Ate token  id__b114__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_340
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_340
exp1:False truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b114]type:[]>>
<<Statement_Semantic with id[b114]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_339 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_341
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b114__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b114]>>
[Exp_IR] Exp -> id: b114
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b114
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b114
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_341 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_342
Lex Ate token  id__b115__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_343
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_343
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b115]type:[]>>
<<Statement_Semantic with id[b115]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_342 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_344
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b115__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b115]>>
[Exp_IR] Exp -> id: b115
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b115
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b115
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_344 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_345
Lex Ate token  id__b116__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_346
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_346
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b116]type:[]>>
<<Statement_Semantic with id[b116]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_345 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_347
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b116__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b116]>>
[Exp_IR] Exp -> id: b116
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b116
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b116
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_347 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_348
Lex Ate token  id__b117__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_349
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_349
exp1:false truelistSize: 0
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b117]type:[]>>
<<Statement_Semantic with id[b117]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_348 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_350
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b117__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b117]>>
[Exp_IR] Exp -> id: b117
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b117
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b117
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_350 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_351
Lex Ate token  id__b118__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_352
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_352
exp1:false truelistSize: 0
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b118]type:[]>>
<<Statement_Semantic with id[b118]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_351 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_353
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b118__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b118]>>
[Exp_IR] Exp -> id: b118
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b118
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b118
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_353 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_354
Lex Ate token  id__b119__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_355
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_355
exp1:false truelistSize: 0
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b119]type:[]>>
<<Statement_Semantic with id[b119]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_354 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_356
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b119__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b119]>>
[Exp_IR] Exp -> id: b119
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b119
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b119
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_356 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_357
Lex Ate token  id__b120__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_358
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_358
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b120]type:[]>>
<<Statement_Semantic with id[b120]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_357 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_359
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b120__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b120]>>
[Exp_IR] Exp -> id: b120
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b120
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b120
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_359 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_360
Lex Ate token  id__b121__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_361
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_361
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b121]type:[]>>
<<Statement_Semantic with id[b121]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_360 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_362
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b121__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b121]>>
[Exp_IR] Exp -> id: b121
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b121
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b121
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_362 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_363
Lex Ate token  id__b122__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_364
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_364
exp1:f truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b122]type:[]>>
<<Statement_Semantic with id[b122]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_363 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_365
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b122__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b122]>>
[Exp_IR] Exp -> id: b122
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b122
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b122
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_365 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_366
Lex Ate token  id__b123__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_367
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_367
exp1:f truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b123]type:[]>>
<<Statement_Semantic with id[b123]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_366 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_368
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b123__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b123]>>
[Exp_IR] Exp -> id: b123
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b123
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b123
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_368 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_369
Lex Ate token  id__b124__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_370
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_370
exp1:f truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b124]type:[]>>
<<Statement_Semantic with id[b124]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_369 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_371
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b124__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b124]>>
[Exp_IR] Exp -> id: b124
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b124
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b124
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_371 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_372
Lex Ate token  id__b125__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_373
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_373
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b125]type:[]>>
<<Statement_Semantic with id[b125]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_372 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_374
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b125__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b125]>>
[Exp_IR] Exp -> id: b125
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b125
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b125
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_374 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_375
Lex Ate token  id__b126__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_376
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_376
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b126]type:[]>>
<<Statement_Semantic with id[b126]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_375 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_377
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b126__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b126]>>
[Exp_IR] Exp -> id: b126
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b126
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b126
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_377 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_378
Lex Ate token  id__b127__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_379
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_379
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b127]type:[]>>
<<Statement_Semantic with id[b127]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_378 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_380
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b127__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b127]>>
[Exp_IR] Exp -> id: b127
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b127
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b127
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_380 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_381
Lex Ate token  id__b128__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_382
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_382
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b128]type:[]>>
<<Statement_Semantic with id[b128]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_381 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_383
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b128__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b128]>>
[Exp_IR] Exp -> id: b128
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b128
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b128
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_383 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_384
Lex Ate token  id__b129__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_385
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_385
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b129]type:[]>>
<<Statement_Semantic with id[b129]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_384 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_386
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b129__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b129]>>
[Exp_IR] Exp -> id: b129
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b129
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b129
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_386 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_387
Lex Ate token  id__b130__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_388
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_388
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b130]type:[]>>
<<Statement_Semantic with id[b130]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_387 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_389
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b130__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b130]>>
[Exp_IR] Exp -> id: b130
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b130
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b130
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_389 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_390
Lex Ate token  id__b131__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_391
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_391
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b131]type:[]>>
<<Statement_Semantic with id[b131]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_390 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_392
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b131__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b131]>>
[Exp_IR] Exp -> id: b131
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b131
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b131
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_392 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_393
Lex Ate token  id__b132__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_394
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_394
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b132]type:[]>>
<<Statement_Semantic with id[b132]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_393 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_395
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b132__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b132]>>
[Exp_IR] Exp -> id: b132
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b132
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b132
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_395 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_396
Lex Ate token  id__b133__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_397
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_397
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b133]type:[]>>
<<Statement_Semantic with id[b133]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_396 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_398
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b133__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b133]>>
[Exp_IR] Exp -> id: b133
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b133
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b133
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_398 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_399
Lex Ate token  id__b134__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_400
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_400
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b134]type:[]>>
<<Statement_Semantic with id[b134]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_399 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_401
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b134__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b134]>>
[Exp_IR] Exp -> id: b134
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b134
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b134
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_401 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_402
Lex Ate token  id__b135__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_403
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_403
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b135]type:[]>>
<<Statement_Semantic with id[b135]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_402 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_404
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b135__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b135]>>
[Exp_IR] Exp -> id: b135
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b135
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b135
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_404 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_405
Lex Ate token  id__b136__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_406
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_406
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b136]type:[]>>
<<Statement_Semantic with id[b136]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_405 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_407
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b136__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b136]>>
[Exp_IR] Exp -> id: b136
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b136
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b136
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_407 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_408
Lex Ate token  id__b137__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_409
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_409
exp1:False truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b137]type:[]>>
<<Statement_Semantic with id[b137]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_408 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_410
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b137__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b137]>>
[Exp_IR] Exp -> id: b137
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b137
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b137
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_410 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_411
Lex Ate token  id__b138__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_412
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_412
exp1:False truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b138]type:[]>>
<<Statement_Semantic with id[b138]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_411 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_413
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b138__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b138]>>
[Exp_IR] Exp -> id: b138
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b138
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b138
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_413 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_414
Lex Ate token  id__b139__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_415
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_415
exp1:False truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b139]type:[]>>
<<Statement_Semantic with id[b139]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_414 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_416
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b139__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b139]>>
[Exp_IR] Exp -> id: b139
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b139
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b139
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_416 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_417
Lex Ate token  id__b140__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_418
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_418
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b140]type:[]>>
<<Statement_Semantic with id[b140]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_417 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_419
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b140__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b140]>>
[Exp_IR] Exp -> id: b140
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b140
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b140
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_419 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_420
Lex Ate token  id__b141__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
Lex Ate token or__
[SJ_Exp_IR]: False
[MARKER IR]: label: bp_label_421
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_421
exp1:False truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b141]type:[]>>
<<Statement_Semantic with id[b141]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_420 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_422
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b141__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b141]>>
[Exp_IR] Exp -> id: b141
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b141
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b141
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_422 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_423
Lex Ate token  id__b142__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_424
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_424
exp1:false truelistSize: 0
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b142]type:[]>>
<<Statement_Semantic with id[b142]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_423 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_425
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b142__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b142]>>
[Exp_IR] Exp -> id: b142
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b142
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b142
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_425 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_426
Lex Ate token  id__b143__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_427
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_427
exp1:false truelistSize: 0
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 0
<<[Statement_Semantic][TypeID_SC] id:[b143]type:[]>>
<<Statement_Semantic with id[b143]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_426 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_428
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b143__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b143]>>
[Exp_IR] Exp -> id: b143
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b143
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b143
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_428 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_429
Lex Ate token  id__b144__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_430
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_430
exp1:false truelistSize: 0
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b144]type:[]>>
<<Statement_Semantic with id[b144]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_429 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_431
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b144__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b144]>>
[Exp_IR] Exp -> id: b144
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b144
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b144
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_431 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_432
Lex Ate token  id__b145__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_433
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_433
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b145]type:[]>>
<<Statement_Semantic with id[b145]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_432 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_434
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b145__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b145]>>
[Exp_IR] Exp -> id: b145
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b145
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b145
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_434 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_435
Lex Ate token  id__b146__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_436
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_436
exp1:false truelistSize: 0
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b146]type:[]>>
<<Statement_Semantic with id[b146]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_435 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_437
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b146__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b146]>>
[Exp_IR] Exp -> id: b146
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b146
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b146
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_437 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_438
Lex Ate token  id__b147__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_439
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_439
exp1:f truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b147]type:[]>>
<<Statement_Semantic with id[b147]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_438 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_440
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b147__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b147]>>
[Exp_IR] Exp -> id: b147
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b147
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b147
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_440 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_441
Lex Ate token  id__b148__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_442
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_442
exp1:f truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b148]type:[]>>
<<Statement_Semantic with id[b148]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_441 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_443
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b148__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b148]>>
[Exp_IR] Exp -> id: b148
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b148
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b148
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_443 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_444
Lex Ate token  id__b149__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_445
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_445
exp1:f truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b149]type:[]>>
<<Statement_Semantic with id[b149]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_444 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_446
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b149__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b149]>>
[Exp_IR] Exp -> id: b149
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b149
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b149
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_446 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_447
Lex Ate token  id__b150__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_448
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_448
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b150]type:[]>>
<<Statement_Semantic with id[b150]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_447 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_449
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b150__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b150]>>
[Exp_IR] Exp -> id: b150
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b150
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b150
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_449 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_450
Lex Ate token  id__b151__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__f__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[MARKER IR]: label: bp_label_451
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_451
exp1:f truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b151]type:[]>>
<<Statement_Semantic with id[b151]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_450 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_452
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b151__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b151]>>
[Exp_IR] Exp -> id: b151
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b151
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b151
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_452 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_453
Lex Ate token  id__b152__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_454
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_454
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b152]type:[]>>
<<Statement_Semantic with id[b152]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_453 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_455
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b152__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b152]>>
[Exp_IR] Exp -> id: b152
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b152
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b152
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_455 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_456
Lex Ate token  id__b153__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_457
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_457
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b153]type:[]>>
<<Statement_Semantic with id[b153]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_456 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_458
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b153__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b153]>>
[Exp_IR] Exp -> id: b153
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b153
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b153
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_458 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_459
Lex Ate token  id__b154__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_460
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_460
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b154]type:[]>>
<<Statement_Semantic with id[b154]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_459 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_461
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b154__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b154]>>
[Exp_IR] Exp -> id: b154
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b154
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b154
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_461 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_462
Lex Ate token  id__b155__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_463
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_463
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b155]type:[]>>
<<Statement_Semantic with id[b155]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_462 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_464
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b155__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b155]>>
[Exp_IR] Exp -> id: b155
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b155
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b155
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_464 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_465
Lex Ate token  id__b156__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token or__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_466
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_466
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b156]type:[]>>
<<Statement_Semantic with id[b156]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_465 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_467
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b156__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b156]>>
[Exp_IR] Exp -> id: b156
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b156
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b156
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_467 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_468
Lex Ate token  id__b157__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_469
Lex Ate token  id__False__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments False
regNum=2
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callFalse
[Exp_IR] endof Exp->callFalse
[SJ_Exp_IR]: False
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_469
exp1: truelistSize: 1
exp2:False truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b157]type:[]>>
<<Statement_Semantic with id[b157]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_468 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_470
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b157__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b157]>>
[Exp_IR] Exp -> id: b157
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b157
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b157
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_470 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_471
Lex Ate token  id__b158__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_472
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_472
exp1: truelistSize: 1
exp2:false truelistSize: 0
Exp: falselistSize: 1
Exp: truelistSize: 1
<<[Statement_Semantic][TypeID_SC] id:[b158]type:[]>>
<<Statement_Semantic with id[b158]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_471 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_473
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b158__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b158]>>
[Exp_IR] Exp -> id: b158
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b158
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b158
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_473 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_474
Lex Ate token  id__b159__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_475
Lex Ate token  id__f__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[f]>>
[Exp_IR] Exp -> id: f
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: f
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_475
exp1: truelistSize: 1
exp2:f truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b159]type:[]>>
<<Statement_Semantic with id[b159]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_474 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_476
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b159__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b159]>>
[Exp_IR] Exp -> id: b159
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b159
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b159
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_476 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_477
Lex Ate token  id__b160__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_478
Lex Ate token  num__4__
Lex Ate token  RelOp__>__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_478
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b160]type:[]>>
<<Statement_Semantic with id[b160]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_477 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_479
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b160__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b160]>>
[Exp_IR] Exp -> id: b160
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b160
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b160
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_479 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_480
Lex Ate token  id__b161__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token or__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_481
Lex Ate token  num__4__
Lex Ate token  RelOp__!=__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_481
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<[Statement_Semantic][TypeID_SC] id:[b161]type:[]>>
<<Statement_Semantic with id[b161]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_480 breaklist size is 0
Lex Ate token  id__printBool__
[MARKER IR]: label: bp_label_482
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  id__b161__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[b161]>>
[Exp_IR] Exp -> id: b161
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : b161
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: b161
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printBool
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_482 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
for an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with label_153
[END_OF Program_IR]



 == printing data === 



pvufne1:	.asciiz "Error division by zero
"
string_label_0:	.asciiz "true\n"
string_label_1:	.asciiz "true\n"
string_label_2:	.asciiz "false\n"
string_label_3:	.asciiz "false\n"



 == printing code === 



	#first program point
main:
	#initialize fp
	move	$fp,$sp
	jal	label_153
	#exiting...
li $v0, 10
syscall
	#print_func:
print:
lw $a0,4($sp)
li $v0,4
syscall
jr $ra
	#printi func:
printi:
lw $a0,4($sp)
li $v0,1
syscall
jr $ra
	#div by 0 handler:
nayalo:
	li	$v0, 4
	la	$a0, pvufne1
	syscall
	#exiting...
li $v0, 10
syscall
	#Func printBool:
label_29:
	#Getting Var falue for [Exp->id]: c offset is 4($fp)
	#			 __allocating reg $t0
	lw $t0, 4($fp)
	#a Bool Var c in boolean operator
	#If true
	bne $t0, $zero,bp_label_0
	#			 __freeing reg $t0
	#If False
	j	bp_label_1
	#marker Label
bp_label_0:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_1
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_2
	#marker Label
bp_label_1:
	#func header store regs before call
	#stored 0 registers
	#caught a string
	#preparing to call print
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#loading str address to stack
	la $v0, string_label_3
	sw $v0, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	#jumping to func: print
	jal	print
	#returned from func: print
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling print
	#end of statement jump
	j	bp_label_2
	#end of ifelse
bp_label_2:
	#end of statement jump
	j	bp_label_3
bp_label_3:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func True:
label_111:
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_5
	#return noneVoid in v0
bp_label_5:
	li	$v0,1
	j	bp_label_4
bp_label_6:
	li	$v0,0
bp_label_4:
	move	$sp,$fp
	jr	$ra
bp_label_7:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func False:
label_132:
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_10
	#return noneVoid in v0
bp_label_9:
	li	$v0,1
	j	bp_label_8
bp_label_10:
	li	$v0,0
bp_label_8:
	move	$sp,$fp
	jr	$ra
bp_label_11:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
	#Func main:
label_153:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
bExpAss_nfjdn0:
	#assigning True to t
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, ($fp)
	j	bp_label_12
bExpAss_nfjdn1:
	#assigning False to t
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, ($fp)
	j	bp_label_12
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_12
	#marker Label
bp_label_12:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
bExpAss_nfjdn2:
	#assigning True to f
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -4($fp)
	j	bp_label_13
bExpAss_nfjdn3:
	#assigning False to f
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -4($fp)
	j	bp_label_13
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_13
	#marker Label
bp_label_13:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	#stored 0 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t0
	move	$t0,$v0
	#a Bool Func True
	bne $t0, $zero,bExpAss_nfjdn4
	j	bExpAss_nfjdn5
	#			 __freeing reg $t0
bExpAss_nfjdn4:
	#assigning True to b2
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -8($fp)
	j	bp_label_14
bExpAss_nfjdn5:
	#assigning False to b2
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -8($fp)
	j	bp_label_14
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_14
	#marker Label
bp_label_14:
	#func header store regs before call
	#stored 0 registers
	#Getting Var falue for [Exp->id]: b2 offset is -8($fp)
	#			 __allocating reg $t0
	lw $t0, -8($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_15
	#marker Label
bp_label_15:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
bExpAss_nfjdn6:
	#assigning True to b3
	#			 __allocating reg $t0
	li	$t0,1
	sw $t0, -12($fp)
	j	bp_label_16
bExpAss_nfjdn7:
	#assigning False to b3
	#			 __allocating reg $t0
	li	$t0,0
	sw $t0, -12($fp)
	j	bp_label_16
	#			 __freeing reg $t0
	#end of statement jump
	j	bp_label_16
	#marker Label
bp_label_16:
	#func header store regs before call
	#stored 0 registers
	#Getting Var falue for [Exp->id]: b3 offset is -12($fp)
	#			 __allocating reg $t0
	lw $t0, -12($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 0 previously used registers
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_17
	#marker Label
bp_label_17:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t0
	lw $t0, ($fp)
bExpAss_nfjdn8:
	#assigning True to b4
	#			 __allocating reg $t1
	li	$t1,1
	sw $t1, -16($fp)
	j	bp_label_18
bExpAss_nfjdn9:
	#assigning False to b4
	#			 __allocating reg $t1
	li	$t1,0
	sw $t1, -16($fp)
	j	bp_label_18
	#			 __freeing reg $t1
	#end of statement jump
	j	bp_label_18
	#marker Label
bp_label_18:
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	#Getting Var falue for [Exp->id]: b4 offset is -16($fp)
	#			 __allocating reg $t0
	lw $t0, -16($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 1 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_19
	#marker Label
bp_label_19:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t1
	li	$t1,4
	#			 __allocating reg $t2
	li	$t2,5
	blt $t1, $t2,bExpAss_nfjdn10
	#			 __freeing reg $t2
	#			 __freeing reg $t1
	j	bExpAss_nfjdn11
bExpAss_nfjdn10:
	#assigning True to b5
	#			 __allocating reg $t1
	li	$t1,1
	sw $t1, -20($fp)
	j	bp_label_20
bExpAss_nfjdn11:
	#assigning False to b5
	#			 __allocating reg $t1
	li	$t1,0
	sw $t1, -20($fp)
	j	bp_label_20
	#			 __freeing reg $t1
	#end of statement jump
	j	bp_label_20
	#marker Label
bp_label_20:
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	#Getting Var falue for [Exp->id]: b5 offset is -20($fp)
	#			 __allocating reg $t0
	lw $t0, -20($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 1 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_21
	#marker Label
bp_label_21:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t1
	li	$t1,4
	#			 __allocating reg $t2
	li	$t2,4
	beq $t1, $t2,bExpAss_nfjdn12
	#			 __freeing reg $t2
	#			 __freeing reg $t1
	j	bExpAss_nfjdn13
bExpAss_nfjdn12:
	#assigning True to b6
	#			 __allocating reg $t1
	li	$t1,1
	sw $t1, -24($fp)
	j	bp_label_22
bExpAss_nfjdn13:
	#assigning False to b6
	#			 __allocating reg $t1
	li	$t1,0
	sw $t1, -24($fp)
	j	bp_label_22
	#			 __freeing reg $t1
	#end of statement jump
	j	bp_label_22
	#marker Label
bp_label_22:
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	#Getting Var falue for [Exp->id]: b6 offset is -24($fp)
	#			 __allocating reg $t0
	lw $t0, -24($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 1 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_23
	#marker Label
bp_label_23:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t1
	move	$t1,$v0
	#a Bool Func False
	bne $t1, $zero,bExpAss_nfjdn14
	j	bExpAss_nfjdn15
	#			 __freeing reg $t1
bExpAss_nfjdn14:
	#assigning True to b7
	#			 __allocating reg $t1
	li	$t1,1
	sw $t1, -28($fp)
	j	bp_label_24
bExpAss_nfjdn15:
	#assigning False to b7
	#			 __allocating reg $t1
	li	$t1,0
	sw $t1, -28($fp)
	j	bp_label_24
	#			 __freeing reg $t1
	#end of statement jump
	j	bp_label_24
	#marker Label
bp_label_24:
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	#Getting Var falue for [Exp->id]: b7 offset is -28($fp)
	#			 __allocating reg $t0
	lw $t0, -28($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 1 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_25
	#marker Label
bp_label_25:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
bExpAss_nfjdn16:
	#assigning True to b8
	#			 __allocating reg $t1
	li	$t1,1
	sw $t1, -32($fp)
	j	bp_label_26
bExpAss_nfjdn17:
	#assigning False to b8
	#			 __allocating reg $t1
	li	$t1,0
	sw $t1, -32($fp)
	j	bp_label_26
	#			 __freeing reg $t1
	#end of statement jump
	j	bp_label_26
	#marker Label
bp_label_26:
	#func header store regs before call
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 1 registers
	#Getting Var falue for [Exp->id]: b8 offset is -32($fp)
	#			 __allocating reg $t0
	lw $t0, -32($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 1 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_27
	#marker Label
bp_label_27:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t1
	lw $t1, -4($fp)
bExpAss_nfjdn18:
	#assigning True to b9
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -36($fp)
	j	bp_label_28
bExpAss_nfjdn19:
	#assigning False to b9
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -36($fp)
	j	bp_label_28
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_28
	#marker Label
bp_label_28:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b9 offset is -36($fp)
	#			 __allocating reg $t0
	lw $t0, -36($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_29
	#marker Label
bp_label_29:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn20
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn21
bExpAss_nfjdn20:
	#assigning True to b10
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -40($fp)
	j	bp_label_30
bExpAss_nfjdn21:
	#assigning False to b10
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -40($fp)
	j	bp_label_30
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_30
	#marker Label
bp_label_30:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b10 offset is -40($fp)
	#			 __allocating reg $t0
	lw $t0, -40($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_31
	#marker Label
bp_label_31:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn22
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn23
bExpAss_nfjdn22:
	#assigning True to b11
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -44($fp)
	j	bp_label_32
bExpAss_nfjdn23:
	#assigning False to b11
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -44($fp)
	j	bp_label_32
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_32
	#marker Label
bp_label_32:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b11 offset is -44($fp)
	#			 __allocating reg $t0
	lw $t0, -44($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_33
	#marker Label
bp_label_33:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_34
	j	bExpAss_nfjdn25
	#			 __freeing reg $t2
	#marker Label
bp_label_34:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn24
	j	bExpAss_nfjdn25
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn24:
	#assigning True to b12
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -48($fp)
	j	bp_label_35
bExpAss_nfjdn25:
	#assigning False to b12
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -48($fp)
	j	bp_label_35
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_35
	#marker Label
bp_label_35:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b12 offset is -48($fp)
	#			 __allocating reg $t0
	lw $t0, -48($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_36
	#marker Label
bp_label_36:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_37
	j	bExpAss_nfjdn27
	#			 __freeing reg $t2
	#marker Label
bp_label_37:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn27
	#reach And derivation
bExpAss_nfjdn26:
	#assigning True to b13
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -52($fp)
	j	bp_label_38
bExpAss_nfjdn27:
	#assigning False to b13
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -52($fp)
	j	bp_label_38
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_38
	#marker Label
bp_label_38:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b13 offset is -52($fp)
	#			 __allocating reg $t0
	lw $t0, -52($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_39
	#marker Label
bp_label_39:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_40
	j	bExpAss_nfjdn29
	#			 __freeing reg $t2
	#marker Label
bp_label_40:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn28
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn29
	#reach And derivation
bExpAss_nfjdn28:
	#assigning True to b14
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -56($fp)
	j	bp_label_41
bExpAss_nfjdn29:
	#assigning False to b14
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -56($fp)
	j	bp_label_41
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_41
	#marker Label
bp_label_41:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b14 offset is -56($fp)
	#			 __allocating reg $t0
	lw $t0, -56($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_42
	#marker Label
bp_label_42:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_43
	j	bExpAss_nfjdn31
	#			 __freeing reg $t2
	#marker Label
bp_label_43:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn30
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn31
	#reach And derivation
bExpAss_nfjdn30:
	#assigning True to b15
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -60($fp)
	j	bp_label_44
bExpAss_nfjdn31:
	#assigning False to b15
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -60($fp)
	j	bp_label_44
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_44
	#marker Label
bp_label_44:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b15 offset is -60($fp)
	#			 __allocating reg $t0
	lw $t0, -60($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_45
	#marker Label
bp_label_45:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_46
	j	bExpAss_nfjdn33
	#			 __freeing reg $t2
	#marker Label
bp_label_46:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn32
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn33
	#reach And derivation
bExpAss_nfjdn32:
	#assigning True to b16
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -64($fp)
	j	bp_label_47
bExpAss_nfjdn33:
	#assigning False to b16
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -64($fp)
	j	bp_label_47
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_47
	#marker Label
bp_label_47:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b16 offset is -64($fp)
	#			 __allocating reg $t0
	lw $t0, -64($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_48
	#marker Label
bp_label_48:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_49
	#marker Label
bp_label_49:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn34
	j	bExpAss_nfjdn35
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn34:
	#assigning True to b17
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -68($fp)
	j	bp_label_50
bExpAss_nfjdn35:
	#assigning False to b17
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -68($fp)
	j	bp_label_50
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_50
	#marker Label
bp_label_50:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b17 offset is -68($fp)
	#			 __allocating reg $t0
	lw $t0, -68($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_51
	#marker Label
bp_label_51:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_52
	#marker Label
bp_label_52:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn37
	#reach And derivation
bExpAss_nfjdn36:
	#assigning True to b18
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -72($fp)
	j	bp_label_53
bExpAss_nfjdn37:
	#assigning False to b18
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -72($fp)
	j	bp_label_53
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_53
	#marker Label
bp_label_53:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b18 offset is -72($fp)
	#			 __allocating reg $t0
	lw $t0, -72($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_54
	#marker Label
bp_label_54:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_55
	#marker Label
bp_label_55:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn38
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn39
	#reach And derivation
bExpAss_nfjdn38:
	#assigning True to b19
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -76($fp)
	j	bp_label_56
bExpAss_nfjdn39:
	#assigning False to b19
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -76($fp)
	j	bp_label_56
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_56
	#marker Label
bp_label_56:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b19 offset is -76($fp)
	#			 __allocating reg $t0
	lw $t0, -76($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_57
	#marker Label
bp_label_57:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_58
	#marker Label
bp_label_58:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn40
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn41
	#reach And derivation
bExpAss_nfjdn40:
	#assigning True to b20
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -80($fp)
	j	bp_label_59
bExpAss_nfjdn41:
	#assigning False to b20
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -80($fp)
	j	bp_label_59
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_59
	#marker Label
bp_label_59:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b20 offset is -80($fp)
	#			 __allocating reg $t0
	lw $t0, -80($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_60
	#marker Label
bp_label_60:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_61
	#marker Label
bp_label_61:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn42
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn43
	#reach And derivation
bExpAss_nfjdn42:
	#assigning True to b21
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -84($fp)
	j	bp_label_62
bExpAss_nfjdn43:
	#assigning False to b21
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -84($fp)
	j	bp_label_62
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_62
	#marker Label
bp_label_62:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b21 offset is -84($fp)
	#			 __allocating reg $t0
	lw $t0, -84($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_63
	#marker Label
bp_label_63:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_64
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn45
	#marker Label
bp_label_64:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn44
	j	bExpAss_nfjdn45
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn44:
	#assigning True to b22
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -88($fp)
	j	bp_label_65
bExpAss_nfjdn45:
	#assigning False to b22
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -88($fp)
	j	bp_label_65
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_65
	#marker Label
bp_label_65:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b22 offset is -88($fp)
	#			 __allocating reg $t0
	lw $t0, -88($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_66
	#marker Label
bp_label_66:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_67
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn47
	#marker Label
bp_label_67:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn47
	#reach And derivation
bExpAss_nfjdn46:
	#assigning True to b23
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -92($fp)
	j	bp_label_68
bExpAss_nfjdn47:
	#assigning False to b23
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -92($fp)
	j	bp_label_68
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_68
	#marker Label
bp_label_68:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b23 offset is -92($fp)
	#			 __allocating reg $t0
	lw $t0, -92($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_69
	#marker Label
bp_label_69:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_70
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn49
	#marker Label
bp_label_70:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn48
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn49
	#reach And derivation
bExpAss_nfjdn48:
	#assigning True to b24
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -96($fp)
	j	bp_label_71
bExpAss_nfjdn49:
	#assigning False to b24
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -96($fp)
	j	bp_label_71
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_71
	#marker Label
bp_label_71:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b24 offset is -96($fp)
	#			 __allocating reg $t0
	lw $t0, -96($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_72
	#marker Label
bp_label_72:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_73
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn51
	#marker Label
bp_label_73:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn50
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn51
	#reach And derivation
bExpAss_nfjdn50:
	#assigning True to b25
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -100($fp)
	j	bp_label_74
bExpAss_nfjdn51:
	#assigning False to b25
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -100($fp)
	j	bp_label_74
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_74
	#marker Label
bp_label_74:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b25 offset is -100($fp)
	#			 __allocating reg $t0
	lw $t0, -100($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_75
	#marker Label
bp_label_75:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_76
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn53
	#marker Label
bp_label_76:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn52
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn53
	#reach And derivation
bExpAss_nfjdn52:
	#assigning True to b26
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -104($fp)
	j	bp_label_77
bExpAss_nfjdn53:
	#assigning False to b26
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -104($fp)
	j	bp_label_77
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_77
	#marker Label
bp_label_77:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b26 offset is -104($fp)
	#			 __allocating reg $t0
	lw $t0, -104($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_78
	#marker Label
bp_label_78:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_79
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn55
	#marker Label
bp_label_79:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn54
	j	bExpAss_nfjdn55
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn54:
	#assigning True to b27
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -108($fp)
	j	bp_label_80
bExpAss_nfjdn55:
	#assigning False to b27
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -108($fp)
	j	bp_label_80
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_80
	#marker Label
bp_label_80:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b27 offset is -108($fp)
	#			 __allocating reg $t0
	lw $t0, -108($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_81
	#marker Label
bp_label_81:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_82
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn57
	#marker Label
bp_label_82:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn57
	#reach And derivation
bExpAss_nfjdn56:
	#assigning True to b28
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -112($fp)
	j	bp_label_83
bExpAss_nfjdn57:
	#assigning False to b28
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -112($fp)
	j	bp_label_83
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_83
	#marker Label
bp_label_83:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b28 offset is -112($fp)
	#			 __allocating reg $t0
	lw $t0, -112($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_84
	#marker Label
bp_label_84:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_85
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn59
	#marker Label
bp_label_85:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn58
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn59
	#reach And derivation
bExpAss_nfjdn58:
	#assigning True to b29
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -116($fp)
	j	bp_label_86
bExpAss_nfjdn59:
	#assigning False to b29
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -116($fp)
	j	bp_label_86
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_86
	#marker Label
bp_label_86:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b29 offset is -116($fp)
	#			 __allocating reg $t0
	lw $t0, -116($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_87
	#marker Label
bp_label_87:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_88
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn61
	#marker Label
bp_label_88:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn60
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn61
	#reach And derivation
bExpAss_nfjdn60:
	#assigning True to b30
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -120($fp)
	j	bp_label_89
bExpAss_nfjdn61:
	#assigning False to b30
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -120($fp)
	j	bp_label_89
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_89
	#marker Label
bp_label_89:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b30 offset is -120($fp)
	#			 __allocating reg $t0
	lw $t0, -120($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_90
	#marker Label
bp_label_90:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_91
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn63
	#marker Label
bp_label_91:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn62
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn63
	#reach And derivation
bExpAss_nfjdn62:
	#assigning True to b31
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -124($fp)
	j	bp_label_92
bExpAss_nfjdn63:
	#assigning False to b31
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -124($fp)
	j	bp_label_92
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_92
	#marker Label
bp_label_92:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b31 offset is -124($fp)
	#			 __allocating reg $t0
	lw $t0, -124($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_93
	#marker Label
bp_label_93:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_94
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn65
	#marker Label
bp_label_94:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn64
	j	bExpAss_nfjdn65
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn64:
	#assigning True to b32
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -128($fp)
	j	bp_label_95
bExpAss_nfjdn65:
	#assigning False to b32
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -128($fp)
	j	bp_label_95
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_95
	#marker Label
bp_label_95:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b32 offset is -128($fp)
	#			 __allocating reg $t0
	lw $t0, -128($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_96
	#marker Label
bp_label_96:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_97
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn67
	#marker Label
bp_label_97:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn67
	#reach And derivation
bExpAss_nfjdn66:
	#assigning True to b33
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -132($fp)
	j	bp_label_98
bExpAss_nfjdn67:
	#assigning False to b33
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -132($fp)
	j	bp_label_98
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_98
	#marker Label
bp_label_98:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b33 offset is -132($fp)
	#			 __allocating reg $t0
	lw $t0, -132($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_99
	#marker Label
bp_label_99:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_100
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn69
	#marker Label
bp_label_100:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn68
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn69
	#reach And derivation
bExpAss_nfjdn68:
	#assigning True to b34
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -136($fp)
	j	bp_label_101
bExpAss_nfjdn69:
	#assigning False to b34
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -136($fp)
	j	bp_label_101
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_101
	#marker Label
bp_label_101:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b34 offset is -136($fp)
	#			 __allocating reg $t0
	lw $t0, -136($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_102
	#marker Label
bp_label_102:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_103
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn71
	#marker Label
bp_label_103:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn70
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn71
	#reach And derivation
bExpAss_nfjdn70:
	#assigning True to b35
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -140($fp)
	j	bp_label_104
bExpAss_nfjdn71:
	#assigning False to b35
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -140($fp)
	j	bp_label_104
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_104
	#marker Label
bp_label_104:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b35 offset is -140($fp)
	#			 __allocating reg $t0
	lw $t0, -140($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_105
	#marker Label
bp_label_105:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_106
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn73
	#marker Label
bp_label_106:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn72
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn73
	#reach And derivation
bExpAss_nfjdn72:
	#assigning True to b36
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -144($fp)
	j	bp_label_107
bExpAss_nfjdn73:
	#assigning False to b36
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -144($fp)
	j	bp_label_107
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_107
	#marker Label
bp_label_107:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b36 offset is -144($fp)
	#			 __allocating reg $t0
	lw $t0, -144($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_108
	#marker Label
bp_label_108:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_109
	j	bExpAss_nfjdn75
	#			 __freeing reg $t2
	#marker Label
bp_label_109:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn74
	j	bExpAss_nfjdn75
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn74:
	#assigning True to b37
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -148($fp)
	j	bp_label_110
bExpAss_nfjdn75:
	#assigning False to b37
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -148($fp)
	j	bp_label_110
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_110
	#marker Label
bp_label_110:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b37 offset is -148($fp)
	#			 __allocating reg $t0
	lw $t0, -148($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_111
	#marker Label
bp_label_111:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_112
	j	bExpAss_nfjdn77
	#			 __freeing reg $t2
	#marker Label
bp_label_112:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn77
	#reach And derivation
bExpAss_nfjdn76:
	#assigning True to b38
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -152($fp)
	j	bp_label_113
bExpAss_nfjdn77:
	#assigning False to b38
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -152($fp)
	j	bp_label_113
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_113
	#marker Label
bp_label_113:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b38 offset is -152($fp)
	#			 __allocating reg $t0
	lw $t0, -152($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_114
	#marker Label
bp_label_114:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_115
	j	bExpAss_nfjdn79
	#			 __freeing reg $t2
	#marker Label
bp_label_115:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn78
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn79
	#reach And derivation
bExpAss_nfjdn78:
	#assigning True to b39
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -156($fp)
	j	bp_label_116
bExpAss_nfjdn79:
	#assigning False to b39
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -156($fp)
	j	bp_label_116
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_116
	#marker Label
bp_label_116:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b39 offset is -156($fp)
	#			 __allocating reg $t0
	lw $t0, -156($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_117
	#marker Label
bp_label_117:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_118
	j	bExpAss_nfjdn81
	#			 __freeing reg $t2
	#marker Label
bp_label_118:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn80
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn81
	#reach And derivation
bExpAss_nfjdn80:
	#assigning True to b40
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -160($fp)
	j	bp_label_119
bExpAss_nfjdn81:
	#assigning False to b40
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -160($fp)
	j	bp_label_119
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_119
	#marker Label
bp_label_119:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b40 offset is -160($fp)
	#			 __allocating reg $t0
	lw $t0, -160($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_120
	#marker Label
bp_label_120:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bp_label_121
	j	bExpAss_nfjdn83
	#			 __freeing reg $t2
	#marker Label
bp_label_121:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn82
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn83
	#reach And derivation
bExpAss_nfjdn82:
	#assigning True to b41
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -164($fp)
	j	bp_label_122
bExpAss_nfjdn83:
	#assigning False to b41
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -164($fp)
	j	bp_label_122
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_122
	#marker Label
bp_label_122:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b41 offset is -164($fp)
	#			 __allocating reg $t0
	lw $t0, -164($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_123
	#marker Label
bp_label_123:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_124
	#marker Label
bp_label_124:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn84
	j	bExpAss_nfjdn85
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn84:
	#assigning True to b42
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -168($fp)
	j	bp_label_125
bExpAss_nfjdn85:
	#assigning False to b42
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -168($fp)
	j	bp_label_125
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_125
	#marker Label
bp_label_125:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b42 offset is -168($fp)
	#			 __allocating reg $t0
	lw $t0, -168($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_126
	#marker Label
bp_label_126:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_127
	#marker Label
bp_label_127:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn87
	#reach And derivation
bExpAss_nfjdn86:
	#assigning True to b43
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -172($fp)
	j	bp_label_128
bExpAss_nfjdn87:
	#assigning False to b43
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -172($fp)
	j	bp_label_128
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_128
	#marker Label
bp_label_128:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b43 offset is -172($fp)
	#			 __allocating reg $t0
	lw $t0, -172($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_129
	#marker Label
bp_label_129:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_130
	#marker Label
bp_label_130:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn88
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn89
	#reach And derivation
bExpAss_nfjdn88:
	#assigning True to b44
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -176($fp)
	j	bp_label_131
bExpAss_nfjdn89:
	#assigning False to b44
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -176($fp)
	j	bp_label_131
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_131
	#marker Label
bp_label_131:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b44 offset is -176($fp)
	#			 __allocating reg $t0
	lw $t0, -176($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_132
	#marker Label
bp_label_132:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_133
	#marker Label
bp_label_133:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn90
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn91
	#reach And derivation
bExpAss_nfjdn90:
	#assigning True to b45
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -180($fp)
	j	bp_label_134
bExpAss_nfjdn91:
	#assigning False to b45
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -180($fp)
	j	bp_label_134
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_134
	#marker Label
bp_label_134:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b45 offset is -180($fp)
	#			 __allocating reg $t0
	lw $t0, -180($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_135
	#marker Label
bp_label_135:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bp_label_136
	#marker Label
bp_label_136:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn92
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn93
	#reach And derivation
bExpAss_nfjdn92:
	#assigning True to b46
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -184($fp)
	j	bp_label_137
bExpAss_nfjdn93:
	#assigning False to b46
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -184($fp)
	j	bp_label_137
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_137
	#marker Label
bp_label_137:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b46 offset is -184($fp)
	#			 __allocating reg $t0
	lw $t0, -184($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_138
	#marker Label
bp_label_138:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_139
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn95
	#marker Label
bp_label_139:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn94
	j	bExpAss_nfjdn95
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn94:
	#assigning True to b47
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -188($fp)
	j	bp_label_140
bExpAss_nfjdn95:
	#assigning False to b47
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -188($fp)
	j	bp_label_140
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_140
	#marker Label
bp_label_140:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b47 offset is -188($fp)
	#			 __allocating reg $t0
	lw $t0, -188($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_141
	#marker Label
bp_label_141:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_142
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn97
	#marker Label
bp_label_142:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn97
	#reach And derivation
bExpAss_nfjdn96:
	#assigning True to b48
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -192($fp)
	j	bp_label_143
bExpAss_nfjdn97:
	#assigning False to b48
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -192($fp)
	j	bp_label_143
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_143
	#marker Label
bp_label_143:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b48 offset is -192($fp)
	#			 __allocating reg $t0
	lw $t0, -192($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_144
	#marker Label
bp_label_144:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_145
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn99
	#marker Label
bp_label_145:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn98
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn99
	#reach And derivation
bExpAss_nfjdn98:
	#assigning True to b49
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -196($fp)
	j	bp_label_146
bExpAss_nfjdn99:
	#assigning False to b49
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -196($fp)
	j	bp_label_146
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_146
	#marker Label
bp_label_146:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b49 offset is -196($fp)
	#			 __allocating reg $t0
	lw $t0, -196($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_147
	#marker Label
bp_label_147:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_148
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn101
	#marker Label
bp_label_148:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn100
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn101
	#reach And derivation
bExpAss_nfjdn100:
	#assigning True to b50
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -200($fp)
	j	bp_label_149
bExpAss_nfjdn101:
	#assigning False to b50
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -200($fp)
	j	bp_label_149
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_149
	#marker Label
bp_label_149:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b50 offset is -200($fp)
	#			 __allocating reg $t0
	lw $t0, -200($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_150
	#marker Label
bp_label_150:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bp_label_151
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn103
	#marker Label
bp_label_151:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn102
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn103
	#reach And derivation
bExpAss_nfjdn102:
	#assigning True to b51
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -204($fp)
	j	bp_label_152
bExpAss_nfjdn103:
	#assigning False to b51
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -204($fp)
	j	bp_label_152
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_152
	#marker Label
bp_label_152:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b51 offset is -204($fp)
	#			 __allocating reg $t0
	lw $t0, -204($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_153
	#marker Label
bp_label_153:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_154
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn105
	#marker Label
bp_label_154:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn104
	j	bExpAss_nfjdn105
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn104:
	#assigning True to b52
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -208($fp)
	j	bp_label_155
bExpAss_nfjdn105:
	#assigning False to b52
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -208($fp)
	j	bp_label_155
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_155
	#marker Label
bp_label_155:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b52 offset is -208($fp)
	#			 __allocating reg $t0
	lw $t0, -208($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_156
	#marker Label
bp_label_156:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_157
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn107
	#marker Label
bp_label_157:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn107
	#reach And derivation
bExpAss_nfjdn106:
	#assigning True to b53
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -212($fp)
	j	bp_label_158
bExpAss_nfjdn107:
	#assigning False to b53
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -212($fp)
	j	bp_label_158
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_158
	#marker Label
bp_label_158:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b53 offset is -212($fp)
	#			 __allocating reg $t0
	lw $t0, -212($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_159
	#marker Label
bp_label_159:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_160
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn109
	#marker Label
bp_label_160:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn108
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn109
	#reach And derivation
bExpAss_nfjdn108:
	#assigning True to b54
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -216($fp)
	j	bp_label_161
bExpAss_nfjdn109:
	#assigning False to b54
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -216($fp)
	j	bp_label_161
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_161
	#marker Label
bp_label_161:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b54 offset is -216($fp)
	#			 __allocating reg $t0
	lw $t0, -216($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_162
	#marker Label
bp_label_162:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_163
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn111
	#marker Label
bp_label_163:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn110
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn111
	#reach And derivation
bExpAss_nfjdn110:
	#assigning True to b55
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -220($fp)
	j	bp_label_164
bExpAss_nfjdn111:
	#assigning False to b55
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -220($fp)
	j	bp_label_164
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_164
	#marker Label
bp_label_164:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b55 offset is -220($fp)
	#			 __allocating reg $t0
	lw $t0, -220($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_165
	#marker Label
bp_label_165:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bp_label_166
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn113
	#marker Label
bp_label_166:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn112
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn113
	#reach And derivation
bExpAss_nfjdn112:
	#assigning True to b56
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -224($fp)
	j	bp_label_167
bExpAss_nfjdn113:
	#assigning False to b56
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -224($fp)
	j	bp_label_167
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_167
	#marker Label
bp_label_167:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b56 offset is -224($fp)
	#			 __allocating reg $t0
	lw $t0, -224($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_168
	#marker Label
bp_label_168:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_169
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn115
	#marker Label
bp_label_169:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn114
	j	bExpAss_nfjdn115
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn114:
	#assigning True to b57
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -228($fp)
	j	bp_label_170
bExpAss_nfjdn115:
	#assigning False to b57
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -228($fp)
	j	bp_label_170
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_170
	#marker Label
bp_label_170:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b57 offset is -228($fp)
	#			 __allocating reg $t0
	lw $t0, -228($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_171
	#marker Label
bp_label_171:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_172
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn117
	#marker Label
bp_label_172:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn117
	#reach And derivation
bExpAss_nfjdn116:
	#assigning True to b58
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -232($fp)
	j	bp_label_173
bExpAss_nfjdn117:
	#assigning False to b58
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -232($fp)
	j	bp_label_173
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_173
	#marker Label
bp_label_173:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b58 offset is -232($fp)
	#			 __allocating reg $t0
	lw $t0, -232($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_174
	#marker Label
bp_label_174:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_175
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn119
	#marker Label
bp_label_175:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn118
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn119
	#reach And derivation
bExpAss_nfjdn118:
	#assigning True to b59
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -236($fp)
	j	bp_label_176
bExpAss_nfjdn119:
	#assigning False to b59
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -236($fp)
	j	bp_label_176
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_176
	#marker Label
bp_label_176:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b59 offset is -236($fp)
	#			 __allocating reg $t0
	lw $t0, -236($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_177
	#marker Label
bp_label_177:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_178
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn121
	#marker Label
bp_label_178:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn120
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn121
	#reach And derivation
bExpAss_nfjdn120:
	#assigning True to b60
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -240($fp)
	j	bp_label_179
bExpAss_nfjdn121:
	#assigning False to b60
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -240($fp)
	j	bp_label_179
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_179
	#marker Label
bp_label_179:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b60 offset is -240($fp)
	#			 __allocating reg $t0
	lw $t0, -240($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_180
	#marker Label
bp_label_180:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bp_label_181
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn123
	#marker Label
bp_label_181:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn122
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn123
	#reach And derivation
bExpAss_nfjdn122:
	#assigning True to b61
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -244($fp)
	j	bp_label_182
bExpAss_nfjdn123:
	#assigning False to b61
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -244($fp)
	j	bp_label_182
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_182
	#marker Label
bp_label_182:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b61 offset is -244($fp)
	#			 __allocating reg $t0
	lw $t0, -244($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_183
	#marker Label
bp_label_183:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bp_label_184
	j	bExpAss_nfjdn125
	#			 __freeing reg $t2
	#marker Label
bp_label_184:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn124
	j	bExpAss_nfjdn125
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn124:
	#assigning True to b62
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -248($fp)
	j	bp_label_185
bExpAss_nfjdn125:
	#assigning False to b62
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -248($fp)
	j	bp_label_185
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_185
	#marker Label
bp_label_185:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b62 offset is -248($fp)
	#			 __allocating reg $t0
	lw $t0, -248($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_186
	#marker Label
bp_label_186:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bp_label_187
	j	bExpAss_nfjdn127
	#			 __freeing reg $t2
	#marker Label
bp_label_187:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn127
	#reach And derivation
bExpAss_nfjdn126:
	#assigning True to b63
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -252($fp)
	j	bp_label_188
bExpAss_nfjdn127:
	#assigning False to b63
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -252($fp)
	j	bp_label_188
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_188
	#marker Label
bp_label_188:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b63 offset is -252($fp)
	#			 __allocating reg $t0
	lw $t0, -252($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_189
	#marker Label
bp_label_189:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bp_label_190
	j	bExpAss_nfjdn129
	#			 __freeing reg $t2
	#marker Label
bp_label_190:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn128
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn129
	#reach And derivation
bExpAss_nfjdn128:
	#assigning True to b64
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -256($fp)
	j	bp_label_191
bExpAss_nfjdn129:
	#assigning False to b64
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -256($fp)
	j	bp_label_191
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_191
	#marker Label
bp_label_191:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b64 offset is -256($fp)
	#			 __allocating reg $t0
	lw $t0, -256($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_192
	#marker Label
bp_label_192:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bp_label_193
	j	bExpAss_nfjdn131
	#			 __freeing reg $t2
	#marker Label
bp_label_193:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn130
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn131
	#reach And derivation
bExpAss_nfjdn130:
	#assigning True to b65
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -260($fp)
	j	bp_label_194
bExpAss_nfjdn131:
	#assigning False to b65
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -260($fp)
	j	bp_label_194
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_194
	#marker Label
bp_label_194:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b65 offset is -260($fp)
	#			 __allocating reg $t0
	lw $t0, -260($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_195
	#marker Label
bp_label_195:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bp_label_196
	j	bExpAss_nfjdn133
	#			 __freeing reg $t2
	#marker Label
bp_label_196:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn132
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn133
	#reach And derivation
bExpAss_nfjdn132:
	#assigning True to b66
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -264($fp)
	j	bp_label_197
bExpAss_nfjdn133:
	#assigning False to b66
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -264($fp)
	j	bp_label_197
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_197
	#marker Label
bp_label_197:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b66 offset is -264($fp)
	#			 __allocating reg $t0
	lw $t0, -264($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_198
	#marker Label
bp_label_198:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn135
	#marker Label
bp_label_199:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn134
	j	bExpAss_nfjdn135
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn134:
	#assigning True to b67
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -268($fp)
	j	bp_label_200
bExpAss_nfjdn135:
	#assigning False to b67
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -268($fp)
	j	bp_label_200
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_200
	#marker Label
bp_label_200:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b67 offset is -268($fp)
	#			 __allocating reg $t0
	lw $t0, -268($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_201
	#marker Label
bp_label_201:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn137
	#marker Label
bp_label_202:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn137
	#reach And derivation
bExpAss_nfjdn136:
	#assigning True to b68
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -272($fp)
	j	bp_label_203
bExpAss_nfjdn137:
	#assigning False to b68
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -272($fp)
	j	bp_label_203
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_203
	#marker Label
bp_label_203:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b68 offset is -272($fp)
	#			 __allocating reg $t0
	lw $t0, -272($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_204
	#marker Label
bp_label_204:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn139
	#marker Label
bp_label_205:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn138
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn139
	#reach And derivation
bExpAss_nfjdn138:
	#assigning True to b69
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -276($fp)
	j	bp_label_206
bExpAss_nfjdn139:
	#assigning False to b69
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -276($fp)
	j	bp_label_206
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_206
	#marker Label
bp_label_206:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b69 offset is -276($fp)
	#			 __allocating reg $t0
	lw $t0, -276($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_207
	#marker Label
bp_label_207:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn141
	#marker Label
bp_label_208:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn140
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn141
	#reach And derivation
bExpAss_nfjdn140:
	#assigning True to b70
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -280($fp)
	j	bp_label_209
bExpAss_nfjdn141:
	#assigning False to b70
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -280($fp)
	j	bp_label_209
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_209
	#marker Label
bp_label_209:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b70 offset is -280($fp)
	#			 __allocating reg $t0
	lw $t0, -280($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_210
	#marker Label
bp_label_210:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn143
	#marker Label
bp_label_211:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn142
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn143
	#reach And derivation
bExpAss_nfjdn142:
	#assigning True to b71
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -284($fp)
	j	bp_label_212
bExpAss_nfjdn143:
	#assigning False to b71
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -284($fp)
	j	bp_label_212
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_212
	#marker Label
bp_label_212:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b71 offset is -284($fp)
	#			 __allocating reg $t0
	lw $t0, -284($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_213
	#marker Label
bp_label_213:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bp_label_214
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn145
	#marker Label
bp_label_214:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn144
	j	bExpAss_nfjdn145
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn144:
	#assigning True to b72
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -288($fp)
	j	bp_label_215
bExpAss_nfjdn145:
	#assigning False to b72
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -288($fp)
	j	bp_label_215
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_215
	#marker Label
bp_label_215:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b72 offset is -288($fp)
	#			 __allocating reg $t0
	lw $t0, -288($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_216
	#marker Label
bp_label_216:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bp_label_217
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn147
	#marker Label
bp_label_217:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn147
	#reach And derivation
bExpAss_nfjdn146:
	#assigning True to b73
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -292($fp)
	j	bp_label_218
bExpAss_nfjdn147:
	#assigning False to b73
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -292($fp)
	j	bp_label_218
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_218
	#marker Label
bp_label_218:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b73 offset is -292($fp)
	#			 __allocating reg $t0
	lw $t0, -292($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_219
	#marker Label
bp_label_219:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bp_label_220
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn149
	#marker Label
bp_label_220:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn148
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn149
	#reach And derivation
bExpAss_nfjdn148:
	#assigning True to b74
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -296($fp)
	j	bp_label_221
bExpAss_nfjdn149:
	#assigning False to b74
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -296($fp)
	j	bp_label_221
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_221
	#marker Label
bp_label_221:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b74 offset is -296($fp)
	#			 __allocating reg $t0
	lw $t0, -296($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_222
	#marker Label
bp_label_222:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bp_label_223
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn151
	#marker Label
bp_label_223:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn150
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn151
	#reach And derivation
bExpAss_nfjdn150:
	#assigning True to b75
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -300($fp)
	j	bp_label_224
bExpAss_nfjdn151:
	#assigning False to b75
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -300($fp)
	j	bp_label_224
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_224
	#marker Label
bp_label_224:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b75 offset is -300($fp)
	#			 __allocating reg $t0
	lw $t0, -300($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_225
	#marker Label
bp_label_225:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bp_label_226
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn153
	#marker Label
bp_label_226:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn152
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn153
	#reach And derivation
bExpAss_nfjdn152:
	#assigning True to b76
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -304($fp)
	j	bp_label_227
bExpAss_nfjdn153:
	#assigning False to b76
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -304($fp)
	j	bp_label_227
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_227
	#marker Label
bp_label_227:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b76 offset is -304($fp)
	#			 __allocating reg $t0
	lw $t0, -304($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_228
	#marker Label
bp_label_228:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bp_label_229
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn155
	#marker Label
bp_label_229:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn154
	j	bExpAss_nfjdn155
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn154:
	#assigning True to b77
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -308($fp)
	j	bp_label_230
bExpAss_nfjdn155:
	#assigning False to b77
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -308($fp)
	j	bp_label_230
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_230
	#marker Label
bp_label_230:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b77 offset is -308($fp)
	#			 __allocating reg $t0
	lw $t0, -308($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_231
	#marker Label
bp_label_231:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bp_label_232
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn157
	#marker Label
bp_label_232:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn157
	#reach And derivation
bExpAss_nfjdn156:
	#assigning True to b78
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -312($fp)
	j	bp_label_233
bExpAss_nfjdn157:
	#assigning False to b78
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -312($fp)
	j	bp_label_233
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_233
	#marker Label
bp_label_233:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b78 offset is -312($fp)
	#			 __allocating reg $t0
	lw $t0, -312($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_234
	#marker Label
bp_label_234:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bp_label_235
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn159
	#marker Label
bp_label_235:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn158
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn159
	#reach And derivation
bExpAss_nfjdn158:
	#assigning True to b79
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -316($fp)
	j	bp_label_236
bExpAss_nfjdn159:
	#assigning False to b79
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -316($fp)
	j	bp_label_236
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_236
	#marker Label
bp_label_236:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b79 offset is -316($fp)
	#			 __allocating reg $t0
	lw $t0, -316($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_237
	#marker Label
bp_label_237:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bp_label_238
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn161
	#marker Label
bp_label_238:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn160
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn161
	#reach And derivation
bExpAss_nfjdn160:
	#assigning True to b80
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -320($fp)
	j	bp_label_239
bExpAss_nfjdn161:
	#assigning False to b80
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -320($fp)
	j	bp_label_239
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_239
	#marker Label
bp_label_239:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b80 offset is -320($fp)
	#			 __allocating reg $t0
	lw $t0, -320($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_240
	#marker Label
bp_label_240:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bp_label_241
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn163
	#marker Label
bp_label_241:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn162
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn163
	#reach And derivation
bExpAss_nfjdn162:
	#assigning True to b81
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -324($fp)
	j	bp_label_242
bExpAss_nfjdn163:
	#assigning False to b81
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -324($fp)
	j	bp_label_242
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_242
	#marker Label
bp_label_242:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b81 offset is -324($fp)
	#			 __allocating reg $t0
	lw $t0, -324($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_243
	#marker Label
bp_label_243:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bp_label_244
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn165
	#marker Label
bp_label_244:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn164
	j	bExpAss_nfjdn165
	#			 __freeing reg $t2
	#reach And derivation
bExpAss_nfjdn164:
	#assigning True to b82
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -328($fp)
	j	bp_label_245
bExpAss_nfjdn165:
	#assigning False to b82
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -328($fp)
	j	bp_label_245
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_245
	#marker Label
bp_label_245:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b82 offset is -328($fp)
	#			 __allocating reg $t0
	lw $t0, -328($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_246
	#marker Label
bp_label_246:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bp_label_247
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn167
	#marker Label
bp_label_247:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn167
	#reach And derivation
bExpAss_nfjdn166:
	#assigning True to b83
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -332($fp)
	j	bp_label_248
bExpAss_nfjdn167:
	#assigning False to b83
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -332($fp)
	j	bp_label_248
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_248
	#marker Label
bp_label_248:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b83 offset is -332($fp)
	#			 __allocating reg $t0
	lw $t0, -332($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_249
	#marker Label
bp_label_249:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bp_label_250
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn169
	#marker Label
bp_label_250:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn168
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn169
	#reach And derivation
bExpAss_nfjdn168:
	#assigning True to b84
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -336($fp)
	j	bp_label_251
bExpAss_nfjdn169:
	#assigning False to b84
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -336($fp)
	j	bp_label_251
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_251
	#marker Label
bp_label_251:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b84 offset is -336($fp)
	#			 __allocating reg $t0
	lw $t0, -336($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_252
	#marker Label
bp_label_252:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bp_label_253
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn171
	#marker Label
bp_label_253:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn170
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn171
	#reach And derivation
bExpAss_nfjdn170:
	#assigning True to b85
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -340($fp)
	j	bp_label_254
bExpAss_nfjdn171:
	#assigning False to b85
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -340($fp)
	j	bp_label_254
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_254
	#marker Label
bp_label_254:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b85 offset is -340($fp)
	#			 __allocating reg $t0
	lw $t0, -340($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_255
	#marker Label
bp_label_255:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bp_label_256
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn173
	#marker Label
bp_label_256:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn172
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn173
	#reach And derivation
bExpAss_nfjdn172:
	#assigning True to b86
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -344($fp)
	j	bp_label_257
bExpAss_nfjdn173:
	#assigning False to b86
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -344($fp)
	j	bp_label_257
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_257
	#marker Label
bp_label_257:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b86 offset is -344($fp)
	#			 __allocating reg $t0
	lw $t0, -344($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_258
	#marker Label
bp_label_258:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bExpAss_nfjdn174
	j	bp_label_259
	#			 __freeing reg $t2
	#marker Label
bp_label_259:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn174
	j	bExpAss_nfjdn175
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn174:
	#assigning True to b87
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -348($fp)
	j	bp_label_260
bExpAss_nfjdn175:
	#assigning False to b87
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -348($fp)
	j	bp_label_260
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_260
	#marker Label
bp_label_260:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b87 offset is -348($fp)
	#			 __allocating reg $t0
	lw $t0, -348($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_261
	#marker Label
bp_label_261:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bExpAss_nfjdn176
	j	bp_label_262
	#			 __freeing reg $t2
	#marker Label
bp_label_262:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn177
	#reach Or derivation
bExpAss_nfjdn176:
	#assigning True to b88
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -352($fp)
	j	bp_label_263
bExpAss_nfjdn177:
	#assigning False to b88
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -352($fp)
	j	bp_label_263
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_263
	#marker Label
bp_label_263:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b88 offset is -352($fp)
	#			 __allocating reg $t0
	lw $t0, -352($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_264
	#marker Label
bp_label_264:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bExpAss_nfjdn178
	j	bp_label_265
	#			 __freeing reg $t2
	#marker Label
bp_label_265:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn178
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn179
	#reach Or derivation
bExpAss_nfjdn178:
	#assigning True to b89
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -356($fp)
	j	bp_label_266
bExpAss_nfjdn179:
	#assigning False to b89
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -356($fp)
	j	bp_label_266
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_266
	#marker Label
bp_label_266:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b89 offset is -356($fp)
	#			 __allocating reg $t0
	lw $t0, -356($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_267
	#marker Label
bp_label_267:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bExpAss_nfjdn180
	j	bp_label_268
	#			 __freeing reg $t2
	#marker Label
bp_label_268:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn180
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn181
	#reach Or derivation
bExpAss_nfjdn180:
	#assigning True to b90
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -360($fp)
	j	bp_label_269
bExpAss_nfjdn181:
	#assigning False to b90
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -360($fp)
	j	bp_label_269
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_269
	#marker Label
bp_label_269:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b90 offset is -360($fp)
	#			 __allocating reg $t0
	lw $t0, -360($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_270
	#marker Label
bp_label_270:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_111
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func True
	bne $t2, $zero,bExpAss_nfjdn182
	j	bp_label_271
	#			 __freeing reg $t2
	#marker Label
bp_label_271:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn182
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn183
	#reach Or derivation
bExpAss_nfjdn182:
	#assigning True to b91
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -364($fp)
	j	bp_label_272
bExpAss_nfjdn183:
	#assigning False to b91
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -364($fp)
	j	bp_label_272
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_272
	#marker Label
bp_label_272:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b91 offset is -364($fp)
	#			 __allocating reg $t0
	lw $t0, -364($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_273
	#marker Label
bp_label_273:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bExpAss_nfjdn184
	#marker Label
bp_label_274:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn184
	j	bExpAss_nfjdn185
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn184:
	#assigning True to b92
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -368($fp)
	j	bp_label_275
bExpAss_nfjdn185:
	#assigning False to b92
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -368($fp)
	j	bp_label_275
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_275
	#marker Label
bp_label_275:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b92 offset is -368($fp)
	#			 __allocating reg $t0
	lw $t0, -368($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_276
	#marker Label
bp_label_276:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bExpAss_nfjdn186
	#marker Label
bp_label_277:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn187
	#reach Or derivation
bExpAss_nfjdn186:
	#assigning True to b93
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -372($fp)
	j	bp_label_278
bExpAss_nfjdn187:
	#assigning False to b93
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -372($fp)
	j	bp_label_278
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_278
	#marker Label
bp_label_278:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b93 offset is -372($fp)
	#			 __allocating reg $t0
	lw $t0, -372($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_279
	#marker Label
bp_label_279:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bExpAss_nfjdn188
	#marker Label
bp_label_280:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn188
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn189
	#reach Or derivation
bExpAss_nfjdn188:
	#assigning True to b94
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -376($fp)
	j	bp_label_281
bExpAss_nfjdn189:
	#assigning False to b94
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -376($fp)
	j	bp_label_281
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_281
	#marker Label
bp_label_281:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b94 offset is -376($fp)
	#			 __allocating reg $t0
	lw $t0, -376($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_282
	#marker Label
bp_label_282:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bExpAss_nfjdn190
	#marker Label
bp_label_283:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn190
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn191
	#reach Or derivation
bExpAss_nfjdn190:
	#assigning True to b95
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -380($fp)
	j	bp_label_284
bExpAss_nfjdn191:
	#assigning False to b95
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -380($fp)
	j	bp_label_284
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_284
	#marker Label
bp_label_284:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b95 offset is -380($fp)
	#			 __allocating reg $t0
	lw $t0, -380($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_285
	#marker Label
bp_label_285:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived true
	#a True exp in boolean operator
	j	bExpAss_nfjdn192
	#marker Label
bp_label_286:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn192
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn193
	#reach Or derivation
bExpAss_nfjdn192:
	#assigning True to b96
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -384($fp)
	j	bp_label_287
bExpAss_nfjdn193:
	#assigning False to b96
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -384($fp)
	j	bp_label_287
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_287
	#marker Label
bp_label_287:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b96 offset is -384($fp)
	#			 __allocating reg $t0
	lw $t0, -384($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_288
	#marker Label
bp_label_288:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn194
	#			 __freeing reg $t2
	#If False
	j	bp_label_289
	#marker Label
bp_label_289:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn194
	j	bExpAss_nfjdn195
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn194:
	#assigning True to b97
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -388($fp)
	j	bp_label_290
bExpAss_nfjdn195:
	#assigning False to b97
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -388($fp)
	j	bp_label_290
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_290
	#marker Label
bp_label_290:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b97 offset is -388($fp)
	#			 __allocating reg $t0
	lw $t0, -388($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_291
	#marker Label
bp_label_291:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn196
	#			 __freeing reg $t2
	#If False
	j	bp_label_292
	#marker Label
bp_label_292:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn197
	#reach Or derivation
bExpAss_nfjdn196:
	#assigning True to b98
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -392($fp)
	j	bp_label_293
bExpAss_nfjdn197:
	#assigning False to b98
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -392($fp)
	j	bp_label_293
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_293
	#marker Label
bp_label_293:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b98 offset is -392($fp)
	#			 __allocating reg $t0
	lw $t0, -392($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_294
	#marker Label
bp_label_294:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn198
	#			 __freeing reg $t2
	#If False
	j	bp_label_295
	#marker Label
bp_label_295:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn198
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn199
	#reach Or derivation
bExpAss_nfjdn198:
	#assigning True to b99
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -396($fp)
	j	bp_label_296
bExpAss_nfjdn199:
	#assigning False to b99
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -396($fp)
	j	bp_label_296
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_296
	#marker Label
bp_label_296:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b99 offset is -396($fp)
	#			 __allocating reg $t0
	lw $t0, -396($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_297
	#marker Label
bp_label_297:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn200
	#			 __freeing reg $t2
	#If False
	j	bp_label_298
	#marker Label
bp_label_298:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn200
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn201
	#reach Or derivation
bExpAss_nfjdn200:
	#assigning True to b100
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -400($fp)
	j	bp_label_299
bExpAss_nfjdn201:
	#assigning False to b100
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -400($fp)
	j	bp_label_299
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_299
	#marker Label
bp_label_299:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b100 offset is -400($fp)
	#			 __allocating reg $t0
	lw $t0, -400($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_300
	#marker Label
bp_label_300:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: t offset is ($fp)
	#			 __allocating reg $t2
	lw $t2, ($fp)
	#a Bool Var t in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn202
	#			 __freeing reg $t2
	#If False
	j	bp_label_301
	#marker Label
bp_label_301:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn202
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn203
	#reach Or derivation
bExpAss_nfjdn202:
	#assigning True to b101
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -404($fp)
	j	bp_label_302
bExpAss_nfjdn203:
	#assigning False to b101
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -404($fp)
	j	bp_label_302
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_302
	#marker Label
bp_label_302:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b101 offset is -404($fp)
	#			 __allocating reg $t0
	lw $t0, -404($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_303
	#marker Label
bp_label_303:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bExpAss_nfjdn204
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_304
	#marker Label
bp_label_304:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn204
	j	bExpAss_nfjdn205
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn204:
	#assigning True to b102
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -408($fp)
	j	bp_label_305
bExpAss_nfjdn205:
	#assigning False to b102
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -408($fp)
	j	bp_label_305
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_305
	#marker Label
bp_label_305:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b102 offset is -408($fp)
	#			 __allocating reg $t0
	lw $t0, -408($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_306
	#marker Label
bp_label_306:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bExpAss_nfjdn206
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_307
	#marker Label
bp_label_307:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn207
	#reach Or derivation
bExpAss_nfjdn206:
	#assigning True to b103
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -412($fp)
	j	bp_label_308
bExpAss_nfjdn207:
	#assigning False to b103
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -412($fp)
	j	bp_label_308
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_308
	#marker Label
bp_label_308:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b103 offset is -412($fp)
	#			 __allocating reg $t0
	lw $t0, -412($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_309
	#marker Label
bp_label_309:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bExpAss_nfjdn208
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_310
	#marker Label
bp_label_310:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn208
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn209
	#reach Or derivation
bExpAss_nfjdn208:
	#assigning True to b104
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -416($fp)
	j	bp_label_311
bExpAss_nfjdn209:
	#assigning False to b104
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -416($fp)
	j	bp_label_311
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_311
	#marker Label
bp_label_311:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b104 offset is -416($fp)
	#			 __allocating reg $t0
	lw $t0, -416($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_312
	#marker Label
bp_label_312:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bExpAss_nfjdn210
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_313
	#marker Label
bp_label_313:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn210
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn211
	#reach Or derivation
bExpAss_nfjdn210:
	#assigning True to b105
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -420($fp)
	j	bp_label_314
bExpAss_nfjdn211:
	#assigning False to b105
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -420($fp)
	j	bp_label_314
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_314
	#marker Label
bp_label_314:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b105 offset is -420($fp)
	#			 __allocating reg $t0
	lw $t0, -420($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_315
	#marker Label
bp_label_315:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	blt $t2, $t3,bExpAss_nfjdn212
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_316
	#marker Label
bp_label_316:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn212
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn213
	#reach Or derivation
bExpAss_nfjdn212:
	#assigning True to b106
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -424($fp)
	j	bp_label_317
bExpAss_nfjdn213:
	#assigning False to b106
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -424($fp)
	j	bp_label_317
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_317
	#marker Label
bp_label_317:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b106 offset is -424($fp)
	#			 __allocating reg $t0
	lw $t0, -424($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_318
	#marker Label
bp_label_318:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bExpAss_nfjdn214
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_319
	#marker Label
bp_label_319:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn214
	j	bExpAss_nfjdn215
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn214:
	#assigning True to b107
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -428($fp)
	j	bp_label_320
bExpAss_nfjdn215:
	#assigning False to b107
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -428($fp)
	j	bp_label_320
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_320
	#marker Label
bp_label_320:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b107 offset is -428($fp)
	#			 __allocating reg $t0
	lw $t0, -428($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_321
	#marker Label
bp_label_321:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bExpAss_nfjdn216
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_322
	#marker Label
bp_label_322:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn217
	#reach Or derivation
bExpAss_nfjdn216:
	#assigning True to b108
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -432($fp)
	j	bp_label_323
bExpAss_nfjdn217:
	#assigning False to b108
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -432($fp)
	j	bp_label_323
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_323
	#marker Label
bp_label_323:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b108 offset is -432($fp)
	#			 __allocating reg $t0
	lw $t0, -432($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_324
	#marker Label
bp_label_324:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bExpAss_nfjdn218
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_325
	#marker Label
bp_label_325:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn218
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn219
	#reach Or derivation
bExpAss_nfjdn218:
	#assigning True to b109
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -436($fp)
	j	bp_label_326
bExpAss_nfjdn219:
	#assigning False to b109
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -436($fp)
	j	bp_label_326
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_326
	#marker Label
bp_label_326:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b109 offset is -436($fp)
	#			 __allocating reg $t0
	lw $t0, -436($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_327
	#marker Label
bp_label_327:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bExpAss_nfjdn220
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_328
	#marker Label
bp_label_328:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn220
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn221
	#reach Or derivation
bExpAss_nfjdn220:
	#assigning True to b110
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -440($fp)
	j	bp_label_329
bExpAss_nfjdn221:
	#assigning False to b110
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -440($fp)
	j	bp_label_329
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_329
	#marker Label
bp_label_329:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b110 offset is -440($fp)
	#			 __allocating reg $t0
	lw $t0, -440($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_330
	#marker Label
bp_label_330:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	beq $t2, $t3,bExpAss_nfjdn222
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_331
	#marker Label
bp_label_331:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn222
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn223
	#reach Or derivation
bExpAss_nfjdn222:
	#assigning True to b111
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -444($fp)
	j	bp_label_332
bExpAss_nfjdn223:
	#assigning False to b111
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -444($fp)
	j	bp_label_332
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_332
	#marker Label
bp_label_332:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b111 offset is -444($fp)
	#			 __allocating reg $t0
	lw $t0, -444($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_333
	#marker Label
bp_label_333:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn224
	j	bp_label_334
	#			 __freeing reg $t2
	#marker Label
bp_label_334:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn224
	j	bExpAss_nfjdn225
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn224:
	#assigning True to b112
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -448($fp)
	j	bp_label_335
bExpAss_nfjdn225:
	#assigning False to b112
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -448($fp)
	j	bp_label_335
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_335
	#marker Label
bp_label_335:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b112 offset is -448($fp)
	#			 __allocating reg $t0
	lw $t0, -448($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_336
	#marker Label
bp_label_336:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn226
	j	bp_label_337
	#			 __freeing reg $t2
	#marker Label
bp_label_337:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn227
	#reach Or derivation
bExpAss_nfjdn226:
	#assigning True to b113
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -452($fp)
	j	bp_label_338
bExpAss_nfjdn227:
	#assigning False to b113
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -452($fp)
	j	bp_label_338
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_338
	#marker Label
bp_label_338:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b113 offset is -452($fp)
	#			 __allocating reg $t0
	lw $t0, -452($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_339
	#marker Label
bp_label_339:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn228
	j	bp_label_340
	#			 __freeing reg $t2
	#marker Label
bp_label_340:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn228
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn229
	#reach Or derivation
bExpAss_nfjdn228:
	#assigning True to b114
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -456($fp)
	j	bp_label_341
bExpAss_nfjdn229:
	#assigning False to b114
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -456($fp)
	j	bp_label_341
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_341
	#marker Label
bp_label_341:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b114 offset is -456($fp)
	#			 __allocating reg $t0
	lw $t0, -456($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_342
	#marker Label
bp_label_342:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn230
	j	bp_label_343
	#			 __freeing reg $t2
	#marker Label
bp_label_343:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn230
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn231
	#reach Or derivation
bExpAss_nfjdn230:
	#assigning True to b115
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -460($fp)
	j	bp_label_344
bExpAss_nfjdn231:
	#assigning False to b115
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -460($fp)
	j	bp_label_344
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_344
	#marker Label
bp_label_344:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b115 offset is -460($fp)
	#			 __allocating reg $t0
	lw $t0, -460($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_345
	#marker Label
bp_label_345:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn232
	j	bp_label_346
	#			 __freeing reg $t2
	#marker Label
bp_label_346:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn232
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn233
	#reach Or derivation
bExpAss_nfjdn232:
	#assigning True to b116
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -464($fp)
	j	bp_label_347
bExpAss_nfjdn233:
	#assigning False to b116
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -464($fp)
	j	bp_label_347
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_347
	#marker Label
bp_label_347:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b116 offset is -464($fp)
	#			 __allocating reg $t0
	lw $t0, -464($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_348
	#marker Label
bp_label_348:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_349
	#marker Label
bp_label_349:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn234
	j	bExpAss_nfjdn235
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn234:
	#assigning True to b117
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -468($fp)
	j	bp_label_350
bExpAss_nfjdn235:
	#assigning False to b117
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -468($fp)
	j	bp_label_350
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_350
	#marker Label
bp_label_350:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b117 offset is -468($fp)
	#			 __allocating reg $t0
	lw $t0, -468($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_351
	#marker Label
bp_label_351:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_352
	#marker Label
bp_label_352:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn237
	#reach Or derivation
bExpAss_nfjdn236:
	#assigning True to b118
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -472($fp)
	j	bp_label_353
bExpAss_nfjdn237:
	#assigning False to b118
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -472($fp)
	j	bp_label_353
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_353
	#marker Label
bp_label_353:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b118 offset is -472($fp)
	#			 __allocating reg $t0
	lw $t0, -472($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_354
	#marker Label
bp_label_354:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_355
	#marker Label
bp_label_355:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn238
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn239
	#reach Or derivation
bExpAss_nfjdn238:
	#assigning True to b119
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -476($fp)
	j	bp_label_356
bExpAss_nfjdn239:
	#assigning False to b119
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -476($fp)
	j	bp_label_356
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_356
	#marker Label
bp_label_356:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b119 offset is -476($fp)
	#			 __allocating reg $t0
	lw $t0, -476($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_357
	#marker Label
bp_label_357:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_358
	#marker Label
bp_label_358:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn240
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn241
	#reach Or derivation
bExpAss_nfjdn240:
	#assigning True to b120
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -480($fp)
	j	bp_label_359
bExpAss_nfjdn241:
	#assigning False to b120
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -480($fp)
	j	bp_label_359
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_359
	#marker Label
bp_label_359:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b120 offset is -480($fp)
	#			 __allocating reg $t0
	lw $t0, -480($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_360
	#marker Label
bp_label_360:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_361
	#marker Label
bp_label_361:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn242
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn243
	#reach Or derivation
bExpAss_nfjdn242:
	#assigning True to b121
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -484($fp)
	j	bp_label_362
bExpAss_nfjdn243:
	#assigning False to b121
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -484($fp)
	j	bp_label_362
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_362
	#marker Label
bp_label_362:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b121 offset is -484($fp)
	#			 __allocating reg $t0
	lw $t0, -484($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_363
	#marker Label
bp_label_363:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn244
	#			 __freeing reg $t2
	#If False
	j	bp_label_364
	#marker Label
bp_label_364:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn244
	j	bExpAss_nfjdn245
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn244:
	#assigning True to b122
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -488($fp)
	j	bp_label_365
bExpAss_nfjdn245:
	#assigning False to b122
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -488($fp)
	j	bp_label_365
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_365
	#marker Label
bp_label_365:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b122 offset is -488($fp)
	#			 __allocating reg $t0
	lw $t0, -488($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_366
	#marker Label
bp_label_366:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn246
	#			 __freeing reg $t2
	#If False
	j	bp_label_367
	#marker Label
bp_label_367:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn247
	#reach Or derivation
bExpAss_nfjdn246:
	#assigning True to b123
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -492($fp)
	j	bp_label_368
bExpAss_nfjdn247:
	#assigning False to b123
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -492($fp)
	j	bp_label_368
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_368
	#marker Label
bp_label_368:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b123 offset is -492($fp)
	#			 __allocating reg $t0
	lw $t0, -492($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_369
	#marker Label
bp_label_369:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn248
	#			 __freeing reg $t2
	#If False
	j	bp_label_370
	#marker Label
bp_label_370:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn248
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn249
	#reach Or derivation
bExpAss_nfjdn248:
	#assigning True to b124
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -496($fp)
	j	bp_label_371
bExpAss_nfjdn249:
	#assigning False to b124
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -496($fp)
	j	bp_label_371
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_371
	#marker Label
bp_label_371:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b124 offset is -496($fp)
	#			 __allocating reg $t0
	lw $t0, -496($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_372
	#marker Label
bp_label_372:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn250
	#			 __freeing reg $t2
	#If False
	j	bp_label_373
	#marker Label
bp_label_373:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn250
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn251
	#reach Or derivation
bExpAss_nfjdn250:
	#assigning True to b125
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -500($fp)
	j	bp_label_374
bExpAss_nfjdn251:
	#assigning False to b125
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -500($fp)
	j	bp_label_374
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_374
	#marker Label
bp_label_374:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b125 offset is -500($fp)
	#			 __allocating reg $t0
	lw $t0, -500($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_375
	#marker Label
bp_label_375:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn252
	#			 __freeing reg $t2
	#If False
	j	bp_label_376
	#marker Label
bp_label_376:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn252
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn253
	#reach Or derivation
bExpAss_nfjdn252:
	#assigning True to b126
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -504($fp)
	j	bp_label_377
bExpAss_nfjdn253:
	#assigning False to b126
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -504($fp)
	j	bp_label_377
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_377
	#marker Label
bp_label_377:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b126 offset is -504($fp)
	#			 __allocating reg $t0
	lw $t0, -504($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_378
	#marker Label
bp_label_378:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn254
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_379
	#marker Label
bp_label_379:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn254
	j	bExpAss_nfjdn255
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn254:
	#assigning True to b127
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -508($fp)
	j	bp_label_380
bExpAss_nfjdn255:
	#assigning False to b127
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -508($fp)
	j	bp_label_380
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_380
	#marker Label
bp_label_380:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b127 offset is -508($fp)
	#			 __allocating reg $t0
	lw $t0, -508($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_381
	#marker Label
bp_label_381:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn256
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_382
	#marker Label
bp_label_382:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn257
	#reach Or derivation
bExpAss_nfjdn256:
	#assigning True to b128
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -512($fp)
	j	bp_label_383
bExpAss_nfjdn257:
	#assigning False to b128
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -512($fp)
	j	bp_label_383
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_383
	#marker Label
bp_label_383:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b128 offset is -512($fp)
	#			 __allocating reg $t0
	lw $t0, -512($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_384
	#marker Label
bp_label_384:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn258
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_385
	#marker Label
bp_label_385:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn258
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn259
	#reach Or derivation
bExpAss_nfjdn258:
	#assigning True to b129
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -516($fp)
	j	bp_label_386
bExpAss_nfjdn259:
	#assigning False to b129
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -516($fp)
	j	bp_label_386
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_386
	#marker Label
bp_label_386:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b129 offset is -516($fp)
	#			 __allocating reg $t0
	lw $t0, -516($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_387
	#marker Label
bp_label_387:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn260
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_388
	#marker Label
bp_label_388:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn260
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn261
	#reach Or derivation
bExpAss_nfjdn260:
	#assigning True to b130
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -520($fp)
	j	bp_label_389
bExpAss_nfjdn261:
	#assigning False to b130
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -520($fp)
	j	bp_label_389
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_389
	#marker Label
bp_label_389:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b130 offset is -520($fp)
	#			 __allocating reg $t0
	lw $t0, -520($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_390
	#marker Label
bp_label_390:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn262
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_391
	#marker Label
bp_label_391:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn262
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn263
	#reach Or derivation
bExpAss_nfjdn262:
	#assigning True to b131
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -524($fp)
	j	bp_label_392
bExpAss_nfjdn263:
	#assigning False to b131
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -524($fp)
	j	bp_label_392
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_392
	#marker Label
bp_label_392:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b131 offset is -524($fp)
	#			 __allocating reg $t0
	lw $t0, -524($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_393
	#marker Label
bp_label_393:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn264
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_394
	#marker Label
bp_label_394:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn264
	j	bExpAss_nfjdn265
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn264:
	#assigning True to b132
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -528($fp)
	j	bp_label_395
bExpAss_nfjdn265:
	#assigning False to b132
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -528($fp)
	j	bp_label_395
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_395
	#marker Label
bp_label_395:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b132 offset is -528($fp)
	#			 __allocating reg $t0
	lw $t0, -528($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_396
	#marker Label
bp_label_396:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn266
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_397
	#marker Label
bp_label_397:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn267
	#reach Or derivation
bExpAss_nfjdn266:
	#assigning True to b133
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -532($fp)
	j	bp_label_398
bExpAss_nfjdn267:
	#assigning False to b133
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -532($fp)
	j	bp_label_398
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_398
	#marker Label
bp_label_398:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b133 offset is -532($fp)
	#			 __allocating reg $t0
	lw $t0, -532($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_399
	#marker Label
bp_label_399:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn268
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_400
	#marker Label
bp_label_400:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn268
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn269
	#reach Or derivation
bExpAss_nfjdn268:
	#assigning True to b134
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -536($fp)
	j	bp_label_401
bExpAss_nfjdn269:
	#assigning False to b134
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -536($fp)
	j	bp_label_401
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_401
	#marker Label
bp_label_401:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b134 offset is -536($fp)
	#			 __allocating reg $t0
	lw $t0, -536($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_402
	#marker Label
bp_label_402:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn270
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_403
	#marker Label
bp_label_403:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn270
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn271
	#reach Or derivation
bExpAss_nfjdn270:
	#assigning True to b135
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -540($fp)
	j	bp_label_404
bExpAss_nfjdn271:
	#assigning False to b135
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -540($fp)
	j	bp_label_404
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_404
	#marker Label
bp_label_404:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b135 offset is -540($fp)
	#			 __allocating reg $t0
	lw $t0, -540($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_405
	#marker Label
bp_label_405:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn272
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_406
	#marker Label
bp_label_406:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn272
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn273
	#reach Or derivation
bExpAss_nfjdn272:
	#assigning True to b136
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -544($fp)
	j	bp_label_407
bExpAss_nfjdn273:
	#assigning False to b136
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -544($fp)
	j	bp_label_407
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_407
	#marker Label
bp_label_407:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b136 offset is -544($fp)
	#			 __allocating reg $t0
	lw $t0, -544($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_408
	#marker Label
bp_label_408:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn274
	j	bp_label_409
	#			 __freeing reg $t2
	#marker Label
bp_label_409:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn274
	j	bExpAss_nfjdn275
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn274:
	#assigning True to b137
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -548($fp)
	j	bp_label_410
bExpAss_nfjdn275:
	#assigning False to b137
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -548($fp)
	j	bp_label_410
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_410
	#marker Label
bp_label_410:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b137 offset is -548($fp)
	#			 __allocating reg $t0
	lw $t0, -548($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_411
	#marker Label
bp_label_411:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn276
	j	bp_label_412
	#			 __freeing reg $t2
	#marker Label
bp_label_412:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn277
	#reach Or derivation
bExpAss_nfjdn276:
	#assigning True to b138
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -552($fp)
	j	bp_label_413
bExpAss_nfjdn277:
	#assigning False to b138
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -552($fp)
	j	bp_label_413
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_413
	#marker Label
bp_label_413:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b138 offset is -552($fp)
	#			 __allocating reg $t0
	lw $t0, -552($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_414
	#marker Label
bp_label_414:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn278
	j	bp_label_415
	#			 __freeing reg $t2
	#marker Label
bp_label_415:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn278
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn279
	#reach Or derivation
bExpAss_nfjdn278:
	#assigning True to b139
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -556($fp)
	j	bp_label_416
bExpAss_nfjdn279:
	#assigning False to b139
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -556($fp)
	j	bp_label_416
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_416
	#marker Label
bp_label_416:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b139 offset is -556($fp)
	#			 __allocating reg $t0
	lw $t0, -556($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_417
	#marker Label
bp_label_417:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn280
	j	bp_label_418
	#			 __freeing reg $t2
	#marker Label
bp_label_418:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn280
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn281
	#reach Or derivation
bExpAss_nfjdn280:
	#assigning True to b140
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -560($fp)
	j	bp_label_419
bExpAss_nfjdn281:
	#assigning False to b140
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -560($fp)
	j	bp_label_419
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_419
	#marker Label
bp_label_419:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b140 offset is -560($fp)
	#			 __allocating reg $t0
	lw $t0, -560($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_420
	#marker Label
bp_label_420:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn282
	j	bp_label_421
	#			 __freeing reg $t2
	#marker Label
bp_label_421:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn282
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn283
	#reach Or derivation
bExpAss_nfjdn282:
	#assigning True to b141
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -564($fp)
	j	bp_label_422
bExpAss_nfjdn283:
	#assigning False to b141
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -564($fp)
	j	bp_label_422
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_422
	#marker Label
bp_label_422:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b141 offset is -564($fp)
	#			 __allocating reg $t0
	lw $t0, -564($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_423
	#marker Label
bp_label_423:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_424
	#marker Label
bp_label_424:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn284
	j	bExpAss_nfjdn285
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn284:
	#assigning True to b142
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -568($fp)
	j	bp_label_425
bExpAss_nfjdn285:
	#assigning False to b142
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -568($fp)
	j	bp_label_425
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_425
	#marker Label
bp_label_425:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b142 offset is -568($fp)
	#			 __allocating reg $t0
	lw $t0, -568($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_426
	#marker Label
bp_label_426:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_427
	#marker Label
bp_label_427:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn287
	#reach Or derivation
bExpAss_nfjdn286:
	#assigning True to b143
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -572($fp)
	j	bp_label_428
bExpAss_nfjdn287:
	#assigning False to b143
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -572($fp)
	j	bp_label_428
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_428
	#marker Label
bp_label_428:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b143 offset is -572($fp)
	#			 __allocating reg $t0
	lw $t0, -572($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_429
	#marker Label
bp_label_429:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_430
	#marker Label
bp_label_430:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn288
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn289
	#reach Or derivation
bExpAss_nfjdn288:
	#assigning True to b144
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -576($fp)
	j	bp_label_431
bExpAss_nfjdn289:
	#assigning False to b144
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -576($fp)
	j	bp_label_431
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_431
	#marker Label
bp_label_431:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b144 offset is -576($fp)
	#			 __allocating reg $t0
	lw $t0, -576($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_432
	#marker Label
bp_label_432:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_433
	#marker Label
bp_label_433:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn290
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn291
	#reach Or derivation
bExpAss_nfjdn290:
	#assigning True to b145
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -580($fp)
	j	bp_label_434
bExpAss_nfjdn291:
	#assigning False to b145
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -580($fp)
	j	bp_label_434
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_434
	#marker Label
bp_label_434:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b145 offset is -580($fp)
	#			 __allocating reg $t0
	lw $t0, -580($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_435
	#marker Label
bp_label_435:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#exp derived false
	#a False exp in boolean operator
	j	bp_label_436
	#marker Label
bp_label_436:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn292
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn293
	#reach Or derivation
bExpAss_nfjdn292:
	#assigning True to b146
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -584($fp)
	j	bp_label_437
bExpAss_nfjdn293:
	#assigning False to b146
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -584($fp)
	j	bp_label_437
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_437
	#marker Label
bp_label_437:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b146 offset is -584($fp)
	#			 __allocating reg $t0
	lw $t0, -584($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_438
	#marker Label
bp_label_438:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn294
	#			 __freeing reg $t2
	#If False
	j	bp_label_439
	#marker Label
bp_label_439:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn294
	j	bExpAss_nfjdn295
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn294:
	#assigning True to b147
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -588($fp)
	j	bp_label_440
bExpAss_nfjdn295:
	#assigning False to b147
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -588($fp)
	j	bp_label_440
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_440
	#marker Label
bp_label_440:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b147 offset is -588($fp)
	#			 __allocating reg $t0
	lw $t0, -588($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_441
	#marker Label
bp_label_441:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn296
	#			 __freeing reg $t2
	#If False
	j	bp_label_442
	#marker Label
bp_label_442:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn297
	#reach Or derivation
bExpAss_nfjdn296:
	#assigning True to b148
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -592($fp)
	j	bp_label_443
bExpAss_nfjdn297:
	#assigning False to b148
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -592($fp)
	j	bp_label_443
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_443
	#marker Label
bp_label_443:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b148 offset is -592($fp)
	#			 __allocating reg $t0
	lw $t0, -592($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_444
	#marker Label
bp_label_444:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn298
	#			 __freeing reg $t2
	#If False
	j	bp_label_445
	#marker Label
bp_label_445:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn298
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn299
	#reach Or derivation
bExpAss_nfjdn298:
	#assigning True to b149
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -596($fp)
	j	bp_label_446
bExpAss_nfjdn299:
	#assigning False to b149
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -596($fp)
	j	bp_label_446
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_446
	#marker Label
bp_label_446:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b149 offset is -596($fp)
	#			 __allocating reg $t0
	lw $t0, -596($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_447
	#marker Label
bp_label_447:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn300
	#			 __freeing reg $t2
	#If False
	j	bp_label_448
	#marker Label
bp_label_448:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn300
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn301
	#reach Or derivation
bExpAss_nfjdn300:
	#assigning True to b150
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -600($fp)
	j	bp_label_449
bExpAss_nfjdn301:
	#assigning False to b150
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -600($fp)
	j	bp_label_449
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_449
	#marker Label
bp_label_449:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b150 offset is -600($fp)
	#			 __allocating reg $t0
	lw $t0, -600($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_450
	#marker Label
bp_label_450:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn302
	#			 __freeing reg $t2
	#If False
	j	bp_label_451
	#marker Label
bp_label_451:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn302
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn303
	#reach Or derivation
bExpAss_nfjdn302:
	#assigning True to b151
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -604($fp)
	j	bp_label_452
bExpAss_nfjdn303:
	#assigning False to b151
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -604($fp)
	j	bp_label_452
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_452
	#marker Label
bp_label_452:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b151 offset is -604($fp)
	#			 __allocating reg $t0
	lw $t0, -604($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_453
	#marker Label
bp_label_453:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn304
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_454
	#marker Label
bp_label_454:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn304
	j	bExpAss_nfjdn305
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn304:
	#assigning True to b152
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -608($fp)
	j	bp_label_455
bExpAss_nfjdn305:
	#assigning False to b152
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -608($fp)
	j	bp_label_455
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_455
	#marker Label
bp_label_455:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b152 offset is -608($fp)
	#			 __allocating reg $t0
	lw $t0, -608($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_456
	#marker Label
bp_label_456:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn306
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_457
	#marker Label
bp_label_457:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn307
	#reach Or derivation
bExpAss_nfjdn306:
	#assigning True to b153
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -612($fp)
	j	bp_label_458
bExpAss_nfjdn307:
	#assigning False to b153
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -612($fp)
	j	bp_label_458
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_458
	#marker Label
bp_label_458:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b153 offset is -612($fp)
	#			 __allocating reg $t0
	lw $t0, -612($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_459
	#marker Label
bp_label_459:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn308
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_460
	#marker Label
bp_label_460:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn308
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn309
	#reach Or derivation
bExpAss_nfjdn308:
	#assigning True to b154
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -616($fp)
	j	bp_label_461
bExpAss_nfjdn309:
	#assigning False to b154
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -616($fp)
	j	bp_label_461
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_461
	#marker Label
bp_label_461:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b154 offset is -616($fp)
	#			 __allocating reg $t0
	lw $t0, -616($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_462
	#marker Label
bp_label_462:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn310
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_463
	#marker Label
bp_label_463:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn310
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn311
	#reach Or derivation
bExpAss_nfjdn310:
	#assigning True to b155
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -620($fp)
	j	bp_label_464
bExpAss_nfjdn311:
	#assigning False to b155
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -620($fp)
	j	bp_label_464
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_464
	#marker Label
bp_label_464:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b155 offset is -620($fp)
	#			 __allocating reg $t0
	lw $t0, -620($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_465
	#marker Label
bp_label_465:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn312
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_466
	#marker Label
bp_label_466:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn312
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn313
	#reach Or derivation
bExpAss_nfjdn312:
	#assigning True to b156
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -624($fp)
	j	bp_label_467
bExpAss_nfjdn313:
	#assigning False to b156
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -624($fp)
	j	bp_label_467
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_467
	#marker Label
bp_label_467:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b156 offset is -624($fp)
	#			 __allocating reg $t0
	lw $t0, -624($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_468
	#marker Label
bp_label_468:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn314
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_469
	#marker Label
bp_label_469:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	move	$fp,$sp
	jal	label_132
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#moving return value to new reg
	#			 __allocating reg $t2
	move	$t2,$v0
	#a Bool Func False
	bne $t2, $zero,bExpAss_nfjdn314
	j	bExpAss_nfjdn315
	#			 __freeing reg $t2
	#reach Or derivation
bExpAss_nfjdn314:
	#assigning True to b157
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -628($fp)
	j	bp_label_470
bExpAss_nfjdn315:
	#assigning False to b157
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -628($fp)
	j	bp_label_470
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_470
	#marker Label
bp_label_470:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b157 offset is -628($fp)
	#			 __allocating reg $t0
	lw $t0, -628($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_471
	#marker Label
bp_label_471:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn316
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_472
	#marker Label
bp_label_472:
	#exp derived false
	#a False exp in boolean operator
	j	bExpAss_nfjdn317
	#reach Or derivation
bExpAss_nfjdn316:
	#assigning True to b158
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -632($fp)
	j	bp_label_473
bExpAss_nfjdn317:
	#assigning False to b158
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -632($fp)
	j	bp_label_473
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_473
	#marker Label
bp_label_473:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b158 offset is -632($fp)
	#			 __allocating reg $t0
	lw $t0, -632($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_474
	#marker Label
bp_label_474:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn318
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_475
	#marker Label
bp_label_475:
	#Getting Var falue for [Exp->id]: f offset is -4($fp)
	#			 __allocating reg $t2
	lw $t2, -4($fp)
	#a Bool Var f in boolean operator
	#If true
	bne $t2, $zero,bExpAss_nfjdn318
	#			 __freeing reg $t2
	#If False
	j	bExpAss_nfjdn319
	#reach Or derivation
bExpAss_nfjdn318:
	#assigning True to b159
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -636($fp)
	j	bp_label_476
bExpAss_nfjdn319:
	#assigning False to b159
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -636($fp)
	j	bp_label_476
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_476
	#marker Label
bp_label_476:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b159 offset is -636($fp)
	#			 __allocating reg $t0
	lw $t0, -636($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_477
	#marker Label
bp_label_477:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn320
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_478
	#marker Label
bp_label_478:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,5
	bgt $t2, $t3,bExpAss_nfjdn320
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn321
	#reach Or derivation
bExpAss_nfjdn320:
	#assigning True to b160
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -640($fp)
	j	bp_label_479
bExpAss_nfjdn321:
	#assigning False to b160
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -640($fp)
	j	bp_label_479
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_479
	#marker Label
bp_label_479:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b160 offset is -640($fp)
	#			 __allocating reg $t0
	lw $t0, -640($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_480
	#marker Label
bp_label_480:
	#preparing for new var
	#allocationg words on stack 
	addiu $sp, $sp, -4
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn322
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bp_label_481
	#marker Label
bp_label_481:
	#			 __allocating reg $t2
	li	$t2,4
	#			 __allocating reg $t3
	li	$t3,4
	bne $t2, $t3,bExpAss_nfjdn322
	#			 __freeing reg $t3
	#			 __freeing reg $t2
	j	bExpAss_nfjdn323
	#reach Or derivation
bExpAss_nfjdn322:
	#assigning True to b161
	#			 __allocating reg $t2
	li	$t2,1
	sw $t2, -644($fp)
	j	bp_label_482
bExpAss_nfjdn323:
	#assigning False to b161
	#			 __allocating reg $t2
	li	$t2,0
	sw $t2, -644($fp)
	j	bp_label_482
	#			 __freeing reg $t2
	#end of statement jump
	j	bp_label_482
	#marker Label
bp_label_482:
	#func header store regs before call
	sw $t1, ($sp)
	addiu $sp, $sp, -4
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#stored 2 registers
	#Getting Var falue for [Exp->id]: b161 offset is -644($fp)
	#			 __allocating reg $t0
	lw $t0, -644($fp)
	#preparing to call printBool
	sw $fp, ($sp)
	addiu $sp, $sp, -4
	sw $ra, ($sp)
	addiu $sp, $sp, -4
	#pushing reg $t0 to stack
	sw $t0, ($sp)
	addiu $sp, $sp, -4
	#			 __freeing reg $t0
	move	$fp,$sp
	#jumping to func: printBool
	jal	label_29
	#returned from func: printBool
	#poping 1 params from stack 
	addiu $sp, $sp, 4
	#restoring ra and fp
	addiu $sp, $sp, 4
	lw $ra, ($sp)
	addiu $sp, $sp, 4
	lw $fp, ($sp)
	#restoring 2 previously used registers
	addiu $sp, $sp, 4
	lw $t0, ($sp)
	addiu $sp, $sp, 4
	lw $t1, ($sp)
	#Moving funcRes (if exists) to next free register
	#finished calling printBool
	#end of statement jump
	j	bp_label_483
bp_label_483:
	#Adding an extre return just in case
	#restting sp
	move	$sp,$fp
	#for this extra return, we zero v0
	move	$v0,$zero
	jr	$ra
