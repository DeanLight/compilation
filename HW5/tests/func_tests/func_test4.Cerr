[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__f__
Lex Ate token  (__
Lex Ate token bool__
Lex Ate token  id__cond__
<<FormalDecl_Semantic: id[cond]>>
<<adding param: [cond] of type [5]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[f]>>
[[[ added func: f with 1 params and label: ]]]
FuncHead_IR for func: f
got label label_29 in line: -1
[set_func_label] label label_29 for function f
[get_func_label] f's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__cond__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[cond]>>
[Exp_IR] Exp -> id: cond
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: cond
[MARKER IR]: label: bp_label_0
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"boy\n"__
[Exp_IR] Exp -> string"boy\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  id__f__
[MARKER IR]: label: bp_label_1
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token false__
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : false
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: false
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments f
[get_func_label] f's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_1 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_2
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"girl\n"__
[Exp_IR] Exp -> string"girl\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: f
If void, an extra ret will be added
Ret type: 1
Lex Ate token bool__
Lex Ate token  id__g__
Lex Ate token  (__
Lex Ate token bool__
Lex Ate token  id__gen__
<<FormalDecl_Semantic: id[gen]>>
<<adding param: [gen] of type [5]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[g]>>
[[[ added func: g with 1 params and label: ]]]
FuncHead_IR for func: g
got label label_135 in line: -1
[set_func_label] label label_135 for function g
[get_func_label] g's label is: label_135
written label: label_135
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__gen__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[gen]>>
[Exp_IR] Exp -> id: gen
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: gen
[MARKER IR]: label: bp_label_5
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"M "__
[Exp_IR] Exp -> string"M "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token return__
[MARKER IR]: label: bp_label_6
Lex Ate token true__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_6 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_7
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"F "__
[Exp_IR] Exp -> string"F "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token return__
[MARKER IR]: label: bp_label_8
Lex Ate token false__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_8 breaklist size is 0
Lex Ate token  }__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: g
If void, an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_224 in line: -1
[set_func_label] label label_224 for function main
Saving main label: label_224
[get_func_label] main's label is: label_224
written label: label_224
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"apple \n"__
[Exp_IR] Exp -> string"apple \n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  id__f__
[MARKER IR]: label: bp_label_11
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__g__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token true__
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : true
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: true
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments g
[get_func_label] g's label is: label_135
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callg
[Exp_IR] endof Exp->callg
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : g
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: g
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments f
[get_func_label] f's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_11 breaklist size is 0
Lex Ate token  id__f__
[MARKER IR]: label: bp_label_15
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__g__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token false__
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : false
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: false
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments g
[get_func_label] g's label is: label_135
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callg
[Exp_IR] endof Exp->callg
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : g
exp is of type BOOL
[ExpList_IR: ExpList->Exp]: g
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments f
[get_func_label] f's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_IR Call] nestlistSize: 0
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_15 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
If void, an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with [get_func_label] main's label is: label_224
label_224
[get_func_label] main's label is: label_224
ignore me1 (label_224)
[END_OF Program_IR]
