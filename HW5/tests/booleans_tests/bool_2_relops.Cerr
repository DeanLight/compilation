[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_29 in line: -1
[set_func_label] label label_29 for function main
[get_func_label] main's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__big__
Lex Ate token  =__
Lex Ate token  num__100__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:100
[get_func_label] main's label is: label_29
{{{{ NOT RELEVANT:label_29}}}}
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[big]type:[]>>
<<adding var: [big] of type [3]>><<Statement_Semantic with id[big]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token int__
[MARKER IR]: label: bp_label_0
Lex Ate token  id__big2__
Lex Ate token  =__
Lex Ate token  num__100__
Lex Ate token B__
<<[Exp_Semantic] B:[100]>>
[Exp_IR] Exp -> Num B
[Exp_IR] Exp -> Num:100
[get_func_label] main's label is: label_29
{{{{ NOT RELEVANT:label_29}}}}
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[big2]type:[]>>
<<adding var: [big2] of type [3]>><<Statement_Semantic with id[big2]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_0
Lex Ate token byte__
[MARKER IR]: label: bp_label_1
Lex Ate token  id__small__
Lex Ate token  =__
Lex Ate token  num__6__
Lex Ate token B__
<<[Exp_Semantic] B:[6]>>
[Exp_IR] Exp -> Num B
[Exp_IR] Exp -> Num:6
[get_func_label] main's label is: label_29
{{{{ NOT RELEVANT:label_29}}}}
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[small]type:[]>>
<<adding var: [small] of type [4]>><<Statement_Semantic with id[small]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_1
Lex Ate token byte__
[MARKER IR]: label: bp_label_2
Lex Ate token  id__small2__
Lex Ate token  =__
Lex Ate token  id__small__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
<<[Statement_Semantic][TypeID_SC] id:[small2]type:[]>>
<<adding var: [small2] of type [4]>><<Statement_Semantic with id[small2]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_2
Lex Ate comment:// ==: true true false false

Lex Ate token if__
[MARKER IR]: label: bp_label_3
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[MARKER IR]: label: bp_label_4
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_5
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_3
Lex Ate token if__
[MARKER IR]: label: bp_label_7
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[MARKER IR]: label: bp_label_8
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_9
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_7
Lex Ate token if__
[MARKER IR]: label: bp_label_11
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[MARKER IR]: label: bp_label_12
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_13
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_11
Lex Ate token if__
[MARKER IR]: label: bp_label_15
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[MARKER IR]: label: bp_label_16
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_17
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_15
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_19
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_19
Lex Ate comment:// !=: false false true true

Lex Ate token if__
[MARKER IR]: label: bp_label_20
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[MARKER IR]: label: bp_label_21
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_22
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_20
Lex Ate token if__
[MARKER IR]: label: bp_label_24
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[MARKER IR]: label: bp_label_25
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_26
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_24
Lex Ate token if__
[MARKER IR]: label: bp_label_28
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[MARKER IR]: label: bp_label_29
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_30
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_28
Lex Ate token if__
[MARKER IR]: label: bp_label_32
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[MARKER IR]: label: bp_label_33
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_34
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_32
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_36
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_36
Lex Ate comment:// <: false false false true

Lex Ate token if__
[MARKER IR]: label: bp_label_37
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[MARKER IR]: label: bp_label_38
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_39
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_37
Lex Ate token if__
[MARKER IR]: label: bp_label_41
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[MARKER IR]: label: bp_label_42
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_43
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_41
Lex Ate token if__
[MARKER IR]: label: bp_label_45
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[MARKER IR]: label: bp_label_46
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_47
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_45
Lex Ate token if__
[MARKER IR]: label: bp_label_49
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[MARKER IR]: label: bp_label_50
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_51
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_49
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_53
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_53
Lex Ate comment:// <=: true true false true

Lex Ate token if__
[MARKER IR]: label: bp_label_54
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[MARKER IR]: label: bp_label_55
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_56
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_54
Lex Ate token if__
[MARKER IR]: label: bp_label_58
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[MARKER IR]: label: bp_label_59
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_60
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_58
Lex Ate token if__
[MARKER IR]: label: bp_label_62
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[MARKER IR]: label: bp_label_63
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_64
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_62
Lex Ate token if__
[MARKER IR]: label: bp_label_66
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[MARKER IR]: label: bp_label_67
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_68
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_66
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_70
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_70
Lex Ate comment:// >: false false true false

Lex Ate token if__
[MARKER IR]: label: bp_label_71
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[MARKER IR]: label: bp_label_72
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_73
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_71
Lex Ate token if__
[MARKER IR]: label: bp_label_75
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[MARKER IR]: label: bp_label_76
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_77
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_75
Lex Ate token if__
[MARKER IR]: label: bp_label_79
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[MARKER IR]: label: bp_label_80
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_81
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_79
Lex Ate token if__
[MARKER IR]: label: bp_label_83
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[MARKER IR]: label: bp_label_84
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_85
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_83
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_87
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_87
Lex Ate comment:// >=: true true true false

Lex Ate token if__
[MARKER IR]: label: bp_label_88
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__>=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big2]>>
[Exp_IR] Exp -> id: big2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 >= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 >= Exp2
[MARKER IR]: label: bp_label_89
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_90
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_88
Lex Ate token if__
[MARKER IR]: label: bp_label_92
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__>=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small2__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small2]>>
[Exp_IR] Exp -> id: small2
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 >= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 >= Exp2
[MARKER IR]: label: bp_label_93
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_94
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_92
Lex Ate token if__
[MARKER IR]: label: bp_label_96
Lex Ate token  (__
Lex Ate token  id__big__
Lex Ate token  RelOp__>=__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__small__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 >= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 >= Exp2
[MARKER IR]: label: bp_label_97
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_98
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_96
Lex Ate token if__
[MARKER IR]: label: bp_label_100
Lex Ate token  (__
Lex Ate token  id__small__
Lex Ate token  RelOp__>=__
<<[Exp_Semantic_Id] id:[small]>>
[Exp_IR] Exp -> id: small
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__big__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[big]>>
[Exp_IR] Exp -> id: big
END_OF [Exp_IR] Exp -> id
[Exp_IR]:Relop Exp -> Exp1 >= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 >= Exp2
[MARKER IR]: label: bp_label_101
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"true\t"__
[Exp_IR] Exp -> string"true\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_102
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"false\t"__
[Exp_IR] Exp -> string"false\t"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_100
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_104
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_104
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
If void, an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with [get_func_label] main's label is: label_29
label_29
[get_func_label] main's label is: label_29
ignore me1 (label_29)
[END_OF Program_IR]
