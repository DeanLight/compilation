[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_29 in line: -1
[set_func_label] label label_29 for function main
[get_func_label] main's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__x__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[x]type:[]>>
<<adding var: [x] of type [3]>>[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_0
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp
exp is of type INT
[ExpList_IR: ExpList->Exp]: x
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 0 with label: bp_label_0 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_1
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__":\n"__
[Exp_IR] Exp -> string":\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_1 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_2
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_3
Lex Ate token case__
Lex Ate token  num__1__
Lex Ate token  :__
Lex Ate token case__
[MARKER IR]: label: bp_label_4
Lex Ate token  num__3__
Lex Ate token  :__
Lex Ate token break__
Lex Ate token  ;__
 new breakcommand at 106 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_5
Lex Ate token  num__0__
Lex Ate token  :__
Lex Ate token default__
[MARKER IR]: label: bp_label_6
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"default\n"__
[Exp_IR] Exp -> string"default\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 1
ERROR: Reg not given yet. req:0 while max used is 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_7
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  num__2__
Lex Ate token )__
[Exp_IR] Exp -> Num:2
[get_func_label] main's label is: label_29
{{{{ NOT RELEVANT:label_29}}}}
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
ERROR: Reg not given yet. req:0 while max used is 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_8
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 1
ERROR: Reg not given yet. req:0 while max used is 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_8 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  5
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
in normal case number1
after else state 11
after else state 21
in normal case number2
after else state 12
after else state 22
foudn default in i =3
in normal case number4
after else state 14
after else state 24
before backpatching case nextlists
backpatching nextlist  0
skipped empty case 0
backpatching nextlist  1
 size of STvec->nextlist is 1
backpatching nextlist  2
 size of STvec->nextlist is 0
backpatching nextlist  3
 size of STvec->nextlist is 1
before backpatching case breaklists
skipped empty case in breaking 0outof 4
reached non empty case in breaking 1outof 4 its breaklist is of size 1
reached non empty case in breaking 2outof 4 its breaklist is of size 4
reached non empty case in breaking 3outof 4 its breaklist is of size 0
reached non empty case in breaking 4outof 4 its breaklist is of size 0
