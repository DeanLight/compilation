[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_29 in line: -1
[set_func_label] label label_29 for function main
[get_func_label] main's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__x__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[x]type:[]>>
<<adding var: [x] of type [3]>><<Statement_Semantic with id[x]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token switch__
[MARKER IR]: label: bp_label_0
Lex Ate token  (__
Lex Ate token  num__0__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__x__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
Lex Ate token  {__
[MARKER IR]: label: bp_label_1
Lex Ate token case__
Lex Ate token  num__1__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_2
Lex Ate token  =__
Lex Ate token  id__x__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token  ;__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_2 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_3
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__2__
Lex Ate token )__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_4
Lex Ate token  =__
Lex Ate token  id__x__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_4 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  2
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
in normal case number1
after else state 11
after else state 21
before backpatching case nextlists
backpatching nextlist  0
 size of STvec->nextlist is 1
before backpatching case breaklists
reached non empty case in breaking 0outof 1 its breaklist is of size 0
reached non empty case in breaking 1outof 1 its breaklist is of size 0
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_0 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_7
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__x__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
Lex Ate token  {__
[MARKER IR]: label: bp_label_8
Lex Ate token case__
Lex Ate token  num__0__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_9
Lex Ate token  num__5__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_10
Lex Ate token  num__3__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__3__
Lex Ate token )__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_11
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_11 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_12
Lex Ate token  num__5__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  4
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
in normal case number1
after else state 11
after else state 21
in normal case number2
after else state 12
after else state 22
in normal case number3
after else state 13
after else state 23
before backpatching case nextlists
backpatching nextlist  0
 size of STvec->nextlist is 1
backpatching nextlist  1
 size of STvec->nextlist is 1
backpatching nextlist  2
 size of STvec->nextlist is 1
before backpatching case breaklists
reached non empty case in breaking 0outof 3 its breaklist is of size 0
reached non empty case in breaking 1outof 3 its breaklist is of size 0
reached non empty case in breaking 2outof 3 its breaklist is of size 0
reached non empty case in breaking 3outof 3 its breaklist is of size 0
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_7 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: main
If void, an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with [get_func_label] main's label is: label_29
label_29
[get_func_label] main's label is: label_29
ignore me1 (label_29)
[END_OF Program_IR]
