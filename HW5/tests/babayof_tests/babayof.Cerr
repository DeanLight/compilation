[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token void__
Lex Ate token  id__OneWhoKnows__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[OneWhoKnows]>>
[[[ added func: OneWhoKnows with 0 params and label: ]]]
FuncHead_IR for func: OneWhoKnows
got label label_29 in line: -1
[set_func_label] label label_29 for function OneWhoKnows
[get_func_label] OneWhoKnows's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token while__
[MARKER IR]: label: bp_label_0
[MARKER IR]: label: bp_label_1
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__13__
Lex Ate token )__
[Exp_IR] Exp -> Num:13
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_2
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_3
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"mi yode'a? "__
[Exp_IR] Exp -> string"mi yode'a? "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_3 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_4
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_4 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_5
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"ani yode'a!\n"__
[Exp_IR] Exp -> string"ani yode'a!\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_5 breaklist size is 0
Lex Ate token switch__
[MARKER IR]: label: bp_label_6
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_7
Lex Ate token case__
Lex Ate token  num__14__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"ONE WHO KNOWS - 14 NOT GOOD\n"__
[Exp_IR] Exp -> string"ONE WHO KNOWS - 14 NOT GOOD\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token default__
[MARKER IR]: label: bp_label_8
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"ONE WHO KNOWS - DEFAULT NOT GOOD\n"__
[Exp_IR] Exp -> string"ONE WHO KNOWS - DEFAULT NOT GOOD\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_9
Lex Ate token  num__13__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__13__
Lex Ate token )__
[Exp_IR] Exp -> Num:13
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_10
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" midaya"__
[Exp_IR] Exp -> string" midaya"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_10 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_11
Lex Ate token  num__12__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__12__
Lex Ate token )__
[Exp_IR] Exp -> Num:12
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_12
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" shivtaya"__
[Exp_IR] Exp -> string" shivtaya"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_12 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_13
Lex Ate token  num__11__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__11__
Lex Ate token )__
[Exp_IR] Exp -> Num:11
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_14
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" kochvaya"__
[Exp_IR] Exp -> string" kochvaya"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_14 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_15
Lex Ate token  num__10__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__10__
Lex Ate token )__
[Exp_IR] Exp -> Num:10
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_16
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" dibraya"__
[Exp_IR] Exp -> string" dibraya"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_16 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_17
Lex Ate token  num__9__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__9__
Lex Ate token )__
[Exp_IR] Exp -> Num:9
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_18
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" chodshei leidah"__
[Exp_IR] Exp -> string" chodshei leidah"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_18 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_19
Lex Ate token  num__8__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__8__
Lex Ate token )__
[Exp_IR] Exp -> Num:8
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_20
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" yemei milah"__
[Exp_IR] Exp -> string" yemei milah"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_20 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_21
Lex Ate token  num__7__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__7__
Lex Ate token )__
[Exp_IR] Exp -> Num:7
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_22
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" yemei shabatah"__
[Exp_IR] Exp -> string" yemei shabatah"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_22 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_23
Lex Ate token  num__6__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__6__
Lex Ate token )__
[Exp_IR] Exp -> Num:6
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_24
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" sidre mishna"__
[Exp_IR] Exp -> string" sidre mishna"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_24 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_25
Lex Ate token  num__5__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_26
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" chumshei torah"__
[Exp_IR] Exp -> string" chumshei torah"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_26 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_27
Lex Ate token  num__4__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_28
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" imahot"__
[Exp_IR] Exp -> string" imahot"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_28 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_29
Lex Ate token  num__3__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__3__
Lex Ate token )__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_30
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" avot"__
[Exp_IR] Exp -> string" avot"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_30 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_31
Lex Ate token  num__2__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__2__
Lex Ate token )__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_32
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" luchot habrit"__
[Exp_IR] Exp -> string" luchot habrit"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_32 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_33
Lex Ate token  num__1__
Lex Ate token  :__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token int__
[MARKER IR]: label: bp_label_34
Lex Ate token  id__j__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__5__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[j]type:[]>>
<<adding var: [j] of type [3]>><<Statement_Semantic with id[j]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_34 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_35
[MARKER IR]: label: bp_label_36
Lex Ate token  (__
Lex Ate token  id__j__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[j]>>
[Exp_IR] Exp -> id: j
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects j
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_37
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" elokeinu"__
[Exp_IR] Exp -> string" elokeinu"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__j__
[MARKER IR]: label: bp_label_38
Lex Ate token  =__
Lex Ate token  id__j__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[j]>>
[Exp_IR] Exp -> id: j
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects j
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<Statement_Semantic with id[j]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_38 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_35 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_40
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" shebashamaim uva'aaaretz\n"__
[Exp_IR] Exp -> string" shebashamaim uva'aaaretz\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_40 breaklist size is 0
Lex Ate token  id__i__
[MARKER IR]: label: bp_label_41
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_41 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  15
[Seggfault test] expreg is $t0
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
foudn default in i =1
in normal case number2
after else state 12
after else state 22
in normal case number3
after else state 13
after else state 23
in normal case number4
after else state 14
after else state 24
in normal case number5
after else state 15
after else state 25
in normal case number6
after else state 16
after else state 26
in normal case number7
after else state 17
after else state 27
in normal case number8
after else state 18
after else state 28
in normal case number9
after else state 19
after else state 29
in normal case number10
after else state 110
after else state 210
in normal case number11
after else state 111
after else state 211
in normal case number12
after else state 112
after else state 212
in normal case number13
after else state 113
after else state 213
in normal case number14
after else state 114
after else state 214
before backpatching case nextlists
backpatching nextlist  0
 size of STvec->nextlist is 1
backpatching nextlist  1
 size of STvec->nextlist is 1
backpatching nextlist  2
 size of STvec->nextlist is 1
backpatching nextlist  3
 size of STvec->nextlist is 1
backpatching nextlist  4
 size of STvec->nextlist is 1
backpatching nextlist  5
 size of STvec->nextlist is 1
backpatching nextlist  6
 size of STvec->nextlist is 1
backpatching nextlist  7
 size of STvec->nextlist is 1
backpatching nextlist  8
 size of STvec->nextlist is 1
backpatching nextlist  9
 size of STvec->nextlist is 1
backpatching nextlist  10
 size of STvec->nextlist is 1
backpatching nextlist  11
 size of STvec->nextlist is 1
backpatching nextlist  12
 size of STvec->nextlist is 1
backpatching nextlist  13
 size of STvec->nextlist is 1
before backpatching case breaklists
reached non empty case in breaking 0outof 14 its breaklist is of size 0
reached non empty case in breaking 1outof 14 its breaklist is of size 0
reached non empty case in breaking 2outof 14 its breaklist is of size 0
reached non empty case in breaking 3outof 14 its breaklist is of size 0
reached non empty case in breaking 4outof 14 its breaklist is of size 0
reached non empty case in breaking 5outof 14 its breaklist is of size 0
reached non empty case in breaking 6outof 14 its breaklist is of size 0
reached non empty case in breaking 7outof 14 its breaklist is of size 0
reached non empty case in breaking 8outof 14 its breaklist is of size 0
reached non empty case in breaking 9outof 14 its breaklist is of size 0
reached non empty case in breaking 10outof 14 its breaklist is of size 0
reached non empty case in breaking 11outof 14 its breaklist is of size 0
reached non empty case in breaking 12outof 14 its breaklist is of size 0
reached non empty case in breaking 13outof 14 its breaklist is of size 0
reached non empty case in breaking 14outof 14 its breaklist is of size 0
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_6 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_0 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: OneWhoKnows
If void, an extra ret will be added
Ret type: 1
Lex Ate token int__
Lex Ate token  id__sqrtRoundDown__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__x__
<<FormalDecl_Semantic: id[x]>>
<<adding param: [x] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[sqrtRoundDown]>>
[[[ added func: sqrtRoundDown with 1 params and label: ]]]
FuncHead_IR for func: sqrtRoundDown
got label label_1155 in line: -1
[set_func_label] label label_1155 for function sqrtRoundDown
[get_func_label] sqrtRoundDown's label is: label_1155
written label: label_1155
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_46
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"sqrtRoundDown - IMPOSSIBLE NEGATIVE PARAMETER!"__
[Exp_IR] Exp -> string"sqrtRoundDown - IMPOSSIBLE NEGATIVE PARAMETER!"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_47
Lex Ate token int__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
[MARKER IR]: label: bp_label_49
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_49 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_50
[MARKER IR]: label: bp_label_51
Lex Ate token  (__
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token B__
<<[Exp_Semantic] B:[1]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
Lex Ate token  BinOp__MUL_DIV*__
Lex Ate token  (__
Lex Ate token  num__1__
Lex Ate token B__
<<[Exp_Semantic] B:[1]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  BinOp__ADD_SUB+__
not a bool var so no SJ_exp after effects 
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  RelOp__<=__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects x
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_52
Lex Ate token  {__
Lex Ate token  id__i__
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_50 breaklist size is 0
Lex Ate token return__
[MARKER IR]: label: bp_label_54
Lex Ate token  id__i__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_54 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: sqrtRoundDown
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__x1__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
<<adding param: [a] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__B__
<<FormalDecl_Semantic: id[B]>>
<<adding param: [B] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__c__
<<FormalDecl_Semantic: id[c]>>
<<adding param: [c] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[x1]>>
[[[ added func: x1 with 3 params and label: ]]]
FuncHead_IR for func: x1
got label label_1275 in line: -1
[set_func_label] label label_1275 for function x1
[get_func_label] x1's label is: label_1275
written label: label_1275
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__delta__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__sqrtRoundDown__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__B__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
Lex Ate token  id__B__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__a__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects c
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments sqrtRoundDown
[get_func_label] sqrtRoundDown's label is: label_1155
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callsqrtRoundDown
[Exp_IR] endof Exp->callsqrtRoundDown
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[delta]type:[]>>
<<adding var: [delta] of type [3]>><<Statement_Semantic with id[delta]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_56
Lex Ate token  (__
Lex Ate token  num__0__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__B__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  id__delta__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[delta]>>
[Exp_IR] Exp -> id: delta
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects delta
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
Lex Ate token  BinOp__MUL_DIV/__
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__2__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__a__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 / Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 / Exp2
Lex Ate token  ;__
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_56 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: x1
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__x2__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
<<adding param: [a] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__B__
<<FormalDecl_Semantic: id[B]>>
<<adding param: [B] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__c__
<<FormalDecl_Semantic: id[c]>>
<<adding param: [c] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[x2]>>
[[[ added func: x2 with 3 params and label: ]]]
FuncHead_IR for func: x2
got label label_1380 in line: -1
[set_func_label] label label_1380 for function x2
[get_func_label] x2's label is: label_1380
written label: label_1380
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__delta__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__sqrtRoundDown__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__B__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
Lex Ate token  id__B__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__4__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__a__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  id__c__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[c]>>
[Exp_IR] Exp -> id: c
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects c
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments sqrtRoundDown
[get_func_label] sqrtRoundDown's label is: label_1155
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callsqrtRoundDown
[Exp_IR] endof Exp->callsqrtRoundDown
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[delta]type:[]>>
<<adding var: [delta] of type [3]>><<Statement_Semantic with id[delta]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_58
Lex Ate token  (__
Lex Ate token  num__0__
Lex Ate token  BinOp__ADD_SUB-__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__B__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  id__delta__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[delta]>>
[Exp_IR] Exp -> id: delta
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects delta
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
Lex Ate token  BinOp__MUL_DIV/__
not a bool var so no SJ_exp after effects 
Lex Ate token  (__
Lex Ate token  num__2__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  id__a__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 / Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 / Exp2
Lex Ate token  ;__
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_58 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: x2
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__mod__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
<<adding param: [a] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[mod]>>
[[[ added func: mod with 2 params and label: ]]]
FuncHead_IR for func: mod
got label label_1485 in line: -1
[set_func_label] label label_1485 for function mod
[get_func_label] mod's label is: label_1485
written label: label_1485
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token return__
Lex Ate token  id__a__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  id__a__
Lex Ate token  BinOp__MUL_DIV/__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  id__n__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
[Exp_IR]:Binop Exp -> Exp1 / Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 / Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  id__n__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States->SignleState]  nextlistSize=0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: mod
If void, an extra ret will be added
Ret type: 3
Lex Ate token bool__
Lex Ate token  id__isPrime__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[isPrime]>>
[[[ added func: isPrime with 1 params and label: ]]]
FuncHead_IR for func: isPrime
got label label_1520 in line: -1
[set_func_label] label label_1520 for function isPrime
[get_func_label] isPrime's label is: label_1520
written label: label_1520
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__2__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token int__
[MARKER IR]: label: bp_label_61
Lex Ate token  id__sqrtn__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__sqrtRoundDown__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : n
exp is of type INT
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments sqrtRoundDown
[get_func_label] sqrtRoundDown's label is: label_1155
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callsqrtRoundDown
[Exp_IR] endof Exp->callsqrtRoundDown
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[sqrtn]type:[]>>
<<adding var: [sqrtn] of type [3]>><<Statement_Semantic with id[sqrtn]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_61 breaklist size is 0
Lex Ate comment://print("\nsqrt of ");

Lex Ate comment://printi(n);

Lex Ate comment://print("is ");

Lex Ate comment://printi(sqrtn);

Lex Ate comment://print("\n");

Lex Ate token while__
[MARKER IR]: label: bp_label_62
[MARKER IR]: label: bp_label_63
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  id__sqrtn__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[sqrtn]>>
[Exp_IR] Exp -> id: sqrtn
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects sqrtn
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_64
Lex Ate token  {__
Lex Ate comment://print("\n mod n i");

Lex Ate comment://printi(n);

Lex Ate comment://print(" ");

Lex Ate comment://printi(i);

Lex Ate comment://print(" ");

Lex Ate comment://printi(mod(n,i));

Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__mod__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments mod
[get_func_label] mod's label is: label_1485
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callmod
[Exp_IR] endof Exp->callmod
not a bool var so no SJ_exp after effects mod
Lex Ate token  RelOp__==__
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_65
Lex Ate token return__
Lex Ate token false__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[MARKER IR]: label: bp_label_66
Lex Ate token  id__i__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
[MARKER IR]: label: bp_label_68
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_68 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_62 breaklist size is 0
Lex Ate token return__
[MARKER IR]: label: bp_label_70
Lex Ate token true__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_70 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: isPrime
If void, an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__printPrimality__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[printPrimality]>>
[[[ added func: printPrimality with 1 params and label: ]]]
FuncHead_IR for func: printPrimality
got label label_1672 in line: -1
[set_func_label] label label_1672 for function printPrimality
[get_func_label] printPrimality's label is: label_1672
written label: label_1672
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_72
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : n
exp is of type INT
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_72 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_73
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" is"__
[Exp_IR] Exp -> string" is"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_73 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_74
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  id__isPrime__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : n
exp is of type INT
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments isPrime
[get_func_label] isPrime's label is: label_1520
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callisPrime
[Exp_IR] endof Exp->callisPrime
[SJ_Exp_IR]: isPrime
Lex Ate token )__
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_75
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" not"__
[Exp_IR] Exp -> string" not"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_76
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_74 breaklist size is 0
[MARKER IR]: label: bp_label_78
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" prime."__
[Exp_IR] Exp -> string" prime."
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_78 breaklist size is 0
Lex Ate token return__
[MARKER IR]: label: bp_label_79
Lex Ate token  ;__
[Statement_IR] Return void
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_79 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: printPrimality
If void, an extra ret will be added
Ret type: 1
Lex Ate token void__
Lex Ate token  id__printPrimalsInRange__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
<<adding param: [a] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__B__
<<FormalDecl_Semantic: id[B]>>
<<adding param: [B] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[printPrimalsInRange]>>
[[[ added func: printPrimalsInRange with 2 params and label: ]]]
FuncHead_IR for func: printPrimalsInRange
got label label_1876 in line: -1
[set_func_label] label label_1876 for function printPrimalsInRange
[get_func_label] printPrimalsInRange's label is: label_1876
written label: label_1876
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token while__
[MARKER IR]: label: bp_label_81
Lex Ate token  (__
Lex Ate token  id__a__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  id__B__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_82
Lex Ate token  {__
Lex Ate token  id__printPrimality__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__a__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : a
exp is of type INT
[ExpList_IR: ExpList->Exp]: a
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printPrimality
[get_func_label] printPrimality's label is: label_1672
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__a__
[MARKER IR]: label: bp_label_83
Lex Ate token  =__
Lex Ate token  id__a__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[a]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_83 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: printPrimalsInRange
If void, an extra ret will be added
Ret type: 1
Lex Ate token int__
Lex Ate token  id__gcd__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__a__
<<FormalDecl_Semantic: id[a]>>
<<adding param: [a] of type [3]>>Lex Ate token  ,__
Lex Ate token int__
Lex Ate token  id__B__
<<FormalDecl_Semantic: id[B]>>
<<adding param: [B] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[gcd]>>
[[[ added func: gcd with 2 params and label: ]]]
FuncHead_IR for func: gcd
got label label_1943 in line: -1
[set_func_label] label label_1943 for function gcd
[get_func_label] gcd's label is: label_1943
written label: label_1943
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__a__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  num__0__
Lex Ate token and__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_86
Lex Ate token  id__B__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_87
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"GCD - GOT 00"__
[Exp_IR] Exp -> string"GCD - GOT 00"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_88
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_88 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_89
Lex Ate token if__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
[MARKER IR]: label: bp_label_91
Lex Ate token  (__
Lex Ate token  id__a__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects a
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_92
Lex Ate token return__
Lex Ate token  id__B__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[MARKER IR]: label: bp_label_93
Lex Ate token if__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_91 breaklist size is 0
[MARKER IR]: label: bp_label_95
Lex Ate token  (__
Lex Ate token  id__B__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects B
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_96
Lex Ate token return__
Lex Ate token  id__a__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[MARKER IR]: label: bp_label_97
Lex Ate token return__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_95 breaklist size is 0
[MARKER IR]: label: bp_label_99
Lex Ate token  id__gcd__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__B__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__mod__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  id__a__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[a]>>
[Exp_IR] Exp -> id: a
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__B__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[B]>>
[Exp_IR] Exp -> id: B
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : B
exp is of type INT
[ExpList_IR: ExpList->Exp]: B
[ExpList_IR: ExpList->Exp]: a
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments mod
[get_func_label] mod's label is: label_1485
[Emitter] REstore_registers: 1
END_OF [Call_IR]
[Exp_IR] Exp->callmod
[Exp_IR] endof Exp->callmod
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : mod
exp is of type INT
[ExpList_IR: ExpList->Exp]: mod
[ExpList_IR: ExpList->Exp]: B
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments gcd
[get_func_label] gcd's label is: label_1943
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callgcd
[Exp_IR] endof Exp->callgcd
Lex Ate token  ;__
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_99 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: gcd
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__fi__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[fi]>>
[[[ added func: fi with 1 params and label: ]]]
FuncHead_IR for func: fi
got label label_2153 in line: -1
[set_func_label] label label_2153 for function fi
[get_func_label] fi's label is: label_2153
written label: label_2153
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token int__
[MARKER IR]: label: bp_label_101
Lex Ate token  id__count__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[count]type:[]>>
<<adding var: [count] of type [3]>>[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_101 breaklist size is 0
Lex Ate token  id__count__
[MARKER IR]: label: bp_label_102
Lex Ate token  =__
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<Statement_Semantic with id[count]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_102 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_103
[MARKER IR]: label: bp_label_104
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  id__n__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_105
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__gcd__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token  ,__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments gcd
[get_func_label] gcd's label is: label_1943
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callgcd
[Exp_IR] endof Exp->callgcd
not a bool var so no SJ_exp after effects gcd
Lex Ate token  RelOp__==__
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_106
Lex Ate token  {__
Lex Ate token  id__count__
Lex Ate token  =__
Lex Ate token  id__count__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[count]>>
[Exp_IR] Exp -> id: count
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects count
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[count]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_107
Lex Ate token  id__i__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
[MARKER IR]: label: bp_label_109
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_109 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_103 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_111
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"\nfi of "__
[Exp_IR] Exp -> string"\nfi of "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_111 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_112
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : n
exp is of type INT
[ExpList_IR: ExpList->Exp]: n
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_112 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_113
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"="__
[Exp_IR] Exp -> string"="
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_113 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_114
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__count__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[count]>>
[Exp_IR] Exp -> id: count
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : count
exp is of type INT
[ExpList_IR: ExpList->Exp]: count
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_114 breaklist size is 0
Lex Ate token return__
[MARKER IR]: label: bp_label_115
Lex Ate token  id__count__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[count]>>
[Exp_IR] Exp -> id: count
END_OF [Exp_IR] Exp -> id
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_115 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: fi
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__factorial1__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[factorial1]>>
[[[ added func: factorial1 with 1 params and label: ]]]
FuncHead_IR for func: factorial1
got label label_2416 in line: -1
[set_func_label] label label_2416 for function factorial1
[get_func_label] factorial1's label is: label_2416
written label: label_2416
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token if__
Lex Ate token  (__
Lex Ate token  id__n__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_117
Lex Ate token return__
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[MARKER IR]: label: bp_label_118
Lex Ate token return__
size of next list for if is0
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
[MARKER IR]: label: bp_label_120
Lex Ate token  id__factorial1__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__n__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments factorial1
[get_func_label] factorial1's label is: label_2416
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfactorial1
[Exp_IR] endof Exp->callfactorial1
Lex Ate token  BinOp__MUL_DIV*__
not a bool var so no SJ_exp after effects factorial1
Lex Ate token  id__n__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_120 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: factorial1
If void, an extra ret will be added
Ret type: 3
Lex Ate token int__
Lex Ate token  id__factorial2__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__n__
<<FormalDecl_Semantic: id[n]>>
<<adding param: [n] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[factorial2]>>
[[[ added func: factorial2 with 1 params and label: ]]]
FuncHead_IR for func: factorial2
got label label_2496 in line: -1
[set_func_label] label label_2496 for function factorial2
[get_func_label] factorial2's label is: label_2496
written label: label_2496
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__result__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[result]type:[]>>
<<adding var: [result] of type [3]>><<Statement_Semantic with id[result]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token while__
[MARKER IR]: label: bp_label_122
[MARKER IR]: label: bp_label_123
Lex Ate token  (__
Lex Ate token  id__n__
Lex Ate token  RelOp__>__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 > Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 > Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_124
Lex Ate token  {__
Lex Ate token  id__result__
Lex Ate token  =__
Lex Ate token  id__result__
Lex Ate token  BinOp__MUL_DIV*__
<<[Exp_Semantic_Id] id:[result]>>
[Exp_IR] Exp -> id: result
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects result
Lex Ate token  id__n__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
<<Statement_Semantic with id[result]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__n__
[MARKER IR]: label: bp_label_125
Lex Ate token  =__
Lex Ate token  id__n__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[n]>>
[Exp_IR] Exp -> id: n
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects n
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<Statement_Semantic with id[n]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_125 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_122 breaklist size is 0
Lex Ate token return__
[MARKER IR]: label: bp_label_127
Lex Ate token  id__result__
Lex Ate token  ;__
<<[Exp_Semantic_Id] id:[result]>>
[Exp_IR] Exp -> id: result
END_OF [Exp_IR] Exp -> id
<<RetExp, ExpT:[3] scopeT:[3]>>
[Statement_IR] Return noneVoid
END_OF [Statement_IR] Return noneVoid
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_127 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: factorial2
If void, an extra ret will be added
Ret type: 3
Lex Ate token bool__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
Lex Ate token int__
Lex Ate token  id__message__
<<FormalDecl_Semantic: id[message]>>
<<adding param: [message] of type [3]>>Lex Ate token )__
<<FormalsSem>><<FuncHead_semantic, id:[NeverPrintMe]>>
[[[ added func: NeverPrintMe with 1 params and label: ]]]
FuncHead_IR for func: NeverPrintMe
got label label_2567 in line: -1
[set_func_label] label label_2567 for function NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
written label: label_2567
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__"YOU PRINTED THE UNPRINTABLE. error message: "__
[Exp_IR] Exp -> string"YOU PRINTED THE UNPRINTABLE. error message: "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_129
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__message__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[message]>>
[Exp_IR] Exp -> id: message
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : message
exp is of type INT
[ExpList_IR: ExpList->Exp]: message
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_129 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_130
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  str__" I SENTENCE YOU TO AN ENDLESS DEBUGGING.\n"__
[Exp_IR] Exp -> string" I SENTENCE YOU TO AN ENDLESS DEBUGGING.\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_130 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: NeverPrintMe
If void, an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__shortCircuitEvaluation__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[shortCircuitEvaluation]>>
[[[ added func: shortCircuitEvaluation with 0 params and label: ]]]
FuncHead_IR for func: shortCircuitEvaluation
got label label_2663 in line: -1
[set_func_label] label label_2663 for function shortCircuitEvaluation
[get_func_label] shortCircuitEvaluation's label is: label_2663
written label: label_2663
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__wannabe__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[wannabe]type:[]>>
<<adding var: [wannabe] of type [3]>><<Statement_Semantic with id[wannabe]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token if__
[MARKER IR]: label: bp_label_132
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token or__
[MARKER IR]: label: bp_label_133
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_133
exp1:true truelistSize: 1
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_134
Lex Ate token  id__wannabe__
Lex Ate token  =__
Lex Ate token  id__wannabe__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[wannabe]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[MARKER IR]: label: bp_label_135
Lex Ate token else__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  num__2__
Lex Ate token )__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_132 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_137
Lex Ate token  (__
Lex Ate token false__
[SJ_Exp_IR]: false
Lex Ate token and__
[MARKER IR]: label: bp_label_138
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__3__
Lex Ate token )__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 1
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:NeverPrintMe falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_139
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 1
END_OF CallHeader_IR
Lex Ate token  num__4__
Lex Ate token )__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_140
Lex Ate token else__
Lex Ate token  id__wannabe__
Lex Ate token  =__
Lex Ate token  id__wannabe__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__2__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[wannabe]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_137 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_142
Lex Ate token  (__
Lex Ate token  (__
Lex Ate token  num__3__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token or__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_143
Lex Ate token  num__3__
Lex Ate token  BinOp__MUL_DIV*__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  RelOp__==__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 * Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 * Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token  BinOp__ADD_SUB+__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
Lex Ate token  num__3__
Lex Ate token or__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_143
exp1: truelistSize: 1
exp2: truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_144
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  num__5__
Lex Ate token )__
[Exp_IR] Exp -> Num:5
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_144
exp1: truelistSize: 2
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 3
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 3
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token and__
[MARKER IR]: label: bp_label_145
Lex Ate token  (__
Lex Ate token  (__
Lex Ate token true__
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: true
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_146
Lex Ate token  (__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  num__6__
Lex Ate token )__
[Exp_IR] Exp -> Num:6
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
Lex Ate token or__
[SJ_Exp_IR]: NeverPrintMe
[MARKER IR]: label: bp_label_147
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  num__7__
Lex Ate token )__
[Exp_IR] Exp -> Num:7
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_147
exp1:NeverPrintMe truelistSize: 1
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_146
exp1:true truelistSize: 1
exp2: truelistSize: 2
Exp: falselistSize: 1
Exp: truelistSize: 3
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 3
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token or__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2: falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 3
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_148
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  num__8__
Lex Ate token )__
[Exp_IR] Exp -> Num:8
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 2
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_148
exp1: truelistSize: 3
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 4
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_149
Lex Ate token  {__
Lex Ate token  id__wannabe__
Lex Ate token  =__
Lex Ate token  id__wannabe__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__4__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:4
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[wannabe]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_150
Lex Ate token else__
Lex Ate token  {__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 2
END_OF CallHeader_IR
Lex Ate token  num__9__
Lex Ate token )__
[Exp_IR] Exp -> Num:9
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 2
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_142 breaklist size is 0
Lex Ate token  id__wannabe__
[MARKER IR]: label: bp_label_152
Lex Ate token  =__
Lex Ate token  id__wannabe__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__8__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:8
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[wannabe]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_152 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_153
Lex Ate token  id__stupidVariableShouldBeTrue__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__mod__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__9__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:9
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__2__
Lex Ate token )__
[Exp_IR] Exp -> Num:2
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments mod
[get_func_label] mod's label is: label_1485
[Emitter] REstore_registers: 3
END_OF [Call_IR]
[Exp_IR] Exp->callmod
[Exp_IR] endof Exp->callmod
Lex Ate token  RelOp__==__
not a bool var so no SJ_exp after effects mod
Lex Ate token  num__0__
Lex Ate token and__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_154
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__10__
Lex Ate token )__
[Exp_IR] Exp -> Num:10
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 3
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token or__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1: falselistSize: 1
exp2:NeverPrintMe falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_155
Lex Ate token  (__
Lex Ate token  id__mod__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__9__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:9
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__3__
Lex Ate token )__
[Exp_IR] Exp -> Num:3
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments mod
[get_func_label] mod's label is: label_1485
[Emitter] REstore_registers: 3
END_OF [Call_IR]
[Exp_IR] Exp->callmod
[Exp_IR] endof Exp->callmod
Lex Ate token  RelOp__==__
not a bool var so no SJ_exp after effects mod
Lex Ate token  num__0__
Lex Ate token or__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_156
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__11__
Lex Ate token )__
[Exp_IR] Exp -> Num:11
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 3
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_156
exp1: truelistSize: 1
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[Exp->(Exp)]
(Exp) str_content: 
(Exp) falselistSize: 1
(Exp) truelistSize: 2
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: 
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_155
exp1: truelistSize: 1
exp2: truelistSize: 2
Exp: falselistSize: 1
Exp: truelistSize: 3
<<[Statement_Semantic][TypeID_SC] id:[stupidVariableShouldBeTrue]type:[]>>
<<adding var: [stupidVariableShouldBeTrue] of type [5]>><<Statement_Semantic with id[stupidVariableShouldBeTrue]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_153 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_157
Lex Ate token  (__
Lex Ate token  id__stupidVariableShouldBeTrue__
Lex Ate token or__
<<[Exp_Semantic_Id] id:[stupidVariableShouldBeTrue]>>
[Exp_IR] Exp -> id: stupidVariableShouldBeTrue
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: stupidVariableShouldBeTrue
[MARKER IR]: label: bp_label_158
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__13__
Lex Ate token )__
[Exp_IR] Exp -> Num:13
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 3
END_OF [Call_IR]
[Exp_IR] Exp->callNeverPrintMe
[Exp_IR] endof Exp->callNeverPrintMe
[SJ_Exp_IR]: NeverPrintMe
Lex Ate token )__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_158
exp1:stupidVariableShouldBeTrue truelistSize: 1
exp2:NeverPrintMe truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_159
Lex Ate token  {__
Lex Ate token  id__wannabe__
Lex Ate token  =__
Lex Ate token  id__wannabe__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__16__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:16
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[wannabe]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_160
Lex Ate token else__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 3
END_OF CallHeader_IR
Lex Ate token  num__14__
Lex Ate token )__
[Exp_IR] Exp -> Num:14
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 3
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
size of next list for if is1
size of next list for else is1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_157 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_162
Lex Ate token  (__
Lex Ate token  id__wannabe__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects wannabe
Lex Ate token  num__31__
Lex Ate token )__
[Exp_IR] Exp -> Num:31
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_163
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  id__wannabe__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[wannabe]>>
[Exp_IR] Exp -> id: wannabe
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : wannabe
exp is of type INT
[ExpList_IR: ExpList->Exp]: wannabe
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_164
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__" IS THE VALUE OF WANNABE BUT IT SHOULD BE 31. BAD SCE"__
[Exp_IR] Exp -> string" IS THE VALUE OF WANNABE BUT IT SHOULD BE 31. BAD SCE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_164 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_165
Lex Ate token  }__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_162 breaklist size is 0
[FuncDeclNode_IR]: 
checking retType of func: shortCircuitEvaluation
If void, an extra ret will be added
Ret type: 1
Lex Ate token void__
Lex Ate token  id__breakingBad__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[breakingBad]>>
[[[ added func: breakingBad with 0 params and label: ]]]
FuncHead_IR for func: breakingBad
got label label_3671 in line: -1
[set_func_label] label label_3671 for function breakingBad
[get_func_label] breakingBad's label is: label_3671
written label: label_3671
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token int__
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token int__
[MARKER IR]: label: bp_label_168
Lex Ate token  id__crazyKey__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[crazyKey]type:[]>>
<<adding var: [crazyKey] of type [3]>><<Statement_Semantic with id[crazyKey]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_168 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_169
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"BREAKING GOOD: 1 TO 10. ELSE: BREAKING BAD"__
[Exp_IR] Exp -> string"BREAKING GOOD: 1 TO 10. ELSE: BREAKING BAD"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_169 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_170
[MARKER IR]: label: bp_label_171
Lex Ate token  (__
Lex Ate token  (__
Lex Ate token true__
Lex Ate token )__
[Exp->(Exp)]
(Exp) str_content: true
(Exp) falselistSize: 0
(Exp) truelistSize: 0
ENDOF_[Exp->(Exp)]
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_172
Lex Ate token  {__
Lex Ate comment://print("Crazy key is ");

Lex Ate comment://print(crazyKey);

Lex Ate comment://print("\n");

Lex Ate token switch__
Lex Ate token  (__
Lex Ate token  id__crazyKey__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[crazyKey]>>
[Exp_IR] Exp -> id: crazyKey
END_OF [Exp_IR] Exp -> id
Lex Ate token  {__
[MARKER IR]: label: bp_label_173
Lex Ate token case__
Lex Ate token  num__435__
Lex Ate token  :__
Lex Ate token case__
[MARKER IR]: label: bp_label_174
Lex Ate token  num__232__
Lex Ate token  :__
Lex Ate token case__
[MARKER IR]: label: bp_label_175
Lex Ate token  num__1__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"1 "__
[Exp_IR] Exp -> string"1 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token case__
[MARKER IR]: label: bp_label_176
Lex Ate token  num__111__
Lex Ate token  :__
Lex Ate token bool__
Lex Ate token  id__isThisDefined__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[isThisDefined]type:[]>>
<<adding var: [isThisDefined] of type [5]>>[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_177
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"2 "__
[Exp_IR] Exp -> string"2 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_177 breaklist size is 0
Lex Ate token default__
[MARKER IR]: label: bp_label_178
Lex Ate token  :__
Lex Ate token bool__
Lex Ate token  id__noMatch__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  id__crazyKey__
Lex Ate token  RelOp__!=__
<<[Exp_Semantic_Id] id:[crazyKey]>>
[Exp_IR] Exp -> id: crazyKey
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects crazyKey
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 != Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 != Exp2
<<[Statement_Semantic][TypeID_SC] id:[noMatch]type:[]>>
<<adding var: [noMatch] of type [5]>><<Statement_Semantic with id[noMatch]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States->SignleState]  nextlistSize=3
Lex Ate token if__
[MARKER IR]: label: bp_label_179
Lex Ate token  (__
Lex Ate token  id__noMatch__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[noMatch]>>
[Exp_IR] Exp -> id: noMatch
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: noMatch
[MARKER IR]: label: bp_label_180
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"7 "__
[Exp_IR] Exp -> string"7 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__crazyKey__
[MARKER IR]: label: bp_label_181
Lex Ate token  =__
Lex Ate token  num__9__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:9
END_OF [Exp_IR] Exp -> Num
<<Statement_Semantic with id[crazyKey]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_181 breaklist size is 0
Lex Ate token break__
[MARKER IR]: label: bp_label_182
Lex Ate token  ;__
 new breakcommand at 3955 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_182 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_183
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_179 breaklist size is 0
[MARKER IR]: label: bp_label_185
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"3 "__
[Exp_IR] Exp -> string"3 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_185 breaklist size is 1
Lex Ate token case__
[MARKER IR]: label: bp_label_186
Lex Ate token  num__666__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"4 "__
[Exp_IR] Exp -> string"4 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__crazyKey__
[MARKER IR]: label: bp_label_187
Lex Ate token  =__
Lex Ate token  num__45__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:45
END_OF [Exp_IR] Exp -> Num
<<Statement_Semantic with id[crazyKey]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_187 breaklist size is 0
Lex Ate token break__
[MARKER IR]: label: bp_label_188
Lex Ate token  ;__
 new breakcommand at 4067 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_188 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_189
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  str__"BREAKING BAD - 666 DID NOT BREAK\n"__
[Exp_IR] Exp -> string"BREAKING BAD - 666 DID NOT BREAK\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_189 breaklist size is 1
Lex Ate token case__
[MARKER IR]: label: bp_label_190
Lex Ate token  num__1000__
Lex Ate token  :__
Lex Ate token  id__isThisDefined__
Lex Ate token  =__
Lex Ate token true__
Lex Ate token  ;__
<<Statement_Semantic with id[isThisDefined]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States->SignleState]  nextlistSize=3
Lex Ate token if__
[MARKER IR]: label: bp_label_191
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  id__isThisDefined__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[isThisDefined]>>
[Exp_IR] Exp -> id: isThisDefined
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: isThisDefined
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_192
Lex Ate token  {__
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 4
END_OF CallHeader_IR
Lex Ate token  num__333__
Lex Ate token )__
[Exp_IR] Exp -> Num:333
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 4
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_193
Lex Ate token  ;__
 new breakcommand at 4198 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_193 breaklist size is 0
Lex Ate token  }__
[MARKER IR]: label: bp_label_194
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_191 breaklist size is 0
[MARKER IR]: label: bp_label_196
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 5
END_OF CallHeader_IR
Lex Ate token  str__"10"__
[Exp_IR] Exp -> string"10"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 5
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_196 breaklist size is 1
Lex Ate token case__
[MARKER IR]: label: bp_label_197
Lex Ate token  num__999__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 5
END_OF CallHeader_IR
Lex Ate token  str__"11 "__
[Exp_IR] Exp -> string"11 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 5
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token break__
[MARKER IR]: label: bp_label_198
Lex Ate token  ;__
 new breakcommand at 4310 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_198 breaklist size is 0
Lex Ate token  id__NeverPrintMe__
[MARKER IR]: label: bp_label_199
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 5
END_OF CallHeader_IR
Lex Ate token  num__345__
Lex Ate token )__
[Exp_IR] Exp -> Num:345
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 5
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_199 breaklist size is 1
Lex Ate token case__
[MARKER IR]: label: bp_label_200
Lex Ate token  num__9__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 6
END_OF CallHeader_IR
Lex Ate token  str__"8 "__
[Exp_IR] Exp -> string"8 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 6
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__crazyKey__
[MARKER IR]: label: bp_label_201
Lex Ate token  =__
Lex Ate token  num__1000__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1000
END_OF [Exp_IR] Exp -> Num
<<Statement_Semantic with id[crazyKey]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_201 breaklist size is 0
Lex Ate token  {__
[MARKER IR]: label: bp_label_202
Lex Ate token  {__
Lex Ate token  {__
Lex Ate token break__
Lex Ate token  ;__
 new breakcommand at 4432 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__NeverPrintMe__
[MARKER IR]: label: bp_label_203
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 6
END_OF CallHeader_IR
Lex Ate token  num__50__
Lex Ate token )__
[Exp_IR] Exp -> Num:50
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 6
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_203 breaklist size is 1
Lex Ate token  }__
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_202 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_204
Lex Ate token  num__45__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 7
END_OF CallHeader_IR
Lex Ate token  str__"5 "__
[Exp_IR] Exp -> string"5 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 7
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token while__
[MARKER IR]: label: bp_label_205
[MARKER IR]: label: bp_label_206
Lex Ate token  (__
Lex Ate token true__
[SJ_Exp_IR]: true
Lex Ate token )__
[MARKER IR]: label: bp_label_207
Lex Ate token break__
Lex Ate token  ;__
 new breakcommand at 4561 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_205 breaklist size is 0
Lex Ate token case__
[MARKER IR]: label: bp_label_209
Lex Ate token  num__1__
Lex Ate token  :__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 7
END_OF CallHeader_IR
Lex Ate token  str__"6 "__
[Exp_IR] Exp -> string"6 "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 7
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__crazyKey__
[MARKER IR]: label: bp_label_210
Lex Ate token  =__
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<Statement_Semantic with id[crazyKey]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_210 breaklist size is 0
Lex Ate token break__
[MARKER IR]: label: bp_label_211
Lex Ate token  ;__
 new breakcommand at 4636 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_211 breaklist size is 0
Lex Ate token  }__
Lex Ate token  ;__
[Statement_IR: state->switch_head caseList ]
CDvec size is  11
[Seggfault test] expreg is $t7
[Seggfault test 2] 
in normal case number0
after else state 10
after else state 20
in normal case number1
after else state 11
after else state 21
in normal case number2
after else state 12
after else state 22
in normal case number3
after else state 13
after else state 23
foudn default in i =4
in normal case number5
after else state 15
after else state 25
in normal case number6
after else state 16
after else state 26
in normal case number7
after else state 17
after else state 27
in normal case number8
after else state 18
after else state 28
in normal case number9
after else state 19
after else state 29
in normal case number10
after else state 110
after else state 210
before backpatching case nextlists
backpatching nextlist  0
skipped empty case 0
backpatching nextlist  1
skipped empty case 1
backpatching nextlist  2
 size of STvec->nextlist is 1
backpatching nextlist  3
 size of STvec->nextlist is 1
backpatching nextlist  4
 size of STvec->nextlist is 1
backpatching nextlist  5
 size of STvec->nextlist is 1
backpatching nextlist  6
 size of STvec->nextlist is 1
backpatching nextlist  7
 size of STvec->nextlist is 1
backpatching nextlist  8
 size of STvec->nextlist is 1
backpatching nextlist  9
 size of STvec->nextlist is 1
before backpatching case breaklists
skipped empty case in breaking 0outof 10
skipped empty case in breaking 1outof 10
reached non empty case in breaking 2outof 10 its breaklist is of size 0
reached non empty case in breaking 3outof 10 its breaklist is of size 0
reached non empty case in breaking 4outof 10 its breaklist is of size 1
reached non empty case in breaking 5outof 10 its breaklist is of size 1
reached non empty case in breaking 6outof 10 its breaklist is of size 1
reached non empty case in breaking 7outof 10 its breaklist is of size 1
reached non empty case in breaking 8outof 10 its breaklist is of size 1
reached non empty case in breaking 9outof 10 its breaklist is of size 0
reached non empty case in breaking 10outof 10 its breaklist is of size 1
finished backpatching breaklists of yeah 
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token if__
[MARKER IR]: label: bp_label_214
Lex Ate token  (__
Lex Ate token  id__crazyKey__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[crazyKey]>>
[Exp_IR] Exp -> id: crazyKey
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects crazyKey
Lex Ate token  num__1000__
Lex Ate token )__
[Exp_IR] Exp -> Num:1000
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_215
Lex Ate token break__
Lex Ate token  ;__
 new breakcommand at 4674 the old list had adress list of size 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[MARKER IR]: label: bp_label_216
Lex Ate token if__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_214 breaklist size is 0
[MARKER IR]: label: bp_label_218
Lex Ate token  (__
Lex Ate token  id__crazyKey__
Lex Ate token  RelOp__==__
<<[Exp_Semantic_Id] id:[crazyKey]>>
[Exp_IR] Exp -> id: crazyKey
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects crazyKey
Lex Ate token  num__1000__
Lex Ate token )__
[Exp_IR] Exp -> Num:1000
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 == Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 == Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_219
Lex Ate token  id__NeverPrintMe__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 7
END_OF CallHeader_IR
Lex Ate token  num__51__
Lex Ate token )__
[Exp_IR] Exp -> Num:51
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments NeverPrintMe
[get_func_label] NeverPrintMe's label is: label_2567
[Emitter] REstore_registers: 7
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_220
Lex Ate token  }__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_218 breaklist size is 1
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_170 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: breakingBad
If void, an extra ret will be added
Ret type: 1
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_4770 in line: -1
[set_func_label] label label_4770 for function main
Saving main label: label_4770
[get_func_label] main's label is: label_4770
written label: label_4770
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"11111111:\n"__
[Exp_IR] Exp -> string"11111111:\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__printPrimality__
[MARKER IR]: label: bp_label_224
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  num__12__
Lex Ate token )__
[Exp_IR] Exp -> Num:12
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printPrimality
[get_func_label] printPrimality's label is: label_1672
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_224 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_225
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"one who knows:\n"__
[Exp_IR] Exp -> string"one who knows:\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_225 breaklist size is 0
Lex Ate token  id__OneWhoKnows__
[MARKER IR]: label: bp_label_226
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments OneWhoKnows
regNum=8
[get_func_label] OneWhoKnows's label is: label_29
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_226 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_227
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_227 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_228
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"breaking bad\n"__
[Exp_IR] Exp -> string"breaking bad\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_228 breaklist size is 0
Lex Ate token  id__breakingBad__
[MARKER IR]: label: bp_label_229
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments breakingBad
regNum=8
[get_func_label] breakingBad's label is: label_3671
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_229 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_230
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_230 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_231
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"curcuit\n"__
[Exp_IR] Exp -> string"curcuit\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_231 breaklist size is 0
Lex Ate token  id__shortCircuitEvaluation__
[MARKER IR]: label: bp_label_232
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments shortCircuitEvaluation
regNum=8
[get_func_label] shortCircuitEvaluation's label is: label_2663
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_232 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_233
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_233 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_234
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"primals\n"__
[Exp_IR] Exp -> string"primals\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_234 breaklist size is 0
Lex Ate token  id__printPrimalsInRange__
[MARKER IR]: label: bp_label_235
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  num__1__
Lex Ate token  ,__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
Lex Ate token  num__100__
Lex Ate token )__
[Exp_IR] Exp -> Num:100
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp : 
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 2
tmpActP: 2
tmptmp: 1
[Call_IR] : with arguments printPrimalsInRange
[get_func_label] printPrimalsInRange's label is: label_1876
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_235 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_236
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_236 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_237
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"factorials of 0,1,2,3,4,5,6 respectively: "__
[Exp_IR] Exp -> string"factorials of 0,1,2,3,4,5,6 respectively: "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_237 breaklist size is 0
Lex Ate token int__
[MARKER IR]: label: bp_label_238
Lex Ate token  id__i__
Lex Ate token  =__
[MVSP_IR] moving sp for place for new var
Lex Ate token  num__0__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<[Statement_Semantic][TypeID_SC] id:[i]type:[]>>
<<adding var: [i] of type [3]>><<Statement_Semantic with id[i]=exp>>
[Entered Statment_IR: Type id = exp]
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_238 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_239
[MARKER IR]: label: bp_label_240
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__<=__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__6__
Lex Ate token )__
[Exp_IR] Exp -> Num:6
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 <= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 <= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_241
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  id__factorial1__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments factorial1
[get_func_label] factorial1's label is: label_2416
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfactorial1
[Exp_IR] endof Exp->callfactorial1
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : factorial1
exp is of type INT
[ExpList_IR: ExpList->Exp]: factorial1
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_242
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_242 breaklist size is 0
Lex Ate token  id__i__
[MARKER IR]: label: bp_label_243
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_243 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_239 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_245
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\nreveresed: "__
[Exp_IR] Exp -> string"\nreveresed: "
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_245 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_246
[MARKER IR]: label: bp_label_247
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__>=__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 >= Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 >= Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_248
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  id__factorial2__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 0
END_OF CallHeader_IR
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments factorial2
[get_func_label] factorial2's label is: label_2496
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfactorial2
[Exp_IR] endof Exp->callfactorial2
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : factorial2
exp is of type INT
[ExpList_IR: ExpList->Exp]: factorial2
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_249
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  str__"\n"__
[Exp_IR] Exp -> string"\n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_249 breaklist size is 0
Lex Ate token  id__i__
[MARKER IR]: label: bp_label_250
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB-__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 - Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 - Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_250 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_246 breaklist size is 0
Lex Ate token while__
[MARKER IR]: label: bp_label_252
[MARKER IR]: label: bp_label_253
Lex Ate token  (__
Lex Ate token  id__i__
Lex Ate token  RelOp__<__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__40__
Lex Ate token )__
[Exp_IR] Exp -> Num:40
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Relop Exp -> Exp1 < Exp2
END_OF [Exp_IR]:Relop Exp -> Exp1 < Exp2
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_254
Lex Ate token  {__
Lex Ate token  id__i__
Lex Ate token  =__
Lex Ate token  id__i__
Lex Ate token  BinOp__ADD_SUB+__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
not a bool var so no SJ_exp after effects i
Lex Ate token  num__1__
Lex Ate token  ;__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
not a bool var so no SJ_exp after effects 
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<Statement_Semantic with id[i]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__fi__
[MARKER IR]: label: bp_label_255
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 8
END_OF CallHeader_IR
Lex Ate token  id__i__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[i]>>
[Exp_IR] Exp -> id: i
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : i
exp is of type INT
[ExpList_IR: ExpList->Exp]: i
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments fi
[get_func_label] fi's label is: label_2153
[Emitter] REstore_registers: 8
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_255 breaklist size is 0
Lex Ate token  }__
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_252 breaklist size is 0
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_257
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 9
END_OF CallHeader_IR
Lex Ate token  str__"\nprinti trunc: \n"__
[Exp_IR] Exp -> string"\nprinti trunc: \n"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 9
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_257 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_258
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 9
END_OF CallHeader_IR
Lex Ate token  num__250__
Lex Ate token B__
<<[Exp_Semantic] B:[250]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:250
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
Lex Ate token  BinOp__ADD_SUB+__
not a bool var so no SJ_exp after effects 
Lex Ate token  num__10__
Lex Ate token B__
<<[Exp_Semantic] B:[10]>>
[Exp_IR] Exp -> Num Bb
[Exp_IR] Exp -> Num:10
END_OF [Exp_IR] Exp -> Num
END_OF [Exp_IR] Exp -> Num B
not a bool var so no SJ_exp after effects 
Lex Ate token )__
[Exp_IR]:Binop Exp -> Exp1 + Exp2
END_OF [Exp_IR]:Binop Exp -> Exp1 + Exp2
<<ExpList_Semantic>> explist -> exp : 
exp is of type BYTE
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 9
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_258 breaklist size is 0
Lex Ate token int__
[MARKER IR]: label: bp_label_259
Lex Ate token  id__init__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[init]type:[]>>
<<adding var: [init] of type [3]>>[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_259 breaklist size is 0
Lex Ate token  id__printi__
[MARKER IR]: label: bp_label_260
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 9
END_OF CallHeader_IR
Lex Ate token  id__init__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[init]>>
[Exp_IR] Exp -> id: init
END_OF [Exp_IR] Exp -> id
<<ExpList_Semantic>> explist -> exp : init
exp is of type INT
[ExpList_IR: ExpList->Exp]: init
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 9
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_260 breaklist size is 0
Lex Ate token bool__
[MARKER IR]: label: bp_label_261
Lex Ate token  id__cccc__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[cccc]type:[]>>
<<adding var: [cccc] of type [5]>>[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_261 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_262
Lex Ate token  (__
Lex Ate token not__
Lex Ate token  id__cccc__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[cccc]>>
[Exp_IR] Exp -> id: cccc
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: cccc
[SJ_Exp_IR]: 
[MARKER IR]: label: bp_label_263
Lex Ate token  {__
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers: 9
END_OF CallHeader_IR
Lex Ate token  str__"bool bool"__
[Exp_IR] Exp -> string"bool bool"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp : 
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 9
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  }__
[MARKER IR]: label: bp_label_264
Lex Ate token  }__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_262 breaklist size is 0
[FuncDeclNode_IR]: 
checking retType of func: main
If void, an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with [get_func_label] main's label is: label_4770
label_4770
[get_func_label] main's label is: label_4770
ignore me1 (label_4770)
[END_OF Program_IR]
