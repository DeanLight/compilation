[[[ added func: print with 1 params and label: ]]]
[[[ added func: printi with 1 params and label: ]]]
print param:2(1)
printi param:3(1)
[FIRST_PROGRAM_POINT]
[set_func_label] label print for function print
[set_func_label] label printi for function printi
(END_OF)  [FIRST_PROGRAM_POINT]
Lex Ate token bool__
Lex Ate token  id__fooFalse__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[fooFalse]>>
[[[ added func: fooFalse with 0 params and label: ]]]
FuncHead_IR for func: fooFalse
got label label_29 in line: -1
[set_func_label] label label_29 for function fooFalse
[get_func_label] fooFalse's label is: label_29
written label: label_29
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  num__0__
Lex Ate token )__
[Exp_IR] Exp -> Num:0
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_0
Lex Ate token false__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
ERROR: Asked last regs, when  none are used
ERROR: Asked to free reg when currently 0 are used
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_0 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: fooFalse
If void, an extra ret will be added
Ret type: 5
Lex Ate token bool__
Lex Ate token  id__tooTrue__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[tooTrue]>>
[[[ added func: tooTrue with 0 params and label: ]]]
FuncHead_IR for func: tooTrue
got label label_67 in line: -1
[set_func_label] label label_67 for function tooTrue
[get_func_label] tooTrue's label is: label_67
written label: label_67
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token  id__printi__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  num__1__
Lex Ate token )__
[Exp_IR] Exp -> Num:1
END_OF [Exp_IR] Exp -> Num
<<ExpList_Semantic>> explist -> exp
exp is of type INT
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments printi
[get_func_label] printi's label is: printi
[Emitter] REstore_registers: -1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token return__
[MARKER IR]: label: bp_label_2
Lex Ate token true__
Lex Ate token  ;__
<<RetExp, ExpT:[5] scopeT:[5]>>
[Statement_IR] Return noneVoid
ERROR: Asked last regs, when  none are used
ERROR: Asked to free reg when currently 0 are used
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_2 breaklist size is 0
Lex Ate token  }__
[FuncDeclNode_IR]: 
checking retType of func: tooTrue
If void, an extra ret will be added
Ret type: 5
Lex Ate token void__
Lex Ate token  id__main__
Lex Ate token  (__
Lex Ate token )__
<<FuncHead_semantic, id:[main]>>
[[[ added func: main with 0 params and label: ]]]
FuncHead_IR for func: main
got label label_105 in line: -1
[set_func_label] label label_105 for function main
[get_func_label] main's label is: label_105
written label: label_105
END_OF [FuncHead_IR] 
Lex Ate token  {__
Lex Ate token bool__
Lex Ate token  id__x__
Lex Ate token  ;__
<<[Statement_Semantic][TypeID_SC] id:[x]type:[]>>
<<adding var: [x] of type [5]>>[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States->SignleState]  nextlistSize=1
Lex Ate token  id__print__
[MARKER IR]: label: bp_label_4
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"B:"__
[Exp_IR] Exp -> string"B:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: -1
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_4 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_5
Lex Ate token  =__
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_6
Lex Ate token  id__fooFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments fooFalse
regNum=0
[get_func_label] fooFalse's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfooFalse
[SJ_Exp_IR]: fooFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_6
exp1:true truelistSize: 1
exp2:fooFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_5 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_7
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_8
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_9
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_7 breaklist size is 0
[MARKER IR]: label: bp_label_11
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"C:"__
[Exp_IR] Exp -> string"C:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_11 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_12
Lex Ate token  =__
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_13
Lex Ate token  id__fooFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments fooFalse
regNum=0
[get_func_label] fooFalse's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfooFalse
[SJ_Exp_IR]: fooFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_13
exp1:false truelistSize: 0
exp2:fooFalse truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_12 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_14
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_15
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_16
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_14 breaklist size is 0
[MARKER IR]: label: bp_label_18
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"D:"__
[Exp_IR] Exp -> string"D:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_18 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_19
Lex Ate token  =__
Lex Ate token true__
Lex Ate token or__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_20
Lex Ate token  id__tooTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments tooTrue
regNum=0
[get_func_label] tooTrue's label is: label_67
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->calltooTrue
[SJ_Exp_IR]: tooTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_20
exp1:true truelistSize: 1
exp2:tooTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 2
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_19 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_21
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_22
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_23
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_21 breaklist size is 0
[MARKER IR]: label: bp_label_25
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"E:"__
[Exp_IR] Exp -> string"E:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_25 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_26
Lex Ate token  =__
Lex Ate token false__
Lex Ate token or__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_27
Lex Ate token  id__tooTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments tooTrue
regNum=0
[get_func_label] tooTrue's label is: label_67
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->calltooTrue
[SJ_Exp_IR]: tooTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 Or M Exp2 ] 
Backpatched label: bp_label_27
exp1:false truelistSize: 0
exp2:tooTrue truelistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_26 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_28
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_29
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_30
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_28 breaklist size is 0
[MARKER IR]: label: bp_label_32
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"F:"__
[Exp_IR] Exp -> string"F:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_32 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_33
Lex Ate token  =__
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_34
Lex Ate token  id__fooFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments fooFalse
regNum=0
[get_func_label] fooFalse's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfooFalse
[SJ_Exp_IR]: fooFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:fooFalse falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_33 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_35
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_36
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_37
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_35 breaklist size is 0
[MARKER IR]: label: bp_label_39
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"G:"__
[Exp_IR] Exp -> string"G:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_39 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_40
Lex Ate token  =__
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_41
Lex Ate token  id__fooFalse__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments fooFalse
regNum=0
[get_func_label] fooFalse's label is: label_29
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->callfooFalse
[SJ_Exp_IR]: fooFalse
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:fooFalse falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_40 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_42
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_43
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_44
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_42 breaklist size is 0
[MARKER IR]: label: bp_label_46
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"H:"__
[Exp_IR] Exp -> string"H:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_46 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_47
Lex Ate token  =__
Lex Ate token true__
Lex Ate token and__
[SJ_Exp_IR]: true
[MARKER IR]: label: bp_label_48
Lex Ate token  id__tooTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments tooTrue
regNum=0
[get_func_label] tooTrue's label is: label_67
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->calltooTrue
[SJ_Exp_IR]: tooTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:true falselistSize: 0
exp2:tooTrue falselistSize: 1
Exp: falselistSize: 1
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_47 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_49
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_50
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_51
Lex Ate token  id__print__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_49 breaklist size is 0
[MARKER IR]: label: bp_label_53
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"I:"__
[Exp_IR] Exp -> string"I:"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_53 breaklist size is 0
Lex Ate token  id__x__
[MARKER IR]: label: bp_label_54
Lex Ate token  =__
Lex Ate token false__
Lex Ate token and__
[SJ_Exp_IR]: false
[MARKER IR]: label: bp_label_55
Lex Ate token  id__tooTrue__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token )__
<<CallSemantics [ID(Exp)] >>
tmpParams: 0
tmpActP: 0
tmptmp: 1
[Call_IR] : no arguments tooTrue
regNum=0
[get_func_label] tooTrue's label is: label_67
[Emitter] REstore_registers: 0
END_OF [Call_IR]
[Exp_IR] Exp->calltooTrue
[SJ_Exp_IR]: tooTrue
Lex Ate token  ;__
[Exp_IR: Exp-> Exp1 And M Exp2 ] 
exp1:false falselistSize: 1
exp2:tooTrue falselistSize: 1
Exp: falselistSize: 2
Exp: truelistSize: 1
<<Statement_Semantic with id[x]=exp>>
[Statement_next_patcher_IR] previously held nextlist size:2
[Statement_next_patcher_IR] currently held nextlist size:3
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 1 with label: bp_label_54 breaklist size is 0
Lex Ate token if__
[MARKER IR]: label: bp_label_56
Lex Ate token  (__
Lex Ate token  id__x__
Lex Ate token )__
<<[Exp_Semantic_Id] id:[x]>>
[Exp_IR] Exp -> id: x
END_OF [Exp_IR] Exp -> id
[SJ_Exp_IR]: x
[MARKER IR]: label: bp_label_57
Lex Ate token  id__print__
Lex Ate token  (__
CallHeader_IR
[Emitter] store_registers
END_OF CallHeader_IR
Lex Ate token  str__"TRUE"__
[Exp_IR] Exp -> string"TRUE"
END_OF [Exp_IR] Exp -> string
Lex Ate token )__
<<ExpList_Semantic>> explist -> exp
exp is of type STRING
[ExpList_IR: ExpList->Exp]: 
<<CallSemantics [ID(Exp)] >>
tmpParams: 1
tmpActP: 1
tmptmp: 1
[Call_IR] : with arguments print
[get_func_label] print's label is: print
found a string typed parameter print
[Emitter] REstore_registers: 0
END_OF [Call_IR]
Lex Ate token  ;__
[Statement_IR Call] nestlistSize: 0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR Call] nestlistSize: 1
[MARKER IR]: label: bp_label_58
Lex Ate token  }__
size of next list for if is1
size of next list for else is0
[Statement_next_patcher_IR] previously held nextlist size:0
[Statement_next_patcher_IR] currently held nextlist size:1
[Statement_IR: States -> states1 M singleState]
Num of nextlist to bp: 3 with label: bp_label_56 breaklist size is 0
[FuncDeclNode_IR]: 
checking retType of func: main
If void, an extra ret will be added
Ret type: 1
[Program_IR] backpatching line number 4 with [get_func_label] main's label is: label_105
label_105
[get_func_label] main's label is: label_105
ignore me1 (label_105)
[END_OF Program_IR]
