%{
    #include <iostream>
    #include "source.hpp"
    #include "semantic_rules.hpp"
    #define YYSTYPE Node*
    int yylex();
    void yyerror(const char*);
    int yydebug=1; //TODO remove this
%}


%token VOID 
%token INT
%token BYTE
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token IF

%token WHILE
%token SWITCH
%token CASE
%token BREAK
%token DEFAULT
%token COLON
%token SC
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE
%token ASSIGN

%left RELOP
%left BINOP
%left OR
%left AND
%left NOT

%token ID
%nonassoc NUM
%token STRING
%nonassoc B


%left L_ASSOC
%left PRIO_REGIF
%left ELSE
%left PRIO_IFELSE

%%

Program:        Funcs


Funcs:          FuncDecl Funcs
                | /*epsilon*/

FuncDecl:       FuncHead FuncState

FuncHead:		RetType ID LPAREN Func_Scope_init Formals RPAREN {std::cout << "[FinFuncHead]";}

Func_Scope_init: 	/*epsilon*/

FuncState:		LBRACE Statements RBRACE


RetType:        Type
                |VOID

Formals:        FormalsList
                | /*epsilon*/

FormalsList:    FormalDecl
				|FormalDecl COMMA FormalsList

FormalDecl:	Type ID

Statements:		Statement {std::cout << "[State]";}
				|Statements Statement {std::cout << "[States S]";}

Statement:		LBRACE Scope_init Statements RBRACE
				| Type ID SC {std::cout << "[TypeID_SC]";}
				| Type ID ASSIGN Exp SC {std::cout << "[TypeIDAssignExpSC]";}
				| ID ASSIGN Exp SC
				| Call SC
				| RETURN SC {std::cout << "[returnSC]";}
				| RETURN Exp SC
				| IF LPAREN BoolExp RPAREN Scope_init Statement Scope_end PossibleElse
				| WHILE LPAREN BoolExp RPAREN While_Scope_init Statement
				| BREAK SC
				| SwitchHead CaseList RBRACE SC {std::cout << "[Switch]";}

SwitchHead:     SWITCH LPAREN NumExp RPAREN LBRACE  {std::cout << "[switchHead]";}

PossibleElse:   /*epsilon*/ %prec PRIO_REGIF
                | ELSE Scope_init Statement Scope_end %prec PRIO_IFELSE

NumExp:			Exp

BoolExp:		Exp

While_Scope_init:	/*epsilon*/


Scope_init:	/*epsilon*/

Scope_end:	/*epsilon*/

CaseList:		CaseList CaseStatement {std::cout << "[CaseList CaseState]";}
				| CaseStatement {std::cout << "[CaseState]";}

CaseStatement:	CaseDec Statements {std::cout << "[CaseDec S]";}
				|CaseDec {std::cout << "[CaseDec]";}

CaseDec:		CASE NUM COLON {std::cout << "[NumCase]";}
				| CASE NUM B COLON {std::cout << "[Num_B_Case]";}
				| DEFAULT COLON {std::cout << "[DefaultCase]";}

Call:			ID LPAREN ExpList RPAREN
				| ID LPAREN RPAREN

ExpList:		Exp
				|Exp COMMA ExpList

Type:			INT
				| BYTE
				| BOOL

Exp:			Exp AND Exp %prec L_ASSOC
				| Exp OR Exp %prec L_ASSOC
				| Exp RELOP Exp %prec L_ASSOC
				| Exp BINOP Exp %prec L_ASSOC
				| LPAREN Exp RPAREN 
				| ID {std::cout << "[ID]";}
				| Call
				| NUM {std::cout << "[NUM]";}
				| NUM B {std::cout << "[NUM B]";}
				| STRING
				| TRUE
				| FALSE
				| NOT Exp



%%
void yyerror (const char*) { std::cout << "syntax error" << std::endl; }

int main(){
	return yyparse();
}




